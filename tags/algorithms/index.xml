<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithms on Weihang Lo</title><link>https://weihanglo.tw/tags/algorithms/</link><description>Recent content in Algorithms on Weihang Lo</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 16 Feb 2021 00:00:00 +0800</lastBuildDate><atom:link href="https://weihanglo.tw/tags/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>雙端佇列 Deque</title><link>https://weihanglo.tw/posts/2021/deque/</link><pubDate>Tue, 16 Feb 2021 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2021/deque/</guid><description>本篇從 Rust Algorithm Club 移植，若欲閱讀最新版，請移駕至Rust 演算法俱樂部：布隆過濾器 Bloom Filter 一文，此文不同步更新。
雙端佇列（double-ended queue，通常縮寫為 deque）是一般化（generalize）的佇列或堆疊。比起佇列只能「先進先出 FIFO」，以及堆疊只有「後進先出 LIFO」，雙端佇列可以從最前端或最末端任意方向，在常數時間複雜度內增刪元素，更為方便。
雙端佇列常見用動態陣列或是鏈結串列實作，動態陣列的實作會因空間不夠，需要重新配置記憶體，但通常會支援隨機存取（random access）；鏈結串列的實作版本雖無法隨機存取，相對地增刪元素不需記憶體重配置。
雙端佇列顯著的缺點是：無論以動態陣列或連結串列實作，基本款實作通常無法在 $O(k)$ 時間複雜度的情況下，選定範圍內 k 個元素並取得單一切片（slice）。這肇因於動態陣列的實作通常內部儲存空間經過多次增刪，空間利用會不連續；而用鏈結串列實作者，則因不支援隨機存取而無法達到相應的複雜度。
本次實作的程式碼置於在 rust_algorithm_club::collections::Deque API 文件中。
架構設計 雙端佇列有個實作重點：可在常數時間從頭尾兩端增刪元素。在資料結構設計上，會儲存分別指向頭尾的兩個指標，長相可能如下：
struct Deque { head: usize, tail: usize, storage: SomeStorageType, } 第一直覺肯定是選用雙向鏈結串列可以雙向增刪節點的特性，作為解決方案。不過這裡我們採用動態陣列實作，更精確來說，底層儲存容器同樣是有兩個分別指向頭尾的指標的「環形緩衝區（Ring buffer）」。
環形緩衝區 環形緩衝區（Ring buffer） 是一個長度大小固定的緩衝區，可以視為頭尾相連的記憶體區塊，上圖雖以環狀呈現，但在計算機架構中儲存方式通常是線性陣列，再搭配指向頭端的 head 與指向尾端的 tail 兩個指標構成。
環形緩衝區有分兩種，一種是有循環的，緩衝區寫滿了就覆蓋尾端舊的資料，另一種是不會循環，緩衝區會放滿的，後者就是本次實作會用到的，以下將來探討：
如何表示環形緩衝區為空 如何表示環形緩衝區已滿 環形緩衝區如何增加元素 這節以 ASCII chart 表示之。
h: head t: tail x: no data [number]: has data 下面一個容量為 8，尚未有任何元素存入的環形緩衝區，這裡觀察到，若 head 與 tail 指向的儲存單元相同，換句話說兩者索引值相同，則緩衝區為空。</description></item><item><title>布隆過濾器 Bloom Filter</title><link>https://weihanglo.tw/posts/2020/bloom-filter/</link><pubDate>Fri, 28 Aug 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/bloom-filter/</guid><description>本篇從 Rust Algorithm Club 移植，若欲閱讀最新版，請移駕至Rust 演算法俱樂部：布隆過濾器 Bloom Filter 一文，此文不同步更新。
Bloom filter 是一種機率資料結構（probabilistic data structure），類似於集合，常用於需快速驗證成員是否「可能存在」或是「絕對不存在」在容器中，亦即有機會出現假陽性（false positive），但絕不會有假陰性（false negative）。
Bloom filter 的優勢是：
類似集合，可在 $O(1)$ 時間複雜度驗證成員是否存在，卻僅需相對少的儲存空間。 承上，在 0.1% 錯誤率下儲存一百萬個元素僅需 1.71 MiB。 非常容易實作的機率資料結構，僅需多次雜湊。 Bloom filter 則有以下短處：
經典款 Bloom filter 容器大小固定（fixed-size），無法動態調整儲存空間。 可能給出假陽性答案：回報存在但實際不存在，且錯誤隨數量變多上升。 自身不儲存成員資料，需要有額外的儲存資料方案。 只能新增成員，但不能移除成員（可透過變形解決）。 若輸入資料集本身離散，接近隨機存取，無法充分利用 CPU cache。 承上，因為隨機存取，不利於延伸到記憶體以外的外部儲存裝置。 Bloom filter 常見應用場景為：
資料庫利用 Bloom filter 中減少實際存取 disk 的 IO 開銷。 Chromium 瀏覽器驗證大量惡意連結。 Medium 避免推薦已推薦過的文章。 小知識：bloom 是開花之意，但 Bloom filter 和開花沒任何關係，只因發明人姓氏為 Bloom</description></item><item><title>漸進符號 Asymptotic Notation</title><link>https://weihanglo.tw/posts/2018/asymptotic-notation/</link><pubDate>Thu, 31 May 2018 23:38:59 +0800</pubDate><guid>https://weihanglo.tw/posts/2018/asymptotic-notation/</guid><description>這是個人第一次撰寫 CS 基礎知識的文章，同時也是 Rust Algorithm Club 基礎概念的首篇文章，目前 Rust Algorithm Club 尚未完工，請各位敬請期待。
（撰於 2018-05-31）
日常生活中，你會如何描述處理事情的效率？
「原來她五分鐘內可以吃掉一頭牛！」
「房間這麼小你還能擺一堆雜物？還不快收拾！」
這些描述方法，著重在處理事情的花費時間，或單位空間內的儲存量。描述演算法的效率也如此，就是「測量演算法的執行成本」，例如這個排序法花了 10 秒鐘跑完兩萬筆資料，或是這個模擬演算法很吃資源需要 32 GB 的記憶體。
然而，在不同的機器規格、環境溫濕度、程式語言、實作方式，以及有沒有放乖乖的變異影響下，相同演算法的執行成本常常不一致。為了消弭這些外部因素，讓分析演算法能夠更科學化。科學家抽絲剝繭，發明一個方法：
「統計演算法內所需操作步驟的數目。」
這是最簡單，最粗淺比較不同演算法效率的作法。
用數學表示演算法效率 「計算步驟數目」很像中小學的數學題目：某公司有三個能力相異的工程師，有的工程師一天解決一個 bug，有的工程師連續工作後效率大幅滑落。每個工程師的除蟲效率可以畫成「bug 數 - 解決 bug 所需時數」函數，橫軸為待處理的臭蟲數，縱軸為解決臭蟲所需時數，如圖一與表所示。
時數 \(\log N\) \(N\) \(N \log N\) \(N=5\) 2.236 5 8.046 \(N=30\) 5.477 30 102.036 不論從圖或表，我們都可以明確看出，當 bug 數目小時，每個工程師耗時差不多；當 bug 數目成長到一定程度時，效率好與效率差的工程師差距就很明顯了。
我們把場景拉回演算法的範疇，再闡明一次。上述的除蟲效率函數關係，可以簡單視為為「輸入資料量 - 運算成本」關係之函數。例如 \(f(x)=x^2+3x+6\)。當輸入資料量增大時，成本也隨之上升，這個用來描述演算法執行成本與輸入資料量之關係的函數，我們稱之為該演算法的「複雜度」。</description></item></channel></rss>