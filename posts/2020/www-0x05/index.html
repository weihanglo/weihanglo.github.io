<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>WWW 0x05: 若單體服務是屎，微服務就是許多屎 | Life is a refactoring process without tests</title>
<meta name=keywords content="Weekly,Microservice">
<meta name=description content="這裡是 WWW 第伍期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食">
<meta name=author content>
<link rel=canonical href=https://weihanglo.tw/posts/2020/www-0x05/>
<link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style>
<link rel=icon href=https://weihanglo.tw/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://weihanglo.tw/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://weihanglo.tw/favicon-32x32.png>
<link rel=apple-touch-icon href=https://weihanglo.tw/apple-touch-icon.png>
<link rel=mask-icon href=https://weihanglo.tw/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:!0},{left:'$',right:'$',display:!1},{left:'\\(',right:'\\)',display:!1},{left:'\\[',right:'\\]',display:!0}],throwOnError:!1})})</script>
<meta property="og:title" content="WWW 0x05: 若單體服務是屎，微服務就是許多屎">
<meta property="og:description" content="這裡是 WWW 第伍期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食">
<meta property="og:type" content="article">
<meta property="og:url" content="https://weihanglo.tw/posts/2020/www-0x05/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-02-22T00:00:00+08:00">
<meta property="article:modified_time" content="2020-02-22T00:00:00+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="WWW 0x05: 若單體服務是屎，微服務就是許多屎">
<meta name=twitter:description content="這裡是 WWW 第伍期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://weihanglo.tw/posts/"},{"@type":"ListItem","position":3,"name":"WWW 0x05: 若單體服務是屎，微服務就是許多屎","item":"https://weihanglo.tw/posts/2020/www-0x05/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"WWW 0x05: 若單體服務是屎，微服務就是許多屎","name":"WWW 0x05: 若單體服務是屎，微服務就是許多屎","description":"這裡是 WWW 第伍期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食","keywords":["Weekly","Microservice"],"articleBody":"這裡是 WWW 第伍期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。\nMicroservices: From Design to Deployment 這是 microservices.io 的作者在 NGINX blog 上面的系列文章，雖然是 2015 年的舊文，從起源、問題，和模式來理解微服務依然詳實，看完絕對驚呼：原來現在 Cloud Native 世界這麼混亂是有些道理！\n Note：不知道為什麼作者很愛提到 Netflix 各種微服務的專案，不過 Netflix 的 Java 開源微服務工具數量之多還真大開眼界\n 以下分別摘要每個主題：\nIntroduction to Microservices 簡介什麼是微服務，有什麼優缺點，並介紹微服務架構下常見元件，鋪陳給接下來的系列文，總之是個不想看可跳過的篇章。\nBuilding Microservices: Using an API Gateway 介紹 API gateway 為什麼存在：統一微服務一致對外的介面，解耦客戶端與微服務們，但缺點是 API gateway 需要更多 operational cost，也要維持 hign availibility。\n實作 API gateway 要注意以下幾點：\n Performance：所有請求都會通過 gateway，所以效能和擴充性一定要好 Reactive Programming 模式：gateway 需要集合各種請求，善用 Reactive programming 模式很有幫助 Service Invocation：微服務之間就是 IPC（inter-process communication），如何透過不同模式相互 invoke 很重要，下一章會詳述 Service Discovery：如何讓服務之間互相知道彼此，就是「服務發現」的工作了，分為 client-side 和 service-side discovery，之後有專文說明 Partial Failures：微服務之間不像單體服務可以用簡單的 transaction 處理錯誤並 rollback，處理部分錯誤，保持 CAP 的 consistency 是個重要課題  Building Microservices: Inter‑Process Communication in a Microservices Architecture 介紹微服務間 IPC（inter‑process communication）的方法與模式，這是系列文中最接近實作層面的文章，很棒。\nIPC 常見的溝通模式根據同步與非同步，以及一對一或一對多，有許多不同的作法，例如 request-respone（一對一、同步）、publish-subscribe（一對多、非同步）。而常見的技術有：\n Message-based communication（message queue）  client-service 完全解耦合 message 有 buffering 有明確的 IPC，反觀 RPC 可能會以為自己在 invoke local function 系統複雜度增加不少 非同步，不容易做到同步的 request-response 互動模式   同步溝通：REST  對 entity/resource 操作，很簡單，大家都熟悉 如果用 HTTP，防火牆通常不會擋 因為是同步的溝通，client 和 server 要一起等待互動結果出爐 client 必須明確知道自己要到哪裡找資源，這部分有較重的耦合 REST 有個 4 level 的 Maturity Model 可以參考   同步溝通：Thrift（注：其實應該要泛稱各種 IDL）  一個老牌，可以作為 IDL 的 binary format 有 compiler 可以協助產生各種語言的 code （注：個人偏好 ProtoBuf 或是 FlatBuffer 這些更高效支援也廣的格式）    而 message format 也是重要的課題：選擇好用的 IDL 可以減少雙方來來去去修改 spec 的時間，例如 JSON schema 或 Protocol Buffer。\nService Discovery in a Microservices Architecture Service discovery 可以動態改變每個服務的位置，讓服務之間不再需要寫死 IP，使得部署與 scaling 更為彈性，主要分為兩種方式：client-side 與 server-side。\n client-side：client 詢問 service registry 來取得可用的服務位置，而且可以做到 client-side load balancing，但相對地，不同語言的 client 都需要實作一遍這個 discovery 邏輯 service-side：服務隱藏在 load balancer 後，load balancer 詢問 service registry，再決定要用哪個服務，完全抽象於 client 外，但也必須導入 load balancer 這個角色而且必須做 HA。  此外，實作 service discovery 最重要的元件是 service registry，將服務註冊在 registry 上，讓其他服務可以透過 registry 發現彼此，常見使用 etcd、consul 和 ZooKeeper 達成。註冊的方式有\n 自我註冊 Self‑Registration：服務自己主動向 registry 註冊/取消註冊 第三方註冊 Third‑Party Registration：額外的 registrar 訂閱該服務的事件或 healthcheck，來決定是否註冊或取消註冊  Event-Driven Data Management for Microservices 本篇探討在微服務這種分散式架構下，每個服務都有獨立的資料庫，甚至資料庫的類型還不一樣，那如何保證 ACID、如何在 CAP 理論中作出取捨，two-phase commit（2PC）過於注重 C（consistency），不符合現代架構要求的 availability，因此，這裡提出 event-driven architecture：\n 事情發生會 publish event 其他服務會訂閱這些 event 做對應處理 可以保證 BASE model 中的 eventual consistency 可以透過特定方法達成 Atomicity  使用 local 的 transaction： event 不直接 publish 到 message broker，而是利用 local 的 transaction 寫入到 event table 中，再透過另一個 Event publisher 服務發布至 message broker 從資料庫 transaction log 挖寶： transaction log 裡面資料 100% 完整，可做為 event 來源，但是 log 太生不好處理，而且和選用的資料庫緊耦合 使用 Event sourcing： 將原本 mutate 資料庫 table 的操作都改成一個個事件，例如 Order 狀態改變變成一個個 Order.completed Order.pending 事件，因為不再將資料映射到 Object entity，不僅省了 ORM 抽象，更保證資料 consistency（因為根本不會 mutate state），在 persistent data 的同時也會直接 publish event，但缺點是不好設計，而且不直觀，需要使用 Command Query Responsibility Segregation（CQRS） 達成特地的查詢操作。    Choosing a Microservices Deployment Strategy 由於微服務架構不論數量、語言、框架種類通常比單體架構更多，因此更難部署，這篇整理了許多不同的部署策略：\n 一個 host 多服務  Pros：部署最直接、資源運用率高 Cons：抽象化不夠，服務直接沒有隔離   一個 VM 一個服務  Pros：服務間獨立、安全性 Cons：資源運用率低、啟動慢   一個 container 一個服務  Pros：啟動快、image 容器化容易部署、隔離完善 Cons：資源運用率比 VM 高但比單一 host 低、比 VM 安全性低一些 如果有 cluster manager 例如 kubernetes 會增加資源運用率   Serverless  Pros：不需管理 infra、by request 算錢 Cons：僅適合 stateless 服務但不適合 long-running 服務、受限於 runtime 語言支援程度    Refactoring a Monolith into Microservices 如何從遷移到基本上是老生常談，還是條列有提到的策略好惹：\n 停止堆屎： 知道目前的單體架構是一坨屎，新 feature 就別再往上加了 切堆分層： 架構通常分為 1）presentation layer，和 UI 或 REST API 等相關，2）business logic layer，都是業務邏輯，以及 3）data-access layer，存取資料庫或是訊息中介 message queue 等。切好切滿更容易抽象出微服務 抽出服務： 乍看之下不知道在講啥，但提到需要以 module 為單位來抽象（前提是 module 權責分明），如果本來就有遵守 Domain Model pattern 會更好抽象  ","wordCount":"2487","inLanguage":"en","datePublished":"2020-02-22T00:00:00+08:00","dateModified":"2020-02-22T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://weihanglo.tw/posts/2020/www-0x05/"},"publisher":{"@type":"Organization","name":"Life is a refactoring process without tests","logo":{"@type":"ImageObject","url":"https://weihanglo.tw/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://weihanglo.tw accesskey=h title="Life is a refactoring process without tests (Alt + H)">Life is a refactoring process without tests</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=https://weihanglo.tw/ title=Home>
<span>Home</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
WWW 0x05: 若單體服務是屎，微服務就是許多屎
</h1>
<div class=post-meta><span title="2020-02-22 00:00:00 +0800 +0800">February 22, 2020</span>&nbsp;·&nbsp;5 min
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#microservices-from-design-to-deploymenthttpswwwnginxcomblogintroduction-to-microservices aria-label="Microservices: From Design to Deployment"><a href=https://www.nginx.com/blog/introduction-to-microservices/>Microservices: From Design to Deployment</a></a><ul>
<li>
<a href=#introduction-to-microserviceshttpswwwnginxcomblogintroduction-to-microservices aria-label="Introduction to Microservices"><a href=https://www.nginx.com/blog/introduction-to-microservices/>Introduction to Microservices</a></a></li>
<li>
<a href=#building-microservices-using-an-api-gatewayhttpswwwnginxcomblogbuilding-microservices-using-an-api-gateway aria-label="Building Microservices: Using an API Gateway"><a href=https://www.nginx.com/blog/building-microservices-using-an-api-gateway/>Building Microservices: Using an API Gateway</a></a></li>
<li>
<a href=#building-microservices-interprocess-communication-in-a-microservices-architecturehttpswwwnginxcomblogbuilding-microservices-inter-process-communication aria-label="Building Microservices: Inter‑Process Communication in a Microservices Architecture"><a href=https://www.nginx.com/blog/building-microservices-inter-process-communication/>Building Microservices: Inter‑Process Communication in a Microservices Architecture</a></a></li>
<li>
<a href=#service-discovery-in-a-microservices-architecturehttpswwwnginxcomblogservice-discovery-in-a-microservices-architecture aria-label="Service Discovery in a Microservices Architecture"><a href=https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/>Service Discovery in a Microservices Architecture</a></a></li>
<li>
<a href=#event-driven-data-management-for-microserviceshttpswwwnginxcomblogevent-driven-data-management-microservices aria-label="Event-Driven Data Management for Microservices"><a href=https://www.nginx.com/blog/event-driven-data-management-microservices/>Event-Driven Data Management for Microservices</a></a></li>
<li>
<a href=#choosing-a-microservices-deployment-strategyhttpswwwnginxcomblogdeploying-microservices aria-label="Choosing a Microservices Deployment Strategy"><a href=https://www.nginx.com/blog/deploying-microservices/>Choosing a Microservices Deployment Strategy</a></a></li>
<li>
<a href=#refactoring-a-monolith-into-microserviceshttpswwwnginxcomblogrefactoring-a-monolith-into-microservices aria-label="Refactoring a Monolith into Microservices"><a href=https://www.nginx.com/blog/refactoring-a-monolith-into-microservices/>Refactoring a Monolith into Microservices</a></a>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>這裡是 WWW 第伍期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。</p>
<h2 id=microservices-from-design-to-deploymenthttpswwwnginxcomblogintroduction-to-microservices><a href=https://www.nginx.com/blog/introduction-to-microservices/>Microservices: From Design to Deployment</a><a hidden class=anchor aria-hidden=true href=#microservices-from-design-to-deploymenthttpswwwnginxcomblogintroduction-to-microservices>#</a></h2>
<p><img loading=lazy src=https://i.imgur.com/6uLbuzb.png alt>
</p>
<p>這是 <a href=https://microservices.io>microservices.io</a> 的作者在 NGINX blog 上面的系列文章，雖然是 2015 年的舊文，從起源、問題，和模式來理解微服務依然詳實，看完絕對驚呼：原來現在 Cloud Native 世界這麼混亂是有些道理！</p>
<blockquote>
<p>Note：不知道為什麼作者很愛提到 Netflix 各種微服務的專案，不過 Netflix 的 Java 開源微服務工具數量之多還真大開眼界</p>
</blockquote>
<p>以下分別摘要每個主題：</p>
<h3 id=introduction-to-microserviceshttpswwwnginxcomblogintroduction-to-microservices><a href=https://www.nginx.com/blog/introduction-to-microservices/>Introduction to Microservices</a><a hidden class=anchor aria-hidden=true href=#introduction-to-microserviceshttpswwwnginxcomblogintroduction-to-microservices>#</a></h3>
<p>簡介什麼是微服務，有什麼優缺點，並介紹微服務架構下常見元件，鋪陳給接下來的系列文，總之是個不想看可跳過的篇章。</p>
<h3 id=building-microservices-using-an-api-gatewayhttpswwwnginxcomblogbuilding-microservices-using-an-api-gateway><a href=https://www.nginx.com/blog/building-microservices-using-an-api-gateway/>Building Microservices: Using an API Gateway</a><a hidden class=anchor aria-hidden=true href=#building-microservices-using-an-api-gatewayhttpswwwnginxcomblogbuilding-microservices-using-an-api-gateway>#</a></h3>
<p>介紹 API gateway 為什麼存在：統一微服務一致對外的介面，解耦客戶端與微服務們，但缺點是 API gateway 需要更多 operational cost，也要維持 hign availibility。</p>
<p>實作 API gateway 要注意以下幾點：</p>
<ul>
<li>Performance：所有請求都會通過 gateway，所以效能和擴充性一定要好</li>
<li>Reactive Programming 模式：gateway 需要集合各種請求，善用 Reactive programming 模式很有幫助</li>
<li>Service Invocation：微服務之間就是 IPC（inter-process communication），如何透過不同模式相互 invoke 很重要，下一章會詳述</li>
<li>Service Discovery：如何讓服務之間互相知道彼此，就是「服務發現」的工作了，分為 client-side 和 service-side discovery，之後有專文說明</li>
<li>Partial Failures：微服務之間不像單體服務可以用簡單的 transaction 處理錯誤並 rollback，處理部分錯誤，保持 CAP 的 consistency 是個重要課題</li>
</ul>
<h3 id=building-microservices-interprocess-communication-in-a-microservices-architecturehttpswwwnginxcomblogbuilding-microservices-inter-process-communication><a href=https://www.nginx.com/blog/building-microservices-inter-process-communication/>Building Microservices: Inter‑Process Communication in a Microservices Architecture</a><a hidden class=anchor aria-hidden=true href=#building-microservices-interprocess-communication-in-a-microservices-architecturehttpswwwnginxcomblogbuilding-microservices-inter-process-communication>#</a></h3>
<p>介紹微服務間 IPC（inter‑process communication）的方法與模式，這是系列文中最接近實作層面的文章，很棒。</p>
<p>IPC 常見的溝通模式根據同步與非同步，以及一對一或一對多，有許多不同的作法，例如 request-respone（一對一、同步）、publish-subscribe（一對多、非同步）。而常見的技術有：</p>
<ul>
<li><strong>Message-based communication（message queue）</strong>
<ul>
<li>client-service 完全解耦合</li>
<li>message 有 buffering</li>
<li>有明確的 IPC，反觀 RPC 可能會以為自己在 invoke local function</li>
<li>系統複雜度增加不少</li>
<li>非同步，不容易做到同步的 request-response 互動模式</li>
</ul>
</li>
<li><strong>同步溝通：REST</strong>
<ul>
<li>對 entity/resource 操作，很簡單，大家都熟悉</li>
<li>如果用 HTTP，防火牆通常不會擋</li>
<li>因為是同步的溝通，client 和 server 要一起等待互動結果出爐</li>
<li>client 必須明確知道自己要到哪裡找資源，這部分有較重的耦合</li>
<li>REST 有個 <a href=https://martinfowler.com/articles/richardsonMaturityModel.html>4 level 的 Maturity Model</a> 可以參考</li>
</ul>
</li>
<li><strong>同步溝通：Thrift（注：其實應該要泛稱各種 IDL）</strong>
<ul>
<li>一個老牌，可以作為 IDL 的 binary format</li>
<li>有 compiler 可以協助產生各種語言的 code</li>
<li>（注：個人偏好 ProtoBuf 或是 FlatBuffer 這些更高效支援也廣的格式）</li>
</ul>
</li>
</ul>
<p>而 message format 也是重要的課題：選擇好用的 IDL 可以減少雙方來來去去修改 spec 的時間，例如 <a href=https://json-schema.org/>JSON schema</a> 或 <a href=https://developers.google.com/protocol-buffers>Protocol Buffer</a>。</p>
<h3 id=service-discovery-in-a-microservices-architecturehttpswwwnginxcomblogservice-discovery-in-a-microservices-architecture><a href=https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/>Service Discovery in a Microservices Architecture</a><a hidden class=anchor aria-hidden=true href=#service-discovery-in-a-microservices-architecturehttpswwwnginxcomblogservice-discovery-in-a-microservices-architecture>#</a></h3>
<p>Service discovery 可以動態改變每個服務的位置，讓服務之間不再需要寫死 IP，使得部署與 scaling 更為彈性，主要分為兩種方式：client-side 與 server-side。</p>
<ul>
<li>client-side：client 詢問 service registry 來取得可用的服務位置，而且可以做到 client-side load balancing，但相對地，不同語言的 client 都需要實作一遍這個 discovery 邏輯</li>
<li>service-side：服務隱藏在 load balancer 後，load balancer 詢問 service registry，再決定要用哪個服務，完全抽象於 client 外，但也必須導入 load balancer 這個角色而且必須做 HA。</li>
</ul>
<p>此外，實作 service discovery 最重要的元件是 service registry，將服務註冊在 registry 上，讓其他服務可以透過 registry 發現彼此，常見使用 <a href=https://etcd.io/>etcd</a>、<a href=https://www.consul.io>consul</a> 和 <a href=https://zookeeper.apache.org>ZooKeeper</a> 達成。註冊的方式有</p>
<ul>
<li>自我註冊 Self‑Registration：服務自己主動向 registry 註冊/取消註冊</li>
<li>第三方註冊 Third‑Party Registration：額外的 registrar 訂閱該服務的事件或 healthcheck，來決定是否註冊或取消註冊</li>
</ul>
<h3 id=event-driven-data-management-for-microserviceshttpswwwnginxcomblogevent-driven-data-management-microservices><a href=https://www.nginx.com/blog/event-driven-data-management-microservices/>Event-Driven Data Management for Microservices</a><a hidden class=anchor aria-hidden=true href=#event-driven-data-management-for-microserviceshttpswwwnginxcomblogevent-driven-data-management-microservices>#</a></h3>
<p>本篇探討在微服務這種分散式架構下，每個服務都有獨立的資料庫，甚至資料庫的類型還不一樣，那如何保證 ACID、如何在 CAP 理論中作出取捨，two-phase commit（2PC）過於注重 C（consistency），不符合現代架構要求的 availability，因此，這裡提出 <strong>event-driven architecture</strong>：</p>
<ul>
<li>事情發生會 publish event</li>
<li>其他服務會訂閱這些 event 做對應處理</li>
<li>可以保證 <a href="https://queue.acm.org/detail.cfm?id=1394128">BASE model</a> 中的 eventual consistency</li>
<li>可以透過特定方法達成 Atomicity
<ul>
<li><strong>使用 local 的 transaction：</strong> event 不直接 publish 到 message broker，而是利用 local 的 transaction 寫入到 event table 中，再透過另一個 Event publisher 服務發布至 message broker</li>
<li><strong>從資料庫 transaction log 挖寶：</strong> transaction log 裡面資料 100% 完整，可做為 event 來源，但是 log 太生不好處理，而且和選用的資料庫緊耦合</li>
<li><strong>使用 <a href=https://github.com/cer/event-sourcing-examples/wiki/WhyEventSourcing>Event sourcing</a>：</strong> 將原本 mutate 資料庫 table 的操作都改成一個個事件，例如 Order 狀態改變變成一個個 Order.completed Order.pending 事件，因為不再將資料映射到 Object entity，不僅省了 ORM 抽象，更保證資料 consistency（因為根本不會 mutate state），在 persistent data 的同時也會直接 publish event，但缺點是不好設計，而且不直觀，需要使用 <a href=https://github.com/cer/event-sourcing-examples/wiki>Command Query Responsibility Segregation（CQRS）</a> 達成特地的查詢操作。</li>
</ul>
</li>
</ul>
<h3 id=choosing-a-microservices-deployment-strategyhttpswwwnginxcomblogdeploying-microservices><a href=https://www.nginx.com/blog/deploying-microservices/>Choosing a Microservices Deployment Strategy</a><a hidden class=anchor aria-hidden=true href=#choosing-a-microservices-deployment-strategyhttpswwwnginxcomblogdeploying-microservices>#</a></h3>
<p>由於微服務架構不論數量、語言、框架種類通常比單體架構更多，因此更難部署，這篇整理了許多不同的部署策略：</p>
<ul>
<li>一個 host 多服務
<ul>
<li>Pros：部署最直接、資源運用率高</li>
<li>Cons：抽象化不夠，服務直接沒有隔離</li>
</ul>
</li>
<li>一個 VM 一個服務
<ul>
<li>Pros：服務間獨立、安全性</li>
<li>Cons：資源運用率低、啟動慢</li>
</ul>
</li>
<li>一個 container 一個服務
<ul>
<li>Pros：啟動快、image 容器化容易部署、隔離完善</li>
<li>Cons：資源運用率比 VM 高但比單一 host 低、比 VM 安全性低一些</li>
<li>如果有 cluster manager 例如 kubernetes 會增加資源運用率</li>
</ul>
</li>
<li>Serverless
<ul>
<li>Pros：不需管理 infra、by request 算錢</li>
<li>Cons：僅適合 stateless 服務但不適合 long-running 服務、受限於 runtime 語言支援程度</li>
</ul>
</li>
</ul>
<h3 id=refactoring-a-monolith-into-microserviceshttpswwwnginxcomblogrefactoring-a-monolith-into-microservices><a href=https://www.nginx.com/blog/refactoring-a-monolith-into-microservices/>Refactoring a Monolith into Microservices</a><a hidden class=anchor aria-hidden=true href=#refactoring-a-monolith-into-microserviceshttpswwwnginxcomblogrefactoring-a-monolith-into-microservices>#</a></h3>
<p>如何從遷移到基本上是老生常談，還是條列有提到的策略好惹：</p>
<ul>
<li><strong>停止堆屎：</strong> 知道目前的單體架構是一坨屎，新 feature 就別再往上加了</li>
<li><strong>切堆分層：</strong> 架構通常分為 1）presentation layer，和 UI 或 REST API 等相關，2）business logic layer，都是業務邏輯，以及 3）data-access layer，存取資料庫或是訊息中介 message queue 等。切好切滿更容易抽象出微服務</li>
<li><strong>抽出服務：</strong> 乍看之下不知道在講啥，但提到需要以 module 為單位來抽象（前提是 module 權責分明），如果本來就有遵守 <a href=https://martinfowler.com/eaaCatalog/domainModel.html>Domain Model pattern</a> 會更好抽象</li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://weihanglo.tw/tags/weekly/>Weekly</a></li>
<li><a href=https://weihanglo.tw/tags/microservice/>Microservice</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://weihanglo.tw/posts/2020/www-0x06/>
<span class=title>« Prev</span>
<br>
<span>WWW 0x06: Life is short. I hate GIL</span>
</a>
<a class=next href=https://weihanglo.tw/posts/2020/www-0x04/>
<span class=title>Next »</span>
<br>
<span>WWW 0x04: Not feeling the async pressure</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>CC BY-NC-SA 4.0</span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>