<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>布隆過濾器 Bloom Filter | Weihang Lo</title>
<meta name=keywords content="Algorithms">
<meta name=description content="本篇從 Rust Algorithm Club 移植，若欲閱讀最新版，請移駕至Rust 演算法俱樂部：布隆過濾器 Bloom Filter 一文，此文不同步更新。 Bloom filter 是一種機率資料結構（probabil">
<meta name=author content>
<link rel=canonical href=https://weihanglo.tw/posts/2020/bloom-filter/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style>
<link rel=icon href=https://weihanglo.tw/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://weihanglo.tw/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://weihanglo.tw/favicon-32x32.png>
<link rel=apple-touch-icon href=https://weihanglo.tw/apple-touch-icon.png>
<link rel=mask-icon href=https://weihanglo.tw/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:!0},{left:'$',right:'$',display:!1},{left:'\\(',right:'\\)',display:!1},{left:'\\[',right:'\\]',display:!0}],throwOnError:!1})})</script>
<meta property="og:title" content="布隆過濾器 Bloom Filter">
<meta property="og:description" content="本篇從 Rust Algorithm Club 移植，若欲閱讀最新版，請移駕至Rust 演算法俱樂部：布隆過濾器 Bloom Filter 一文，此文不同步更新。 Bloom filter 是一種機率資料結構（probabil">
<meta property="og:type" content="article">
<meta property="og:url" content="https://weihanglo.tw/posts/2020/bloom-filter/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-08-28T00:00:00+08:00">
<meta property="article:modified_time" content="2020-08-28T00:00:00+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="布隆過濾器 Bloom Filter">
<meta name=twitter:description content="本篇從 Rust Algorithm Club 移植，若欲閱讀最新版，請移駕至Rust 演算法俱樂部：布隆過濾器 Bloom Filter 一文，此文不同步更新。 Bloom filter 是一種機率資料結構（probabil">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://weihanglo.tw/posts/"},{"@type":"ListItem","position":3,"name":"布隆過濾器 Bloom Filter","item":"https://weihanglo.tw/posts/2020/bloom-filter/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"布隆過濾器 Bloom Filter","name":"布隆過濾器 Bloom Filter","description":"本篇從 Rust Algorithm Club 移植，若欲閱讀最新版，請移駕至Rust 演算法俱樂部：布隆過濾器 Bloom Filter 一文，此文不同步更新。 Bloom filter 是一種機率資料結構（probabil","keywords":["Algorithms"],"articleBody":" 本篇從 Rust Algorithm Club 移植，若欲閱讀最新版，請移駕至Rust 演算法俱樂部：布隆過濾器 Bloom Filter 一文，此文不同步更新。\n Bloom filter 是一種機率資料結構（probabilistic data structure），類似於集合，常用於需快速驗證成員是否「可能存在」或是「絕對不存在」在容器中，亦即有機會出現假陽性（false positive），但絕不會有假陰性（false negative）。\nBloom filter 的優勢是：\n 類似集合，可在 $O(1)$ 時間複雜度驗證成員是否存在，卻僅需相對少的儲存空間。 承上，在 0.1% 錯誤率下儲存一百萬個元素僅需 1.71 MiB。 非常容易實作的機率資料結構，僅需多次雜湊。  Bloom filter 則有以下短處：\n 經典款 Bloom filter 容器大小固定（fixed-size），無法動態調整儲存空間。 可能給出假陽性答案：回報存在但實際不存在，且錯誤隨數量變多上升。 自身不儲存成員資料，需要有額外的儲存資料方案。 只能新增成員，但不能移除成員（可透過變形解決）。 若輸入資料集本身離散，接近隨機存取，無法充分利用 CPU cache。 承上，因為隨機存取，不利於延伸到記憶體以外的外部儲存裝置。  Bloom filter 常見應用場景為：\n 資料庫利用 Bloom filter 中減少實際存取 disk 的 IO 開銷。 Chromium 瀏覽器驗證大量惡意連結。 Medium 避免推薦已推薦過的文章。   小知識：bloom 是開花之意，但 Bloom filter 和開花沒任何關係，只因發明人姓氏為 Bloom\n 概念 Bloom filter 由下列兩個部分組成：\n 一個 $m$ 位元的位元陣列（bit array） $k$ 個不同的雜湊函數  經典款的 Bloom filter 作為一個近似集合的容器，提供下列兩個操作\n 新增： 新增一個值時，透過 $k$ 個雜湊函數產生 $k$ 個雜湊值，分別代表在位元陣列的索引位置，再將 $k$ 個位置的位元翻轉至 1。 查詢： 同樣透過 $k$ 個雜湊函數產生 $k$ 個雜湊值作為位元陣列的索引位置，若所有位元皆為 1，則代表該值存在。   上圖顯示 w 並沒有在 {x,y,z} 集合中，因為 w 的雜湊結果有個位元為 0。\n 你可能會開始想：\n 欲儲存一百萬個元素，需要多少位元？ 出現假陽性的機率是多少？可以調整嗎？ 需要幾個雜湊函數？ 可重複使用相同的雜湊函數嗎？  回答這些問題需要兩個已知條件：\n 預期會儲存多少 $n$ 個元素到容器。 可容忍的假陽性機率 $\\epsilon$，即容器不包含該元素，檢測卻回報存在（所有雜湊位皆為 1）。  於是可得位元陣列最佳化的長度為 $m$ 個位元，$m$ 為：\n$$m = -\\frac{n \\ln{\\epsilon}}{(\\ln{2})^2}$$\n而在已知條件下，需要的雜湊函數數量 $k$ 為：\n$$k = -\\frac{\\ln{\\epsilon}}{\\ln{2}} = -\\log_2{\\epsilon}$$\n當然，這些公式並非憑空冒出，有興趣可以讀讀維基百科上的數學，和這段詳細的推導，不過也要注意，Bloom filter 的假設是「每個雜湊函數獨立」但位元間是否獨立有待討論，這順便開啟了其他問題，可重複使用相同的雜湊函數嗎？\n答案是可以， 這篇「Less Hashing, Same Performance:Building a Better Bloom Filter」提及，在不犧牲漸進假陽性機率（asymptotic false positive probability）的前提下，透過兩個不同的雜湊函數 $h_1(x)$ 和 $h_2(x)$，配合以下公式，就可以模擬出多個雜湊函數：\n$$g_i(x) = h_1(x) + ih_2(x)$$\n數學看暈了嗎？來點程式碼吧。\n架構設計 利用 Vec 儲存位元 Bloom filter 底層以位元陣列作為儲存容器，如果目標是最省空間，該用 Rust 的什麼型別來儲存位元呢？\n直觀作法是在 struct 新增一個 bits 位元陣列的 array 型別：\npub struct BloomFilter { bits: [bool; N] } 雖然非常省空間，用了多少 bits 這個 struct 就佔多大，但這語法並非不合法，因為 N 未定義，無法編譯，array 的 N 必須是編譯期就決定的常數，BloomFilter 若寫死 N 就不夠泛用了（除非參考 vec! 透過 macro 建立）。\n不如換個方向，不用 fixed size array，給定動態大小的 slice 試試看。\npub struct BloomFilter { bits: [bool] } 嗯，可以編譯通過，但如果嘗試建立一個 struct 呢？\nfn main() { let input_len = 5; let bits = [true; input_len]; BloomFilter { bits }; } 就會發現編譯結果如下：\nerror[E0435]: attempt to use a non-constant value in a constant -- src/main.rs:7:23 | 7 | let bits = [true; input_len]; | ^^^^^^^^^ non-constant value error[E0277]: the size for values of type `[bool]` cannot be known at compilation time -- src/main.rs:8:5 | 8 | BloomFilter { bits }; | ^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time 原因有二，其一同樣是 array bits 需要一個常數長度；其二則是 bits 是一個 Dynamic Sized Types（Dsts） ，長度無法在編譯時決定，編譯期就無法得知 BloomFilter 的所佔記憶體用量。\n看來得放棄用 array 或 slice 這些方法，改用最暴力的 Vec 作為位元陣列儲存容器，Vec 雖可動態調整大小，背後其實是一個 pointer + 一個 usize 的 capacity + 一個 usize 的 len 組成，若是在 64 位元的機器上，一個 Vec 就會佔 24 位元組，比起 array 多耗費兩個 2 * 8 個位元組空間，幸好這額外的 16 個位元組是固定支出，不隨著 $m$ 和 $n$ 成長。\npub struct BloomFilter { bits: Vecbool } 儲存兩個雜湊函數 再來，要在 BloomFilter 儲存兩個 hasher，也就是實作前面提及用兩個雜湊函數模擬 $k$ 個論文中的兩個 hasher，這兩個在 BloomFilter 建構時同時建立，並在操作 BloomFilter 的方法上共用。\n這次直接使用標準函式庫內預設雜湊演算法 DefaultHasher 作為隨機的兩個雜湊函數 BloomFilter.hashers。由於是模擬 $k$ 個函數的雜湊行為，仍需另闢欄位，儲存 $k$ 實際上是多少個雜湊函數 BloomFilter.hash_fn_count。\nuse std::collections::hash_map::DefaultHasher; pub struct BloomFilter { /// The bit array of _m_ bits.  bits: Vecbool, /// Count of hash functions. Denoted by _k_.  hash_fn_count: usize, /// The hashers that do real works.  hashers: [DefaultHasher; 2], } 就剩最後一里路了！\n使用 PhantomData 讓編譯器閉嘴 眾所周知，透過泛型（Generic），Rust 可重用相同的容器型別，特化接受不同型別的容器，例如 HashMap 可以特化為鍵為 String，值為 u32 的 HashMap，Vec 可以成為二維位元組 Vec。看 std::collections 提供的容器，所有泛型型別參數（Type Parameter）像是 T、K、V 都是跟著 struct 宣告，也因為這些容器的確實際儲存了這些型別的元素，泛型型別參數跟著 struct 很合理。\n有趣的是，作為一個容器，Bloom filter 其實不儲存元素本身，而是記錄元素是否「曾經新增至」該容器中。這給了一些想像空間：如何提供型別參數給 Bloom filter？提供兩個方向：\n 泛型型別參數宣告跟著 struct： 也就是 struct BloomFilter，如此一來，一個容器實例只能操作一種型別，而且在編譯期就決定。 let bf = BloomFilter::new(); bf.insert(\u00261); // infer the type T is i32 bf.insert(\"wront type\"); // compile error: \u0026str is not compatible to i32  泛型型別跟著 struct 的方法，struct 本身不宣告： 很難想像容器裡面儲存不同的型別，但 BloomFilter 實際上只需要一個 Vec 記錄存在與否，到底新增了什麼型別的元素其實不重要，型別有實作雜湊就行。這個作法下，你可能會看到這種邪魔歪道： let bf = BloomFilter::new(); bf.insert(\u00261); bf.insert(\"another type\"); // it works bf.insert(vec![3.14159]); // it also works   為了讓容器有一致感，這裡決定選擇法一，讓泛型跟著容器走。實作非常簡單，加上 T 泛型參數就行\nuse std::collections::hash_map::DefaultHasher; - pub struct BloomFilter { + pub struct BloomFilter {  /// .. snip } 哎呀，編譯失敗！\nerror[E0392]: parameter `T` is never used -- src/lib.rs:3:24 | 3 | pub struct BloomFilter { | ^ unused parameter | = help: consider removing `T`, referring to it in a field, or using a marker such as `std::marker::PhantomData` 因為 Rust 編譯器認為 BloomFilter 並不實際擁有 T 相關欄位，因此編譯不通過，我們可以利用 std::marker::PhantomData，PhantomData 是一個 Zero-Sized Type 不佔空間，就是為了取悅編譯器，製造出 struct 擁有 T 的假象。\nuse std::collections::hash_map::DefaultHasher; use std::marker::PhantomData; pub struct BloomFilterT { /// The bit array of _m_ bits.  bits: Vecbool, /// Count of hash functions. Denoted by _k_.  hash_fn_count: usize, /// The hashers that do real works.  hashers: [DefaultHasher; 2], _phantom: PhantomDataT, } ?Sized 讓容器可以儲存 DSTs 最後，有鑑於讓Bloom fliter 能夠接受更多型別，元素不一定要符合編譯期確定大小的 Sized trait bound，可以透過加上 ?Sized trait bound 解除預設的限制，如此一來 BloomFilter 就可接受 slice 和 trait object 這些 DSTs 了，傳入 string literal 變為可能 bloom_filter.insert(\"1234\")。\nuse std::collections::hash_map::DefaultHasher; use std::marker::PhantomData; - pub struct BloomFilter { + pub struct BloomFilter{  // .. snip } 基本操作 Bloom filter 為類似集合的容器，當然有類似的操作，事實上，這類機率性集合成員檢測的資料結構有個較少聽見但令人印象深刻的名字，稱為「Approximate Membership Query（AMQ）」，提供 add(element) 和 query(element) 兩個基本操作。\n本文的 BloomFilter 提供下列幾個公開方法：\n new：初始化一個容器。 insert：新增一個元素。 contains：檢查容器內有無特定元素（是否曾新增過）。  以及幾個內部輔助方法：\n make_hash：給定輸入元素資料，透過兩個雜湊函數產生兩個雜湊值。 get_index：將 make_hash 的兩雜湊值帶入 $g_i(x) = h_1(x) + ih_2(x)$ 計算單次 i 的索引位置。 optimal_bits_count：給定預期儲存元素個數 $n$ 與假陽性機率 $\\epsilon$，得位元陣列最適位元數 $m$。 optimal_hashers_count：給定預期假陽性機率，得最適雜湊函數個數 $k$。  初始化 Bloom filter 有四個參數 $m$、$n$、$k$、$\\epsilon$ 可以調整（詳見 效能一節），對使用者來說，有幾個雜湊函數或底層是多少個位元都是實作細節了，更關心的可能是\n「我有一百萬筆資料需要驗證存在，容錯率需要在 0.1%，我需要多大的儲存空間？」\n因此，建構函數 new 提供輸入預期儲存元素個數 $n$ 和預期的假陽性機率 $\\epsilon$ 是天經地義的事：\npub fn new(capacity: usize, err_rate: f64) - Self; 接下來，會實作概念一節的數學公式，找出最適位元數和最適雜湊函數個數。這兩個函數都是以 Rust 表達數學公式，可注意的點是，std::f32::consts 和 std::f64::consts，提供許多數學上常見的常數老朋友，操作浮點數和雙精度浮點數就不用自己手動重算了。\n/// m = -1 * (n * ln ε) / (ln 2)^2 fn optimal_bits_count(capacity: usize, err_rate: f64) - usize { let ln_2_2 = std::f64::consts::LN_2.powf(2f64); (-1f64 * capacity as f64 * err_rate.ln() / ln_2_2).ceil() as usize } /// k = -log_2 ε fn optimal_hashers_count(err_rate: f64) - usize { (-1f64 * err_rate.log2()).ceil() as usize } 目前為止，BloomFilter::new 長這樣：\npub fn new(capacity: usize, err_rate: f64) - Self { let bits_count = Self::optimal_bits_count(capacity, err_rate); let hash_fn_count = Self::optimal_hashers_count(err_rate); } 最後，按照前述兩個雜湊函數恰恰好的道理，建立兩個不同的雜湊函數，並初始化位元陣列，大功告成！\npub fn new(capacity: usize, err_rate: f64) - Self { // #1 Get optimal count of bit  let bits_count = Self::optimal_bits_count(capacity, err_rate); // #2 Get optimal count of hash functions  let hash_fn_count = Self::optimal_hashers_count(err_rate); // #3 Use RandomState to build different hasher  let hashers = [ RandomState::new().build_hasher(), RandomState::new().build_hasher(), ]; Self { bits: vec![false; bits_count], // #4 Initialize a all zero bit array  hash_fn_count, hashers, _phantom: PhantomData, } }  透過指定假陽性機率與預期元素個數，算得最適位元數 透過指定假陽性機率，算得最適雜湊函數個數 透過 std 內建的 RandomState 產生兩個不同初始狀態的雜湊函數，以模擬 $k$ 個雜湊函數 初始化一個全零的位元陣列  新增 新增一個元素到 Bloom filter，說穿了就做一件事：將元素透過 $k$ 個雜湊函數，產出 $k$ 個索引位置，並將位元陣列上這些位置的位元翻轉至 1。\n整個 insert 函數即為計算 $g_i(x) = h_1(x) + ih_2(x)$ 模擬 $k$ 個雜湊函數的過程：\npub fn insert(\u0026mut self, elem: \u0026T) where T: Hash, { let hashes = self.make_hash(elem); // #1  for fn_i in 0..self.hash_fn_count { // #2  let index = self.get_index(hashes, fn_i as u64); // #3  self.bits[index] = true; // #4  } }  取得 $h_1(x)$ 和 $h_2(x)$ 的雜湊輸出結果。 迭代 i 次，i 上限為 $k$：初始化時所得的最適雜湊函數個數 計算 $g_i(x) = h_1(x) + ih_2(x)$ 取得索引位置 將索引位置下的位元設定為 1  這裡有兩個內部方法，先講解如何計算 $h_1(x)$ 和 $h_2(x)$：\nfn make_hash(\u0026self, elem: \u0026T) - (u64, u64) where T: Hash, { // #1  let hasher1 = \u0026mut self.hashers[0].clone(); let hasher2 = \u0026mut self.hashers[1].clone(); // #2  elem.hash(hasher1); elem.hash(hasher2); // #3  (hasher1.finish(), hasher2.finish()) }  為保存兩個 hasher 內部初始狀態，使用 clone 複製新的 hasher 來做雜湊 將 elem 餵給 hasher 計算雜湊值 輸出雜湊值，由於 Hasher::finish 不會重設 hasher 內部狀態，所以需要步驟一 clone 來保留 hasher 的原始狀態  再來是實作計算索引位置 $g_i(x) = h_1(x) + ih_2(x)$，這個函數非常單純，就是輸入 make_hash 所得之雜湊值，然後帶入公式中。為了防止輸出的索引位置超過位元陣列的位元數，這裡以位元數 $m$ 取模（% modulo），加上使用 wrapping_ops 這些 modular arithmetic operation 達成。\nfn get_index(\u0026self, (h1, h2): (u64, u64), fn_i: u64) - usize { (h1.wrapping_add(fn_i.wrapping_mul(h2)) % self.bits.len() as u64) as usize } 查詢 查詢元素是否在 Bloom filter 裡面，就是看看該元素透過 $k$ 個雜湊函數輸出的每個索引位置全部為 1，則可能存在；否則就是絕對不存在。\n實作步驟和插入非常相似：\npub fn contains(\u0026self, elem: \u0026T) - bool where T: Hash, { let hashes = self.make_hash(elem); // #1  (0..self.hash_fn_count).all(|fn_i| { // #1 使用 iter  let index = self.get_index(hashes, fn_i as u64); self.bits[index] }) }  取得 $h_1(x)$ 和 $h_2(x)$ 的雜湊輸出結果。 使用 Iterator::all 迭代收集 $k$ 個雜湊函數的輸出 計算 $g_i(x) = h_1(x) + ih_2(x)$ 取得索引位置 回傳索引位置下的位元 bool 值，此值會匯集起來，於步驟二確認命中全部 $k$ 個索引，即為元素存在  完整程式碼如下，或轉駕到 API 文件：\npub struct BloomFilterT: ?Sized { bits: Vecbool, hash_fn_count: usize, hashers: [DefaultHasher; 2], _phantom: PhantomDataT, } implT: ?Sized BloomFilterT { pub fn new(capacity: usize, err_rate: f64) - Self { let bits_count = Self::optimal_bits_count(capacity, err_rate); let hash_fn_count = Self::optimal_hashers_count(err_rate); let hashers = [ RandomState::new().build_hasher(), RandomState::new().build_hasher(), ]; Self { bits: vec![false; bits_count], hash_fn_count, hashers, _phantom: PhantomData, } } pub fn insert(\u0026mut self, elem: \u0026T) where T: Hash, { // g_i(x) = h1(x) + i * h2(x)  let hashes = self.make_hash(elem); for fn_i in 0..self.hash_fn_count { let index = self.get_index(hashes, fn_i as u64); self.bits[index] = true; } } pub fn contains(\u0026self, elem: \u0026T) - bool where T: Hash, { let hashes = self.make_hash(elem); (0..self.hash_fn_count).all(|fn_i| { let index = self.get_index(hashes, fn_i as u64); self.bits[index] }) } fn get_index(\u0026self, (h1, h2): (u64, u64), fn_i: u64) - usize { (h1.wrapping_add(fn_i.wrapping_mul(h2)) % self.bits.len() as u64) as usize } fn make_hash(\u0026self, elem: \u0026T) - (u64, u64) where T: Hash, { let hasher1 = \u0026mut self.hashers[0].clone(); let hasher2 = \u0026mut self.hashers[1].clone(); elem.hash(hasher1); elem.hash(hasher2); (hasher1.finish(), hasher2.finish()) } /// m = -1 * (n * ln ε) / (ln 2)^2  fn optimal_bits_count(capacity: usize, err_rate: f64) - usize { let ln_2_2 = std::f64::consts::LN_2.powf(2f64); (-1f64 * capacity as f64 * err_rate.ln() / ln_2_2).ceil() as usize } /// k = -log_2 ε  fn optimal_hashers_count(err_rate: f64) - usize { (-1f64 * err_rate.log2()).ceil() as usize } } 效能    Notation Description     $n$ 預期儲存 $n$ 個元素到容器中   $m$ 使用 $m$ 位元的位元陣列來儲存   $k$ 有 $k$ 個雜湊函數計算索引位置   $\\epsilon$ 假陽性錯誤的機率 $\\epsilon$    和常見的容器資料結構不太一樣，複雜度和 $n$ 元素個數脫鉤，而是和 $k$ 和 $m$ 相關：\n   Operation Time complexity     insert(v) $O(k)$   contains(v) $O(k)$    而儲存空間複雜度則是 $O(m)$。\n新增和搜尋一個元素個別需要雜湊 $k$ 次，因此時間複雜度為 $O(k)$ 顯而易見，然而，$k$ 通常相對 $m$ $n$ 是非常小的數字，例如 在 0.1% 錯誤率下儲存一百萬個元素僅需 1.71 MiB 和 7 個雜湊函數，實務上直接當作 $O(1)$ 也不算錯。\n至於空間複雜度，由於必須事先配置好 $m$ 位元的位元陣列，就算新增的元素 $n \\gt m$，也不會再新增新位元，因此空間使用為 $O(m)$ 個位元。實務上，當 $n$ 成長到接近 $m$ 時，假陽性的機率會大增，不堪使用，進而需要能動態調整儲存空間的 Bloom filter 變形。\n變形 經典款 Bloom filter 容易實作，歷久不衰，不過仍有許多可以增進空間：\n Data locality 不夠好：Bloom filter 底層儲存是位元陣列隨機存取，較不符合現代 CPU 架構的 cache line 使用姿勢。Cloudflare 技術部落格文 When Bloom filters don’t bloom 以幽默筆法帶出這個問題，值得一讀。 雜湊次數過多：Bloom filter 每一個新增查詢操作都需要雜湊 $k$ 次，就算利用 double hashing 還是要雜湊兩次，比起其他類似資料結構硬生生多雜湊數次。 位元陣列大小固定：Bloom filter 容器大小固定，給你預期的元素個數後，無法動態調整儲存空間， bits per entry 較高：以類似功能的的資料結構來說，Bloom filter 在空間利用率上，欲維持一定的假陽性機率，每個元素所需位元數相對較高，需要 $1.44 \\log_2{\\frac{1}{\\epsilon}}$ 個位元。  這裡介紹幾款嘗試解決上述問題的 filter，您也可以去 Wikipedia 看看其他更多變形的介紹。\n可以計數的 Counting Bloom filter 📚 維基百科\n經典款 Bloom filter 之所以無法刪除元素，是因為沒有記錄哪些元素新增/刪除的資訊，而 Counting Bloom filter 顧名思義，原本用一個位元儲存 0 / 1 資訊，延伸為多位元方便儲存計數（counting），有了個別元素增刪資訊，Bloom filter 因此能實作「刪除元素」。搜尋一個 Counting Bloom filter 是否擁有 n 次以上 x，答案一樣和 Bloom filter 類似是「可能有 n 次以上的 x」或是「x 絕對沒有 n 次以上」。事實上，可將 Counting Bloom filter 視為 Bloom filter 的一般化形式（generalized form），而經典款 Bloom filter 反過來可當作只記一次數的特化。\n但 Counting Bloom filter 的缺點是空間需求大，端看決定要用幾個位元計數，例如常見用 4 個位元計數，則是經典款的四倍空間消耗。\n動態適應空間大小的 Scalable Bloom Filter 📚 論文連結\nScalable Bloom Filter 的特色是：動態適應空間大小，不需事先知道預期儲存的元素個數。\nScalable Bloom Filter 的實作蠻暴力的，本身是由一至多個經典款 Bloom filter 組成，若一個 filter 滿了（超過 fill ratio），則會新增一個 filter，往後所有新增都在這個新 filter 上面，直到它也滿了，可視為一個 recursive data structure。\n至於查詢，這就是 Scalable Bloom Filter 比較弱的地方，查詢會從第一個 filter 開始找，若找不到往下一個 filter 找，找到會沒有下一個 filter 為止。若 filter 數量為 $l$，則查詢的時間複雜度從 $O(k)$ 變成 $O(k \\cdot l)$。\n除了初始化大小和假陽性機率率，Scalable Bloom Filter 提供設定成長率和假陽性錯誤緊縮率：\n 成長因子 $s$：每個新增的 filter 空間大小成長率，論文的經驗法則得出預期小成長趨勢選擇 $s = 2$，有較大成長趨勢則 $s = 4$ 效果好。 錯誤緊縮率 $r$： 每個新增的 filter 會以等比級數得到更緊縮的假陽性機率上限，由於是等比級數，逼近極限時會小於原始機率，這讓整體假陽性機率得以保持。論文中實證 0.8 到 0.9 在元素預期有大成長率下有最佳平均空間利用率。  Quotient filter 📚 論文連結（直接讀論文更易懂）\n商數過濾器（Quotient filterF）利用雜湊表為底層儲存容器，來做集合成員檢測的 AMQ，為了節省空間使用量，Quotient filter 的雜湊表只儲存 partial-key，俗稱指紋（fingerprint），指紋的鍵短空間用量低，副作用是更容易碰撞，代表需要更有效處理雜湊碰撞（hash collision）。\n一般來說，處理雜湊碰撞有 separate chaining 和 Open addressping 兩大類方法，而 Quotient filter 選擇了另一條詭譎的方法：利用 open addressing 中 linear probing 的方式，對每個 slot 儲存額外資訊，使得我們可辨認碰撞的元素是在相同指紋下的同個 bucket 內。換句話說，額外資訊就是在「透過 linear probing 模擬 separate chaining」。\n回到指紋，Quotient filter 實際上並不直接儲存指紋，而是將指紋 $f$ 進一步拆成商 $f_q$ 與餘數 $f_r$，商作為索引位置，而餘數則為真實被儲存的值。透過商和餘數，可重組回推原本的指紋。不需存完整的指紋，又再次減少空間使用量，帥！\n簡單總結 Quotient filter 的特性：\n 使用 linear probing 解決雜湊碰撞，data locality 好，有 cache friendly。 有額外儲存資訊，可在不重建不 rehash filter 的情況下支援刪除、合併、調整空間。 綜合上述兩點，非常適合 LSM-tree 等需要存取 SSD 的場景，大幅減少 I/O。 Throughput 受到雜湊表 load factor 影響較大。 空間用量仍比經典款 Bloom filter 多 10% 到 25%。   Quotient filter 與它等價的 open addressing hash map\n Image Source: Bender, et al., 2012. “Don’t Thrash: How to Cache Your Hash on Flash”.\n支援刪除元素的 Cuckoo filter 📚 論文連結（有趣易讀，誠摯推薦）\nCuckoo hashing 是一種解決雜湊碰撞的方法，透過一次計算兩個雜湊函數產生兩個索引位置，若其中一個位置有空位則插入空位，若都沒有空位，則隨機踢掉一個，被踢掉的再去找下一個替死鬼，直到全部都有位置，或踢掉次數大於一定值則停止。這種行為和杜鵑鳥（cuckoo、布穀鳥）鳩佔鵲巢的生物習性很像，因此得名。\nCuckoo filter 利用雜湊表為底層儲存容器，來做集合成員檢測的 AMQ，會和 cuckoo 扯上關係則是因為使用 Cuckoo hashing 解決雜湊碰撞，以增加空間使用率（達到 95% occupancy）。Cuckoo filter 的雜湊表和 Quotient filter 一樣，為了減少空間使用量而只儲存 partial-key。\n儲存指紋導致鍵變短，容易碰撞，也代表萬一碰撞，沒辦法透過原始的鍵再次雜湊來找到 Cuckoo hasing 對應另一位置，不過 Cuckoo filter 巧妙利用 XOR 的 identity $x \\oplus x = 0$ 解決問題，double hashing 公式奉上：\n$$ h_1(x) = hash(x) \\\\ h_2(x) = h_1(x) \\oplus hash(fingerprint(x)) $$\n如此一次，透過 $h_2(x)$ 和指紋的 XOR 就可以得到 $h_1(x)$，公式進而可一般化成：\n$$j = i \\oplus hash(fingerprint(x))$$\n其中 $j$ 與 $i$ 為同個元素經過兩個雜湊函數中任一的值，神奇吧！\nCuckoo filter 的特性是：\n 支援動態新增與刪除元數。 比其他 filter 變形（例如 Quotient filter）好實作，如果懂 Cuckoo hashing 的話。 查詢效能比經典款 Bloom filter 好，bits per item 也比較低（$(\\log_2{\\frac{1}{\\epsilon}} + 2) / \\alpha$，$\\alpha$ 是雜湊表的 load factor，通常為 95.5%）。 缺點是「一定要先新增過一個元素，才能對 filter 刪除該元素」，但這是所有支援刪除的 filter 的通病，不然就會有假陽性發生。  Image Source: Fan, et al., 2014. “Cuckoo Filter: Practically Better Than Bloom”.\n參考資料  Burton H. Bloom: Space/Time Trade-offs in Hash Coding with Allowable Errors Wiki: Bloom filter Less Hashing, Same Performance:Building a Better Bloom Filter Onat: Let’s implement a Bloom Filter Google Guava: BloomFilter Bloom Filter Calculator  ","wordCount":"7300","inLanguage":"en","datePublished":"2020-08-28T00:00:00+08:00","dateModified":"2020-08-28T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://weihanglo.tw/posts/2020/bloom-filter/"},"publisher":{"@type":"Organization","name":"Weihang Lo","logo":{"@type":"ImageObject","url":"https://weihanglo.tw/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://weihanglo.tw accesskey=h title="Weihang Lo (Alt + H)">Weihang Lo</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://weihanglo.tw/ title=Home>
<span>Home</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/posts/ title=Posts>
<span>Posts</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
布隆過濾器 Bloom Filter
</h1>
<div class=post-meta><span title="2020-08-28 00:00:00 +0800 +0800">August 28, 2020</span>&nbsp;·&nbsp;15 min
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e6%a6%82%e5%bf%b5 aria-label=概念>概念</a></li>
<li>
<a href=#%e6%9e%b6%e6%a7%8b%e8%a8%ad%e8%a8%88 aria-label=架構設計>架構設計</a><ul>
<li>
<a href=#%e5%88%a9%e7%94%a8-vec-%e5%84%b2%e5%ad%98%e4%bd%8d%e5%85%83 aria-label="利用 Vec 儲存位元">利用 <code>Vec</code> 儲存位元</a></li>
<li>
<a href=#%e5%84%b2%e5%ad%98%e5%85%a9%e5%80%8b%e9%9b%9c%e6%b9%8a%e5%87%bd%e6%95%b8 aria-label=儲存兩個雜湊函數>儲存兩個雜湊函數</a></li>
<li>
<a href=#%e4%bd%bf%e7%94%a8-phantomdatarust-std-marker-phantomdata-%e8%ae%93%e7%b7%a8%e8%ad%af%e5%99%a8%e9%96%89%e5%98%b4 aria-label="使用 PhantomData 讓編譯器閉嘴">使用 <a href=https://doc.rust-lang.org/core/marker/struct.PhantomData.html><code>PhantomData</code></a> 讓編譯器閉嘴</a></li></ul>
</li>
<li>
<a href=#sized-%e8%ae%93%e5%ae%b9%e5%99%a8%e5%8f%af%e4%bb%a5%e5%84%b2%e5%ad%98-dsts aria-label="?Sized 讓容器可以儲存 DSTs"><code>?Sized</code> 讓容器可以儲存 DSTs</a></li>
<li>
<a href=#%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c aria-label=基本操作>基本操作</a><ul>
<li>
<a href=#%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label=初始化>初始化</a></li>
<li>
<a href=#%e6%96%b0%e5%a2%9e aria-label=新增>新增</a></li>
<li>
<a href=#%e6%9f%a5%e8%a9%a2 aria-label=查詢>查詢</a></li></ul>
</li>
<li>
<a href=#%e6%95%88%e8%83%bd aria-label=效能>效能</a></li>
<li>
<a href=#%e8%ae%8a%e5%bd%a2 aria-label=變形>變形</a><ul>
<li>
<a href=#%e5%8f%af%e4%bb%a5%e8%a8%88%e6%95%b8%e7%9a%84-counting-bloom-filter aria-label="可以計數的 Counting Bloom filter">可以計數的 Counting Bloom filter</a></li>
<li>
<a href=#%e5%8b%95%e6%85%8b%e9%81%a9%e6%87%89%e7%a9%ba%e9%96%93%e5%a4%a7%e5%b0%8f%e7%9a%84-scalable-bloom-filter aria-label="動態適應空間大小的 Scalable Bloom Filter">動態適應空間大小的 Scalable Bloom Filter</a></li>
<li>
<a href=#quotient-filter aria-label="Quotient filter">Quotient filter</a></li>
<li>
<a href=#%e6%94%af%e6%8f%b4%e5%88%aa%e9%99%a4%e5%85%83%e7%b4%a0%e7%9a%84-cuckoo-filter aria-label="支援刪除元素的 Cuckoo filter">支援刪除元素的 Cuckoo filter</a></li></ul>
</li>
<li>
<a href=#%e5%8f%83%e8%80%83%e8%b3%87%e6%96%99 aria-label=參考資料>參考資料</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><blockquote>
<p>本篇從 <a href=https://rust-algo.club>Rust Algorithm Club</a> 移植，若欲閱讀最新版，請移駕至<a href=https://rust-algo.club/collections/bloom_filter>Rust 演算法俱樂部：布隆過濾器 Bloom Filter</a> 一文，此文不同步更新。</p>
</blockquote>
<p>Bloom filter 是一種機率資料結構（probabilistic data structure），類似於<a href=https://rust-algo.club/collections/set>集合</a>，常用於需快速驗證成員是否「可能存在」或是「絕對不存在」在容器中，亦即有機會出現假陽性（false positive），但絕不會有假陰性（false negative）。</p>
<p>Bloom filter 的優勢是：</p>
<ul>
<li>類似<a href=https://rust-algo.club/collections/set>集合</a>，可在 $O(1)$ 時間複雜度驗證成員是否存在，卻僅需相對少的儲存空間。</li>
<li>承上，<a href="https://hur.st/bloomfilter/?n=1M&p=0.001&m=&k=">在 0.1% 錯誤率下儲存一百萬個元素僅需 1.71 MiB</a>。</li>
<li>非常容易實作的機率資料結構，僅需多次雜湊。</li>
</ul>
<p>Bloom filter 則有以下短處：</p>
<ul>
<li>經典款 Bloom filter 容器大小固定（fixed-size），無法動態調整儲存空間。</li>
<li>可能給出假陽性答案：回報存在但實際不存在，且錯誤隨數量變多上升。</li>
<li>自身不儲存成員資料，需要有額外的儲存資料方案。</li>
<li>只能新增成員，但不能移除成員（可透過<a href=#%E8%AE%8A%E5%BD%A2>變形</a>解決）。</li>
<li>若輸入資料集本身離散，接近<a href=https://en.wikipedia.org/wiki/Random_access>隨機存取</a>，無法充分利用 CPU cache。</li>
<li>承上，因為隨機存取，不利於延伸到記憶體以外的外部儲存裝置。</li>
</ul>
<p>Bloom filter 常見應用場景為：</p>
<ul>
<li><a href=https://www.postgresql.org/docs/12/bloom.html>資料庫利用 Bloom filter</a> 中減少實際存取 disk 的 IO 開銷。</li>
<li>Chromium 瀏覽器<a href=https://chromiumcodereview.appspot.com/10896048/>驗證大量惡意連結</a>。</li>
<li>Medium <a href=https://blog.medium.com/what-are-bloom-filters-1ec2a50c68ff>避免推薦已推薦過的文章</a>。</li>
</ul>
<blockquote>
<p>小知識：bloom 是開花之意，但 Bloom filter 和開花沒任何關係，只因發明人姓氏為 Bloom</p>
</blockquote>
<h2 id=概念>概念<a hidden class=anchor aria-hidden=true href=#概念>#</a></h2>
<p>Bloom filter 由下列兩個部分組成：</p>
<ul>
<li>一個 $m$ 位元的位元陣列（bit array）</li>
<li>$k$ 個不同的雜湊函數</li>
</ul>
<p>經典款的 Bloom filter 作為一個近似集合的容器，提供下列兩個操作</p>
<ul>
<li><strong>新增：</strong> 新增一個值時，透過 $k$ 個雜湊函數產生 $k$ 個雜湊值，分別代表在位元陣列的索引位置，再將 $k$ 個位置的位元翻轉至 1。</li>
<li><strong>查詢：</strong> 同樣透過 $k$ 個雜湊函數產生 $k$ 個雜湊值作為位元陣列的索引位置，若所有位元皆為 1，則代表該值存在。</li>
</ul>
<p><img loading=lazy src=https://upload.wikimedia.org/wikipedia/commons/thumb/a/ac/Bloom_filter.svg/1280px-Bloom_filter.svg.png alt>
</p>
<blockquote>
<p>上圖顯示 w 並沒有在 {x,y,z} 集合中，因為 w 的雜湊結果有個位元為 0。</p>
</blockquote>
<p>你可能會開始想：</p>
<ul>
<li>欲儲存一百萬個元素，需要多少位元？</li>
<li>出現假陽性的機率是多少？可以調整嗎？</li>
<li>需要幾個雜湊函數？</li>
<li>可重複使用相同的雜湊函數嗎？</li>
</ul>
<p>回答這些問題需要兩個已知條件：</p>
<ol>
<li>預期會儲存多少 $n$ 個元素到容器。</li>
<li>可容忍的假陽性機率 $\epsilon$，即容器不包含該元素，檢測卻回報存在（所有雜湊位皆為 1）。</li>
</ol>
<p>於是可得位元陣列最佳化的長度為 $m$ 個位元，$m$ 為：</p>
<p>$$m = -\frac{n \ln{\epsilon}}{(\ln{2})^2}$$</p>
<p>而在已知條件下，需要的雜湊函數數量 $k$ 為：</p>
<p>$$k = -\frac{\ln{\epsilon}}{\ln{2}} = -\log_2{\epsilon}$$</p>
<p>當然，這些公式並非憑空冒出，有興趣可以讀讀<a href=https://en.wikipedia.org/wiki/Bloom_filter#Optimal_number_of_hash_functions>維基百科上的數學</a>，和<a href=https://sagi.io/bloom-filters-for-the-perplexed/#false-positive-probability-and-formulae>這段詳細的推導</a>，不過也要注意，Bloom filter 的假設是「每個雜湊函數獨立」但<a href=https://gopiandcode.uk/logs/log-bloomfilters-debunked.html#org7b3d391>位元間是否獨立有待討論</a>，這順便開啟了其他問題，可重複使用相同的雜湊函數嗎？</p>
<p>答案是可以， 這篇<a href=https://www.eecs.harvard.edu/~michaelm/postscripts/rsa2008.pdf>「Less Hashing, Same Performance:Building a Better Bloom Filter」</a>提及，在不犧牲漸進假陽性機率（asymptotic false positive probability）的前提下，透過兩個不同的雜湊函數 $h_1(x)$ 和 $h_2(x)$，配合以下公式，就可以模擬出多個雜湊函數：</p>
<p>$$g_i(x) = h_1(x) + ih_2(x)$$</p>
<p>數學看暈了嗎？來點程式碼吧。</p>
<h2 id=架構設計>架構設計<a hidden class=anchor aria-hidden=true href=#架構設計>#</a></h2>
<h3 id=利用-vec-儲存位元>利用 <code>Vec</code> 儲存位元<a hidden class=anchor aria-hidden=true href=#利用-vec-儲存位元>#</a></h3>
<p>Bloom filter 底層以位元陣列作為儲存容器，如果目標是最省空間，該用 Rust 的什麼型別來儲存位元呢？</p>
<p>直觀作法是在 struct 新增一個 <code>bits</code> 位元陣列的 <code>array</code> 型別：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>BloomFilter</span> {
  bits: [<span style=color:#66d9ef>bool</span>; N]
}
</code></pre></div><p>雖然非常省空間，用了多少 bits 這個 struct 就佔多大，但這語法並非不合法，因為 <code>N</code> 未定義，無法編譯，<a href=https://doc.rust-lang.org/std/primitive.array.html>array</a> 的 <code>N</code> 必須是編譯期就決定的常數，BloomFilter 若寫死 <code>N</code> 就不夠泛用了（除非參考 <a href=https://doc.rust-lang.org/alloc/macro.vec.html><code>vec!</code></a> 透過 macro 建立）。</p>
<p>不如換個方向，不用 fixed size array，給定動態大小的 <code>slice</code> 試試看。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>BloomFilter</span> {
  bits: [<span style=color:#66d9ef>bool</span>]
}
</code></pre></div><p>嗯，可以編譯通過，但如果嘗試建立一個 struct 呢？</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> input_len <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
    <span style=color:#66d9ef>let</span> bits <span style=color:#f92672>=</span> [<span style=color:#66d9ef>true</span>; input_len];
    BloomFilter { bits };
}
</code></pre></div><p>就會發現編譯結果如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>error<span style=color:#f92672>[</span>E0435<span style=color:#f92672>]</span>: attempt to use a non-constant value in a constant
 --&gt; src/main.rs:7:23
  |
<span style=color:#ae81ff>7</span> |     let bits <span style=color:#f92672>=</span> <span style=color:#f92672>[</span>true; input_len<span style=color:#f92672>]</span>;
  |                       ^^^^^^^^^ non-constant value

error<span style=color:#f92672>[</span>E0277<span style=color:#f92672>]</span>: the size <span style=color:#66d9ef>for</span> values of type <span style=color:#e6db74>`</span><span style=color:#f92672>[</span>bool<span style=color:#f92672>]</span><span style=color:#e6db74>`</span> cannot be known at compilation time
 --&gt; src/main.rs:8:5
  |
<span style=color:#ae81ff>8</span> |     BloomFilter <span style=color:#f92672>{</span> bits <span style=color:#f92672>}</span>;
  |     ^^^^^^^^^^^^^^^^^^^^ doesn<span style=color:#960050;background-color:#1e0010>&#39;</span>t have a size known at compile-time
</code></pre></div><p>原因有二，其一同樣是 array <code>bits</code> 需要一個常數長度；其二則是 <code>bits</code> 是一個 <a href=https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>Dynamic Sized Types（Dsts）</a> ，長度無法在編譯時決定，編譯期就無法得知 BloomFilter 的所佔記憶體用量。</p>
<p>看來得放棄用 <code>array</code> 或 <code>slice</code> 這些方法，改用最暴力的 <code>Vec</code> 作為位元陣列儲存容器，<code>Vec</code> 雖可動態調整大小，背後其實是一個 pointer + 一個 <code>usize</code> 的 <code>capacity</code> + 一個 <code>usize</code> 的 <code>len</code> 組成，若是在 64 位元的機器上，<a href=https://cheats.rs/#general-purpose-heap-storage>一個 <code>Vec</code> 就會佔 24 位元組</a>，比起 <code>array</code> 多耗費兩個 2 * 8 個位元組空間，幸好這額外的 16 個位元組是固定支出，不隨著 $m$ 和 $n$ 成長。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>BloomFilter</span> {
  bits: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>
}
</code></pre></div><h3 id=儲存兩個雜湊函數>儲存兩個雜湊函數<a hidden class=anchor aria-hidden=true href=#儲存兩個雜湊函數>#</a></h3>
<p>再來，要在 <code>BloomFilter</code> 儲存兩個 hasher，也就是實作前面提及<a href=https://www.eecs.harvard.edu/~michaelm/postscripts/rsa2008.pdf>用兩個雜湊函數模擬 $k$ 個</a>論文中的兩個 hasher，這兩個在 <code>BloomFilter</code> 建構時同時建立，並在操作 <code>BloomFilter</code> 的方法上共用。</p>
<p>這次直接使用標準函式庫內預設雜湊演算法 <a href=http://doc.rust-lang.org/std/collections/hash_map/struct.DefaultHasher.html><code>DefaultHasher</code></a> 作為隨機的兩個雜湊函數 <code>BloomFilter.hashers</code>。由於是模擬 $k$ 個函數的雜湊行為，仍需另闢欄位，儲存 $k$ 實際上是多少個雜湊函數 <code>BloomFilter.hash_fn_count</code>。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>use</span> std::collections::hash_map::DefaultHasher;

<span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>BloomFilter</span> {
  <span style=color:#e6db74>/// The bit array of _m_ bits.
</span><span style=color:#e6db74></span>  bits: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>,
  <span style=color:#e6db74>/// Count of hash functions. Denoted by _k_.
</span><span style=color:#e6db74></span>  hash_fn_count: <span style=color:#66d9ef>usize</span>,
  <span style=color:#e6db74>/// The hashers that do real works.
</span><span style=color:#e6db74></span>  hashers: [DefaultHasher; <span style=color:#ae81ff>2</span>],
}
</code></pre></div><p>就剩最後一里路了！</p>
<h3 id=使用-phantomdatarust-std-marker-phantomdata-讓編譯器閉嘴>使用 <a href=https://doc.rust-lang.org/core/marker/struct.PhantomData.html><code>PhantomData</code></a> 讓編譯器閉嘴<a hidden class=anchor aria-hidden=true href=#使用-phantomdatarust-std-marker-phantomdata-讓編譯器閉嘴>#</a></h3>
<p>眾所周知，透過<a href=https://doc.rust-lang.org/book/ch10-01-syntax.html>泛型（Generic）</a>，Rust 可重用相同的容器型別，特化接受不同型別的容器，例如 <code>HashMap&lt;K, V></code> 可以特化為鍵為 <code>String</code>，值為 <code>u32</code> 的 <code>HashMap&lt;String, u32></code>，<code>Vec&lt;T></code> 可以成為二維位元組 <code>Vec&lt;Vec&lt;u8>></code>。看 <a href=http://doc.rust-lang.org/std/collections/index.html><code>std::collections</code></a> 提供的容器，所有泛型型別參數（Type Parameter）像是 <code>T</code>、<code>K</code>、<code>V</code> 都是跟著 struct 宣告，也因為這些容器的確實際儲存了這些型別的元素，泛型型別參數跟著 struct 很合理。</p>
<p>有趣的是，作為一個容器，Bloom filter 其實不儲存元素本身，而是記錄元素是否「曾經新增至」該容器中。這給了一些想像空間：如何提供型別參數給 Bloom filter？提供兩個方向：</p>
<ol>
<li><strong>泛型型別參數宣告跟著 struct：</strong> 也就是 <code>struct BloomFilter&lt;T></code>，如此一來，一個容器實例只能操作一種型別，而且在編譯期就決定。
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> bf <span style=color:#f92672>=</span> BloomFilter::new();
bf.insert(<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span>);            <span style=color:#75715e>// infer the type T is i32
</span><span style=color:#75715e></span>bf.insert(<span style=color:#e6db74>&#34;wront type&#34;</span>);  <span style=color:#75715e>// compile error: &amp;str is not compatible to i32
</span></code></pre></div></li>
<li><strong>泛型型別跟著 struct 的方法，struct 本身不宣告：</strong> 很難想像容器裡面儲存不同的型別，但 BloomFilter 實際上只需要一個 <code>Vec&lt;bool></code> 記錄存在與否，到底新增了什麼型別的元素其實不重要，型別有實作雜湊就行。這個作法下，你可能會看到這種邪魔歪道：
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> bf <span style=color:#f92672>=</span> BloomFilter::new();
bf.insert(<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span>);
bf.insert(<span style=color:#e6db74>&#34;another type&#34;</span>);  <span style=color:#75715e>// it works
</span><span style=color:#75715e></span>bf.insert(vec![<span style=color:#ae81ff>3.14159</span>]);   <span style=color:#75715e>// it also works
</span></code></pre></div></li>
</ol>
<p>為了讓容器有一致感，這裡決定選擇法一，讓泛型跟著容器走。實作非常簡單，加上 <code>T</code> 泛型參數就行</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff>use std::collections::hash_map::DefaultHasher;

<span style=color:#f92672>- pub struct BloomFilter {
</span><span style=color:#f92672></span><span style=color:#a6e22e>+ pub struct BloomFilter&lt;T&gt; {
</span><span style=color:#a6e22e></span>  /// .. snip
}
</code></pre></div><p>哎呀，編譯失敗！</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>error<span style=color:#f92672>[</span>E0392<span style=color:#f92672>]</span>: parameter <span style=color:#e6db74>`</span>T<span style=color:#e6db74>`</span> is never used
 --&gt; src/lib.rs:3:24
  |
<span style=color:#ae81ff>3</span> | pub struct BloomFilter&lt;T&gt; <span style=color:#f92672>{</span>
  |                        ^ unused parameter
  |
  <span style=color:#f92672>=</span> help: consider removing <span style=color:#e6db74>`</span>T<span style=color:#e6db74>`</span>, referring to it in a field, or using a marker such as <span style=color:#e6db74>`</span>std::marker::PhantomData<span style=color:#e6db74>`</span>
</code></pre></div><p>因為 Rust 編譯器認為 <code>BloomFilter</code> 並不實際擁有 <code>T</code> 相關欄位，因此編譯不通過，我們可以利用 <a href=https://doc.rust-lang.org/core/marker/struct.PhantomData.html><code>std::marker::PhantomData</code></a>，<code>PhantomData</code> 是一個 Zero-Sized Type 不佔空間，就是為了取悅編譯器，製造出 struct 擁有 <code>T</code> 的假象。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>use</span> std::collections::hash_map::DefaultHasher;
<span style=color:#66d9ef>use</span> std::marker::PhantomData;

<span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>BloomFilter</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
  <span style=color:#e6db74>/// The bit array of _m_ bits.
</span><span style=color:#e6db74></span>  bits: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>,
  <span style=color:#e6db74>/// Count of hash functions. Denoted by _k_.
</span><span style=color:#e6db74></span>  hash_fn_count: <span style=color:#66d9ef>usize</span>,
  <span style=color:#e6db74>/// The hashers that do real works.
</span><span style=color:#e6db74></span>  hashers: [DefaultHasher; <span style=color:#ae81ff>2</span>],
  _phantom: <span style=color:#a6e22e>PhantomData</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>,
}
</code></pre></div><h2 id=sized-讓容器可以儲存-dsts><code>?Sized</code> 讓容器可以儲存 DSTs<a hidden class=anchor aria-hidden=true href=#sized-讓容器可以儲存-dsts>#</a></h2>
<p>最後，有鑑於讓Bloom fliter 能夠接受更多型別，元素不一定要符合編譯期確定大小的 <a href=http://doc.rust-lang.org/std/marker/trait.Sized.html><code>Sized</code></a> trait bound，可以透過加上 <code>?Sized</code> trait bound 解除預設的限制，如此一來 <code>BloomFilter</code> 就可接受 slice 和 trait object 這些 <a href=https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>DSTs</a> 了，傳入 string literal 變為可能 <code>bloom_filter.insert("1234")</code>。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff>use std::collections::hash_map::DefaultHasher;
use std::marker::PhantomData;

<span style=color:#f92672>- pub struct BloomFilter&lt;T&gt; {
</span><span style=color:#f92672></span><span style=color:#a6e22e>+ pub struct BloomFilter&lt;T: ?Sized&gt; {
</span><span style=color:#a6e22e></span>    // .. snip
}
</code></pre></div><h2 id=基本操作>基本操作<a hidden class=anchor aria-hidden=true href=#基本操作>#</a></h2>
<p>Bloom filter 為類似集合的容器，當然有<a href=https://rust-algo.club/collections/set#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C>類似的操作</a>，事實上，這類機率性集合成員檢測的資料結構有個較少聽見但令人印象深刻的名字，稱為「Approximate Membership Query（AMQ）」，提供 <code>add(element)</code> 和 <code>query(element)</code> 兩個基本操作。</p>
<p>本文的 <code>BloomFilter</code> 提供下列幾個公開方法：</p>
<ul>
<li><code>new</code>：初始化一個容器。</li>
<li><code>insert</code>：新增一個元素。</li>
<li><code>contains</code>：檢查容器內有無特定元素（是否曾新增過）。</li>
</ul>
<p>以及幾個內部輔助方法：</p>
<ul>
<li><code>make_hash</code>：給定輸入元素資料，透過兩個雜湊函數產生兩個雜湊值。</li>
<li><code>get_index</code>：將 <code>make_hash</code> 的兩雜湊值帶入 $g_i(x) = h_1(x) + ih_2(x)$ 計算單次 <code>i</code> 的索引位置。</li>
<li><code>optimal_bits_count</code>：給定預期儲存元素個數 $n$ 與假陽性機率 $\epsilon$，得位元陣列最適位元數 $m$。</li>
<li><code>optimal_hashers_count</code>：給定預期假陽性機率，得最適雜湊函數個數 $k$。</li>
</ul>
<h3 id=初始化>初始化<a hidden class=anchor aria-hidden=true href=#初始化>#</a></h3>
<p>Bloom filter 有四個參數 $m$、$n$、$k$、$\epsilon$ 可以調整（詳見 <a href=#%E6%95%88%E8%83%BD>效能</a>一節），對使用者來說，有幾個雜湊函數或底層是多少個位元都是實作細節了，更關心的可能是</p>
<p><em>「我有一百萬筆資料需要驗證存在，容錯率需要在 0.1%，我需要多大的儲存空間？」</em></p>
<p>因此，建構函數 <code>new</code> 提供輸入預期儲存元素個數 $n$ 和預期的假陽性機率 $\epsilon$ 是天經地義的事：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(capacity: <span style=color:#66d9ef>usize</span>, err_rate: <span style=color:#66d9ef>f64</span>) -&gt; <span style=color:#a6e22e>Self</span>;
</code></pre></div><p>接下來，會實作<a href=#%E6%A6%82%E5%BF%B5>概念</a>一節的數學公式，找出最適位元數和最適雜湊函數個數。這兩個函數都是以 Rust 表達數學公式，可注意的點是，<a href=http://doc.rust-lang.org/std/f32/consts/index.html><code>std::f32::consts</code></a> 和 <a href=http://doc.rust-lang.org/std/f64/consts/index.html><code>std::f64::consts</code></a>，提供許多數學上常見的常數老朋友，操作浮點數和雙精度浮點數就不用自己手動重算了。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#e6db74>/// m = -1 * (n * ln ε) / (ln 2)^2
</span><span style=color:#e6db74></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>optimal_bits_count</span>(capacity: <span style=color:#66d9ef>usize</span>, err_rate: <span style=color:#66d9ef>f64</span>) -&gt; <span style=color:#66d9ef>usize</span> {
    <span style=color:#66d9ef>let</span> ln_2_2 <span style=color:#f92672>=</span> std::<span style=color:#66d9ef>f64</span>::consts::LN_2.powf(<span style=color:#ae81ff>2</span><span style=color:#66d9ef>f64</span>);
    (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#66d9ef>f64</span> <span style=color:#f92672>*</span> capacity <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f64</span> <span style=color:#f92672>*</span> err_rate.ln() <span style=color:#f92672>/</span> ln_2_2).ceil() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>
}

<span style=color:#e6db74>/// k = -log_2 ε
</span><span style=color:#e6db74></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>optimal_hashers_count</span>(err_rate: <span style=color:#66d9ef>f64</span>) -&gt; <span style=color:#66d9ef>usize</span> {
    (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#66d9ef>f64</span> <span style=color:#f92672>*</span> err_rate.log2()).ceil() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>
}
</code></pre></div><p>目前為止，<code>BloomFilter::new</code> 長這樣：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(capacity: <span style=color:#66d9ef>usize</span>, err_rate: <span style=color:#66d9ef>f64</span>) -&gt; <span style=color:#a6e22e>Self</span> {
    <span style=color:#66d9ef>let</span> bits_count <span style=color:#f92672>=</span> Self::optimal_bits_count(capacity, err_rate);
    <span style=color:#66d9ef>let</span> hash_fn_count <span style=color:#f92672>=</span> Self::optimal_hashers_count(err_rate);
}
</code></pre></div><p>最後，按照前述<a href=https://www.eecs.harvard.edu/~michaelm/postscripts/rsa2008.pdf>兩個雜湊函數恰恰好</a>的道理，建立兩個不同的雜湊函數，並初始化位元陣列，大功告成！</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(capacity: <span style=color:#66d9ef>usize</span>, err_rate: <span style=color:#66d9ef>f64</span>) -&gt; <span style=color:#a6e22e>Self</span> {
    <span style=color:#75715e>// #1 Get optimal count of bit
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> bits_count <span style=color:#f92672>=</span> Self::optimal_bits_count(capacity, err_rate);
    <span style=color:#75715e>// #2 Get optimal count of hash functions
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> hash_fn_count <span style=color:#f92672>=</span> Self::optimal_hashers_count(err_rate);
    <span style=color:#75715e>// #3 Use RandomState to build different hasher
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> hashers <span style=color:#f92672>=</span> [
        RandomState::new().build_hasher(),
        RandomState::new().build_hasher(),
    ];

    Self {
        bits: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[<span style=color:#66d9ef>false</span>; bits_count], <span style=color:#75715e>// #4 Initialize a all zero bit array
</span><span style=color:#75715e></span>        hash_fn_count,
        hashers,
        _phantom: <span style=color:#a6e22e>PhantomData</span>,
    }
}
</code></pre></div><ol>
<li>透過指定假陽性機率與預期元素個數，算得最適位元數</li>
<li>透過指定假陽性機率，算得最適雜湊函數個數</li>
<li>透過 std 內建的 <a href=http://doc.rust-lang.org/std/collections/hash_map/struct.RandomState.html><code>RandomState</code></a> 產生兩個不同初始狀態的雜湊函數，以模擬 $k$ 個雜湊函數</li>
<li>初始化一個全零的位元陣列</li>
</ol>
<h3 id=新增>新增<a hidden class=anchor aria-hidden=true href=#新增>#</a></h3>
<p>新增一個元素到 Bloom filter，說穿了就做一件事：將元素透過 $k$ 個雜湊函數，產出 $k$ 個索引位置，並將位元陣列上這些位置的位元翻轉至 1。</p>
<p>整個 <code>insert</code> 函數即為計算 $g_i(x) = h_1(x) + ih_2(x)$ 模擬 $k$ 個雜湊函數的過程：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>insert</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, elem: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>T</span>)
<span style=color:#66d9ef>where</span>
    T: <span style=color:#a6e22e>Hash</span>,
{
    <span style=color:#66d9ef>let</span> hashes <span style=color:#f92672>=</span> self.make_hash(elem);  <span style=color:#75715e>// #1
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> fn_i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.hash_fn_count { <span style=color:#75715e>// #2
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> index <span style=color:#f92672>=</span> self.get_index(hashes, fn_i <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>); <span style=color:#75715e>// #3
</span><span style=color:#75715e></span>        self.bits[index] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;        <span style=color:#75715e>// #4
</span><span style=color:#75715e></span>    }
}
</code></pre></div><ol>
<li>取得 $h_1(x)$ 和 $h_2(x)$ 的雜湊輸出結果。</li>
<li>迭代 <code>i</code> 次，<code>i</code> 上限為 $k$：初始化時所得的最適雜湊函數個數</li>
<li>計算 $g_i(x) = h_1(x) + ih_2(x)$ 取得索引位置</li>
<li>將索引位置下的位元設定為 1</li>
</ol>
<p>這裡有兩個內部方法，先講解如何計算 $h_1(x)$ 和 $h_2(x)$：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>make_hash</span>(<span style=color:#f92672>&amp;</span>self, elem: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>T</span>) -&gt; (<span style=color:#66d9ef>u64</span>, <span style=color:#66d9ef>u64</span>)
<span style=color:#66d9ef>where</span>
    T: <span style=color:#a6e22e>Hash</span>,
{
    <span style=color:#75715e>// #1
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> hasher1 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self.hashers[<span style=color:#ae81ff>0</span>].clone();
    <span style=color:#66d9ef>let</span> hasher2 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self.hashers[<span style=color:#ae81ff>1</span>].clone();

    <span style=color:#75715e>// #2
</span><span style=color:#75715e></span>    elem.hash(hasher1);
    elem.hash(hasher2);

    <span style=color:#75715e>// #3
</span><span style=color:#75715e></span>    (hasher1.finish(), hasher2.finish())
}
</code></pre></div><ol>
<li>為保存兩個 hasher 內部初始狀態，使用 <code>clone</code> 複製新的 hasher 來做雜湊</li>
<li>將 <code>elem</code> 餵給 hasher 計算雜湊值</li>
<li>輸出雜湊值，由於 <a href=http://doc.rust-lang.org/core/hash/trait.Hasher.html#tymethod.finish><code>Hasher::finish</code></a> 不會重設 hasher 內部狀態，所以需要步驟一 <code>clone</code> 來保留 hasher 的原始狀態</li>
</ol>
<p>再來是實作計算索引位置 $g_i(x) = h_1(x) + ih_2(x)$，這個函數非常單純，就是輸入 <code>make_hash</code> 所得之雜湊值，然後帶入公式中。為了防止輸出的索引位置超過位元陣列的位元數，這裡以位元數 $m$ 取模（<code>%</code> modulo），加上使用 <code>wrapping_ops</code> 這些 modular arithmetic operation 達成。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_index</span>(<span style=color:#f92672>&amp;</span>self, (h1, h2): (<span style=color:#66d9ef>u64</span>, <span style=color:#66d9ef>u64</span>), fn_i: <span style=color:#66d9ef>u64</span>) -&gt; <span style=color:#66d9ef>usize</span> {
    (h1.wrapping_add(fn_i.wrapping_mul(h2)) <span style=color:#f92672>%</span> self.bits.len() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>
}
</code></pre></div><h3 id=查詢>查詢<a hidden class=anchor aria-hidden=true href=#查詢>#</a></h3>
<p>查詢元素是否在 Bloom filter 裡面，就是看看該元素透過 $k$ 個雜湊函數輸出的每個索引位置<strong>全部為 1</strong>，則可能存在；否則就是絕對不存在。</p>
<p>實作步驟和插入非常相似：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>contains</span>(<span style=color:#f92672>&amp;</span>self, elem: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>T</span>) -&gt; <span style=color:#66d9ef>bool</span>
<span style=color:#a6e22e>where</span>
    T: <span style=color:#a6e22e>Hash</span>,
{
    <span style=color:#66d9ef>let</span> hashes <span style=color:#f92672>=</span> self.make_hash(elem); <span style=color:#75715e>// #1
</span><span style=color:#75715e></span>    (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.hash_fn_count).all(<span style=color:#f92672>|</span>fn_i<span style=color:#f92672>|</span> { <span style=color:#75715e>// #1 使用 iter
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> index <span style=color:#f92672>=</span> self.get_index(hashes, fn_i <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>);
        self.bits[index]
    })
}
</code></pre></div><ol>
<li>取得 $h_1(x)$ 和 $h_2(x)$ 的雜湊輸出結果。</li>
<li>使用 <a href=http://doc.rust-lang.org/1.45.2/core/iter/trait.Iterator.html#method.all>Iterator::all</a> 迭代收集 $k$ 個雜湊函數的輸出</li>
<li>計算 $g_i(x) = h_1(x) + ih_2(x)$ 取得索引位置</li>
<li>回傳索引位置下的位元 <code>bool</code> 值，此值會匯集起來，於步驟二確認命中全部 $k$ 個索引，即為元素存在</li>
</ol>
<p>完整程式碼如下，或轉駕到 <a href=/doc/rust_algorithm_club/collections/struct.BloomFilter.html>API 文件</a>：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>BloomFilter</span><span style=color:#f92672>&lt;</span>T: <span style=color:#f92672>?</span>Sized<span style=color:#f92672>&gt;</span> {
    bits: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span>,
    hash_fn_count: <span style=color:#66d9ef>usize</span>,
    hashers: [DefaultHasher; <span style=color:#ae81ff>2</span>],
    _phantom: <span style=color:#a6e22e>PhantomData</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>,
}

<span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T: <span style=color:#f92672>?</span>Sized<span style=color:#f92672>&gt;</span> BloomFilter<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(capacity: <span style=color:#66d9ef>usize</span>, err_rate: <span style=color:#66d9ef>f64</span>) -&gt; <span style=color:#a6e22e>Self</span> {
        <span style=color:#66d9ef>let</span> bits_count <span style=color:#f92672>=</span> Self::optimal_bits_count(capacity, err_rate);
        <span style=color:#66d9ef>let</span> hash_fn_count <span style=color:#f92672>=</span> Self::optimal_hashers_count(err_rate);
        <span style=color:#66d9ef>let</span> hashers <span style=color:#f92672>=</span> [
            RandomState::new().build_hasher(),
            RandomState::new().build_hasher(),
        ];

        Self {
            bits: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[<span style=color:#66d9ef>false</span>; bits_count],
            hash_fn_count,
            hashers,
            _phantom: <span style=color:#a6e22e>PhantomData</span>,
        }
    }

    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>insert</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, elem: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>T</span>)
    <span style=color:#66d9ef>where</span>
        T: <span style=color:#a6e22e>Hash</span>,
    {
        <span style=color:#75715e>// g_i(x) = h1(x) + i * h2(x)
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> hashes <span style=color:#f92672>=</span> self.make_hash(elem);
        <span style=color:#66d9ef>for</span> fn_i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.hash_fn_count {
            <span style=color:#66d9ef>let</span> index <span style=color:#f92672>=</span> self.get_index(hashes, fn_i <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>);
            self.bits[index] <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
        }
    }

    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>contains</span>(<span style=color:#f92672>&amp;</span>self, elem: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>T</span>) -&gt; <span style=color:#66d9ef>bool</span>
    <span style=color:#a6e22e>where</span>
        T: <span style=color:#a6e22e>Hash</span>,
    {
        <span style=color:#66d9ef>let</span> hashes <span style=color:#f92672>=</span> self.make_hash(elem);
        (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>self.hash_fn_count).all(<span style=color:#f92672>|</span>fn_i<span style=color:#f92672>|</span> {
            <span style=color:#66d9ef>let</span> index <span style=color:#f92672>=</span> self.get_index(hashes, fn_i <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>);
            self.bits[index]
        })
    }

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_index</span>(<span style=color:#f92672>&amp;</span>self, (h1, h2): (<span style=color:#66d9ef>u64</span>, <span style=color:#66d9ef>u64</span>), fn_i: <span style=color:#66d9ef>u64</span>) -&gt; <span style=color:#66d9ef>usize</span> {
        (h1.wrapping_add(fn_i.wrapping_mul(h2)) <span style=color:#f92672>%</span> self.bits.len() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u64</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>
    }

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>make_hash</span>(<span style=color:#f92672>&amp;</span>self, elem: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>T</span>) -&gt; (<span style=color:#66d9ef>u64</span>, <span style=color:#66d9ef>u64</span>)
    <span style=color:#66d9ef>where</span>
        T: <span style=color:#a6e22e>Hash</span>,
    {
        <span style=color:#66d9ef>let</span> hasher1 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self.hashers[<span style=color:#ae81ff>0</span>].clone();
        <span style=color:#66d9ef>let</span> hasher2 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self.hashers[<span style=color:#ae81ff>1</span>].clone();

        elem.hash(hasher1);
        elem.hash(hasher2);

        (hasher1.finish(), hasher2.finish())
    }

    <span style=color:#e6db74>/// m = -1 * (n * ln ε) / (ln 2)^2
</span><span style=color:#e6db74></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>optimal_bits_count</span>(capacity: <span style=color:#66d9ef>usize</span>, err_rate: <span style=color:#66d9ef>f64</span>) -&gt; <span style=color:#66d9ef>usize</span> {
        <span style=color:#66d9ef>let</span> ln_2_2 <span style=color:#f92672>=</span> std::<span style=color:#66d9ef>f64</span>::consts::LN_2.powf(<span style=color:#ae81ff>2</span><span style=color:#66d9ef>f64</span>);
        (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#66d9ef>f64</span> <span style=color:#f92672>*</span> capacity <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f64</span> <span style=color:#f92672>*</span> err_rate.ln() <span style=color:#f92672>/</span> ln_2_2).ceil() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>
    }

    <span style=color:#e6db74>/// k = -log_2 ε
</span><span style=color:#e6db74></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>optimal_hashers_count</span>(err_rate: <span style=color:#66d9ef>f64</span>) -&gt; <span style=color:#66d9ef>usize</span> {
        (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#66d9ef>f64</span> <span style=color:#f92672>*</span> err_rate.log2()).ceil() <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>
    }
}
</code></pre></div><h2 id=效能>效能<a hidden class=anchor aria-hidden=true href=#效能>#</a></h2>
<table>
<thead>
<tr>
<th>Notation</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>$n$</td>
<td>預期儲存 $n$ 個元素到容器中</td>
</tr>
<tr>
<td>$m$</td>
<td>使用 $m$ 位元的位元陣列來儲存</td>
</tr>
<tr>
<td>$k$</td>
<td>有 $k$ 個雜湊函數計算索引位置</td>
</tr>
<tr>
<td>$\epsilon$</td>
<td>假陽性錯誤的機率 $\epsilon$</td>
</tr>
</tbody>
</table>
<p>和常見的容器資料結構不太一樣，複雜度和 $n$ 元素個數脫鉤，而是和 $k$ 和 $m$ 相關：</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Time complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td>insert(v)</td>
<td>$O(k)$</td>
</tr>
<tr>
<td>contains(v)</td>
<td>$O(k)$</td>
</tr>
</tbody>
</table>
<p>而儲存空間複雜度則是 $O(m)$。</p>
<p>新增和搜尋一個元素個別需要雜湊 $k$ 次，因此時間複雜度為 $O(k)$ 顯而易見，然而，$k$ 通常相對 $m$ $n$ 是非常小的數字，例如
<a href="https://hur.st/bloomfilter/?n=1M&p=0.001&m=&k=">在 0.1% 錯誤率下儲存一百萬個元素僅需 1.71 MiB 和 7 個雜湊函數</a>，實務上直接當作 $O(1)$ 也不算錯。</p>
<p>至於空間複雜度，由於必須事先配置好 $m$ 位元的位元陣列，就算新增的元素 $n \gt m$，也不會再新增新位元，因此空間使用為 $O(m)$ 個位元。實務上，當 $n$ 成長到接近 $m$ 時，假陽性的機率會大增，不堪使用，進而需要能動態調整儲存空間的 Bloom filter 變形。</p>
<h2 id=變形>變形<a hidden class=anchor aria-hidden=true href=#變形>#</a></h2>
<p>經典款 Bloom filter 容易實作，歷久不衰，不過仍有許多可以增進空間：</p>
<ul>
<li>Data locality 不夠好：Bloom filter 底層儲存是位元陣列<a href=https://en.wikipedia.org/wiki/Random_access>隨機存取</a>，較不符合現代 CPU 架構的 cache line 使用姿勢。Cloudflare 技術部落格文 <a href=https://blog.cloudflare.com/when-bloom-filters-dont-bloom/>When Bloom filters don&rsquo;t bloom</a> 以幽默筆法帶出這個問題，值得一讀。</li>
<li>雜湊次數過多：Bloom filter 每一個新增查詢操作都需要雜湊 $k$ 次，就算利用 double hashing 還是要雜湊兩次，比起其他類似資料結構硬生生多雜湊數次。</li>
<li>位元陣列大小固定：Bloom filter 容器大小固定，給你預期的元素個數後，無法動態調整儲存空間，</li>
<li>bits per entry 較高：以類似功能的的資料結構來說，Bloom filter 在空間利用率上，欲維持一定的假陽性機率，每個元素所需位元數相對較高，需要 $1.44 \log_2{\frac{1}{\epsilon}}$ 個位元。</li>
</ul>
<p>這裡介紹幾款嘗試解決上述問題的 filter，您也可以去 <a href=https://en.wikipedia.org/wiki/Bloom_filter#Extensions_and_applications>Wikipedia 看看其他更多變形的介紹</a>。</p>
<h3 id=可以計數的-counting-bloom-filter>可以計數的 Counting Bloom filter<a hidden class=anchor aria-hidden=true href=#可以計數的-counting-bloom-filter>#</a></h3>
<p><a href=https://en.wikipedia.org/wiki/Counting_Bloom_filter>📚 維基百科</a></p>
<p>經典款 Bloom filter 之所以無法刪除元素，是因為沒有記錄哪些元素新增/刪除的資訊，而 Counting Bloom filter 顧名思義，原本用一個位元儲存 0 / 1 資訊，延伸為多位元方便儲存計數（counting），有了個別元素增刪資訊，Bloom filter 因此能實作「刪除元素」。搜尋一個 Counting Bloom filter 是否擁有 n 次以上 x，答案一樣和 Bloom filter 類似是「可能有 n 次以上的 x」或是「x 絕對沒有 n 次以上」。事實上，可將 Counting Bloom filter 視為 Bloom filter 的一般化形式（generalized form），而經典款 Bloom filter 反過來可當作只記一次數的特化。</p>
<p>但 Counting Bloom filter 的缺點是空間需求大，端看決定要用幾個位元計數，例如常見用 4 個位元計數，則是經典款的四倍空間消耗。</p>
<h3 id=動態適應空間大小的-scalable-bloom-filter>動態適應空間大小的 Scalable Bloom Filter<a hidden class=anchor aria-hidden=true href=#動態適應空間大小的-scalable-bloom-filter>#</a></h3>
<p><a href=https://gsd.di.uminho.pt/members/cbm/ps/dbloom.pdf>📚 論文連結</a></p>
<p>Scalable Bloom Filter 的特色是：動態適應空間大小，不需事先知道預期儲存的元素個數。</p>
<p>Scalable Bloom Filter 的實作蠻暴力的，本身是由一至多個經典款 Bloom filter 組成，若一個 filter 滿了（超過 fill ratio），則會新增一個 filter，往後所有新增都在這個新 filter 上面，直到它也滿了，可視為一個 recursive data structure。</p>
<p>至於查詢，這就是 Scalable Bloom Filter 比較弱的地方，查詢會從第一個 filter 開始找，若找不到往下一個 filter 找，找到會沒有下一個 filter 為止。若 filter 數量為 $l$，則查詢的時間複雜度從 $O(k)$ 變成 $O(k \cdot l)$。</p>
<p>除了初始化大小和假陽性機率率，Scalable Bloom Filter 提供設定成長率和假陽性錯誤緊縮率：</p>
<ul>
<li>成長因子 $s$：每個新增的 filter 空間大小成長率，論文的經驗法則得出預期小成長趨勢選擇 $s = 2$，有較大成長趨勢則 $s = 4$ 效果好。</li>
<li>錯誤緊縮率 $r$： 每個新增的 filter 會以等比級數得到更緊縮的假陽性機率上限，由於是等比級數，逼近極限時會小於原始機率，這讓整體假陽性機率得以保持。論文中實證 0.8 到 0.9 在元素預期有大成長率下有最佳平均空間利用率。</li>
</ul>
<h3 id=quotient-filter>Quotient filter<a hidden class=anchor aria-hidden=true href=#quotient-filter>#</a></h3>
<p><a href=http://vldb.org/pvldb/vol5/p1627_michaelabender_vldb2012.pdf>📚 論文連結</a>（直接讀論文更易懂）</p>
<p>商數過濾器（Quotient filterF）利用<a href=https://rust-algo.club/collections/hash_map>雜湊表</a>為底層儲存容器，來做集合成員檢測的 AMQ，為了節省空間使用量，Quotient filter 的雜湊表只儲存 partial-key，俗稱指紋（fingerprint），指紋的鍵短空間用量低，副作用是更容易碰撞，代表需要更有效處理雜湊碰撞（hash collision）。</p>
<p>一般來說，<a href=https://rust-algo.club/collections/hash_map#%E8%99%95%E7%90%86%E9%9B%9C%E6%B9%8A%E7%A2%B0%E6%92%9E>處理雜湊碰撞</a>有 separate chaining 和 Open addressping 兩大類方法，而 Quotient filter 選擇了另一條詭譎的方法：利用 open addressing 中 linear probing 的方式，對每個 slot 儲存額外資訊，使得我們可辨認碰撞的元素是在相同指紋下的同個 bucket 內。換句話說，額外資訊就是在「透過 linear probing 模擬 separate chaining」。</p>
<p>回到指紋，Quotient filter 實際上並不直接儲存指紋，而是將指紋 $f$ 進一步拆成商 $f_q$ 與餘數 $f_r$，商作為索引位置，而餘數則為真實被儲存的值。透過商和餘數，可重組回推原本的指紋。不需存完整的指紋，又再次減少空間使用量，帥！</p>
<p>簡單總結 Quotient filter 的特性：</p>
<ul>
<li>使用 linear probing 解決雜湊碰撞，data locality 好，有 cache friendly。</li>
<li>有額外儲存資訊，可在不重建不 rehash filter 的情況下支援刪除、合併、調整空間。</li>
<li>綜合上述兩點，非常適合 LSM-tree 等需要存取 SSD 的場景，大幅減少 I/O。</li>
<li>Throughput 受到雜湊表 load factor 影響較大。</li>
<li>空間用量仍比經典款 Bloom filter 多 10% 到 25%。</li>
</ul>
<p><img loading=lazy src=./quotient-filter.png alt>
</p>
<blockquote>
<p>Quotient filter 與它等價的 open addressing hash map</p>
</blockquote>
<p><em>Image Source: <a href=http://vldb.org/pvldb/vol5/p1627_michaelabender_vldb2012.pdf>Bender, et al., 2012. &ldquo;Don’t Thrash: How to Cache Your Hash on Flash&rdquo;</a>.</em></p>
<h3 id=支援刪除元素的-cuckoo-filter>支援刪除元素的 Cuckoo filter<a hidden class=anchor aria-hidden=true href=#支援刪除元素的-cuckoo-filter>#</a></h3>
<p><a href=https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf>📚 論文連結</a>（有趣易讀，誠摯推薦）</p>
<p>Cuckoo hashing 是一種解決雜湊碰撞的方法，透過一次計算兩個雜湊函數產生兩個索引位置，若其中一個位置有空位則插入空位，若都沒有空位，則隨機踢掉一個，被踢掉的再去找下一個替死鬼，直到全部都有位置，或踢掉次數大於一定值則停止。這種行為和杜鵑鳥（cuckoo、布穀鳥）鳩佔鵲巢的生物習性很像，因此得名。</p>
<p>Cuckoo filter 利用<a href=./hash_map>雜湊表</a>為底層儲存容器，來做集合成員檢測的 AMQ，會和 cuckoo 扯上關係則是因為使用 Cuckoo hashing 解決雜湊碰撞，以增加空間使用率（達到 95% occupancy）。Cuckoo filter 的雜湊表和 Quotient filter 一樣，為了減少空間使用量而只儲存 partial-key。</p>
<p>儲存指紋導致鍵變短，容易碰撞，也代表萬一碰撞，沒辦法透過原始的鍵再次雜湊來找到 Cuckoo hasing 對應另一位置，不過 Cuckoo filter 巧妙利用 XOR 的 identity $x \oplus x = 0$ 解決問題，double hashing 公式奉上：</p>
<p>$$
h_1(x) = hash(x) \\
h_2(x) = h_1(x) \oplus hash(fingerprint(x))
$$</p>
<p>如此一次，透過 $h_2(x)$ 和指紋的 XOR 就可以得到 $h_1(x)$，公式進而可一般化成：</p>
<p>$$j = i \oplus hash(fingerprint(x))$$</p>
<p>其中 $j$ 與 $i$ 為同個元素經過兩個雜湊函數中任一的值，神奇吧！</p>
<p>Cuckoo filter 的特性是：</p>
<ul>
<li>支援動態新增與刪除元數。</li>
<li>比其他 filter 變形（例如 Quotient filter）好實作，如果懂 Cuckoo hashing 的話。</li>
<li>查詢效能比經典款 Bloom filter 好，bits per item 也比較低（$(\log_2{\frac{1}{\epsilon}} + 2) / \alpha$，$\alpha$ 是雜湊表的 load factor，通常為 95.5%）。</li>
<li>缺點是「一定要先新增過一個元素，才能對 filter 刪除該元素」，但這是所有支援刪除的 filter 的通病，不然就會有假陽性發生。</li>
</ul>
<p><img loading=lazy src=./cuckoo-filter.png alt>
</p>
<p><em>Image Source: <a href=https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf>Fan, et al., 2014. &ldquo;Cuckoo Filter: Practically Better Than Bloom&rdquo;</a>.</em></p>
<h2 id=參考資料>參考資料<a hidden class=anchor aria-hidden=true href=#參考資料>#</a></h2>
<ul>
<li><a href="https://citeseerx.ist.psu.edu/viewdoc/download;?doi=10.1.1.641.9096&rep=rep1&type=pdf">Burton H. Bloom: Space/Time Trade-offs in Hash Coding with Allowable Errors</a></li>
<li><a href=https://en.wikipedia.org/wiki/Bloom_filter>Wiki: Bloom filter</a></li>
<li><a href=https://www.eecs.harvard.edu/~michaelm/postscripts/rsa2008.pdf>Less Hashing, Same Performance:Building a Better Bloom Filter</a></li>
<li><a href=https://onatm.dev/2020/08/10/let-s-implement-a-bloom-filter/>Onat: Let&rsquo;s implement a Bloom Filter</a></li>
<li><a href=https://github.com/google/guava/blob/v29.0/guava/src/com/google/common/hash/BloomFilter.java>Google Guava: BloomFilter</a></li>
<li><a href=https://hur.st/bloomfilter/>Bloom Filter Calculator</a></li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://weihanglo.tw/tags/algorithms/>Algorithms</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://weihanglo.tw/posts/2020/rust-2020-tooling-ecosystem/>
<span class=title>« Prev Page</span>
<br>
<span>我眼中的 Rust 2020：生態工具發展</span>
</a>
<a class=next href=https://weihanglo.tw/posts/2020/www-0x17/>
<span class=title>Next Page »</span>
<br>
<span>WWW 0x17: 再見 weekly</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>CC BY-NC-SA 4.0</span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>