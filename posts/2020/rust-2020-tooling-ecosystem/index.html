<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>我眼中的 Rust 2020：生態工具發展 | Life is a refactoring process without tests</title>
<meta name=keywords content="Rust">
<meta name=description content="最近越來越多人想要學 Rust，也有一些朋友來諮詢 Rust 相關的生態，這裡稍微囉嗦一下我眼中的 Rust 2020 吧。 如果沒有拖稿的話，文章應該會分三篇，表列如下：">
<meta name=author content>
<link rel=canonical href=https://weihanglo.tw/posts/2020/rust-2020-tooling-ecosystem/>
<link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style>
<link rel=icon href=https://weihanglo.tw/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://weihanglo.tw/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://weihanglo.tw/favicon-32x32.png>
<link rel=apple-touch-icon href=https://weihanglo.tw/apple-touch-icon.png>
<link rel=mask-icon href=https://weihanglo.tw/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:!0},{left:'$',right:'$',display:!1},{left:'\\(',right:'\\)',display:!1},{left:'\\[',right:'\\]',display:!0}],throwOnError:!1})})</script>
<meta property="og:title" content="我眼中的 Rust 2020：生態工具發展">
<meta property="og:description" content="最近越來越多人想要學 Rust，也有一些朋友來諮詢 Rust 相關的生態，這裡稍微囉嗦一下我眼中的 Rust 2020 吧。 如果沒有拖稿的話，文章應該會分三篇，表列如下：">
<meta property="og:type" content="article">
<meta property="og:url" content="https://weihanglo.tw/posts/2020/rust-2020-tooling-ecosystem/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-11-01T08:00:00+08:00">
<meta property="article:modified_time" content="2020-11-01T08:00:00+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="我眼中的 Rust 2020：生態工具發展">
<meta name=twitter:description content="最近越來越多人想要學 Rust，也有一些朋友來諮詢 Rust 相關的生態，這裡稍微囉嗦一下我眼中的 Rust 2020 吧。 如果沒有拖稿的話，文章應該會分三篇，表列如下：">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://weihanglo.tw/posts/"},{"@type":"ListItem","position":3,"name":"我眼中的 Rust 2020：生態工具發展","item":"https://weihanglo.tw/posts/2020/rust-2020-tooling-ecosystem/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"我眼中的 Rust 2020：生態工具發展","name":"我眼中的 Rust 2020：生態工具發展","description":"最近越來越多人想要學 Rust，也有一些朋友來諮詢 Rust 相關的生態，這裡稍微囉嗦一下我眼中的 Rust 2020 吧。 如果沒有拖稿的話，文章應該會分三篇，表列如下：","keywords":["Rust"],"articleBody":"最近越來越多人想要學 Rust，也有一些朋友來諮詢 Rust 相關的生態，這裡稍微囉嗦一下我眼中的 Rust 2020 吧。\n如果沒有拖稿的話，文章應該會分三篇，表列如下：\n Rust 生態工具發展  有多少函式庫，都在發展什麼輪子 IDE 和 Debugger、測試和開發工具支援程度 Cross-Compilation、Distribution 工具支援程度 與其他語言的 Interpolation 穩定性與 Compatibility   Rust 業界採用情形 Rust 開源社群運作與生態  本篇將會介紹 「Rust 生態工具發展」。\n 註零：本文會有大量連結，歡迎點進去。\n註一：本文是於 2020-09-19 和朋友討論的文字整理，所以會和「好讀文章」有點差距，請見諒。\n註二：本文和 Rust 官方的 Call for blogs 2020 無關，主要是回顧 2020 這年 Rust 在我眼中如何存在。\n 與其他語言的 Interpolation 我先從「與其他語言的 Interpolation」來說：\nRust 其實一開始的定位就是 system programming language，沒有 GC，沒有 runtime（或 minimal runtime），所以跟 C 溝通非常容易，社群也有很多工具可以自動產生 header 給 C call 或是從 C lib 建立給 Rust 用的 FFI 的工具，很多社群選擇用 Rust 包裹一層 C code 就是因為 Rust 相對有許多安全檢查（預設 move semantic + object lifetime 檢查），讓 C 的 library 可稍微 robust 一點，至少 caller 這端不用自己 free 有 boundary check 不會 buffer overflow。\n對 C++ 來說也是一樣，有生成 binding 的工具，最近 Google 實驗在 Chromium 導入 Rust，所以開發了自動生成 binding 的工具，雖然 Rust 和 C++ 有諸多雷同之處（Rust for C++ programmers 參考手冊），但因為 C++ 過於複雜，所以 binding 工具有些爭議（有人怕會錯）。\n其他 GC 類語言的 binding 像 Python binding、Ruby binding、Node.js binding（N-API binding）、 Java JNI binding and another 都在蓬勃發展，我知道前四個都用用在大公司正式環境，尤其是 Python binding 看起來做得很好，基本上串接其他語言不會很痛。\n另外，敝司之前為了降低 sha256 hash 過慢，曾經用另一個快速的 cryptographic hash BLAKE3 就是用 Rust 寫然後 Node.js binding 的 node module。\n有多少函式庫，都在發展什麼輪子 再來是「有多少函式庫，都在發展什麼輪子」。\nRust 的函式庫走的是中心化 npm 風格，叫做 crates.io，上面充滿各式各樣有用和無用的函式庫，不過基本上你想做的東西一切都有，例如：\n Event loop、async runtime： 這塊目前算很成熟，官方語法只定義了 future 的介面，其他 runtime reactor task 都讓社群實作，所以出現有 libuv 等級的 tokio，第二大的 async-std，也有半官方工具包 futures，我自己覺得比 Python async 更成熟（感覺啦） Concurrency tools： 這塊非常多，有 parallism 和 channel 之類的工具，例如 rayon 的目標就是 data parallism，而 crossbeam 則是 std 的 concurrency 強化版。 Web framework： 有點像 Python 一樣多頭馬車，actix、rocket、warp 這三個自己比較推薦，但都沒有 Django 和 Rails 這麼功能豐富而肥大，比較像 falcon 那樣簡單精巧。 HTTP/gRPC：hyper 基本上是 de-facto HTTP lib，我貢獻過一些，品質不錯，最近 cURL 的作者想要底層可以抽換 hyper 這樣；gPRC 大概有三家 tonic、tarpc（Google 內部使用）、和 grpc-rs（TiDB 使用），tonic 的 benchmark 印象中和 Google 自己的 gRPC C library 比起來成績平分秋色。 搜尋引擎： 搜尋引擎和 web framework 一樣不少選項，有最近拿到融資的開源版 Algolia MeiliSearch，Elasticsearch 替代方案的 Sonic、Toshi，有加上 Raft 搜尋引擎 Bayard，還有作為 Lucene 潛在對手的 Tantivy。 遊戲引擎： Rust 就是在蠶食鯨吞 C++ 的疆域，所以有許多優秀的 engine，上次分享過的 bevy、看起來很強的 Amethyst，還有 Piston，不過 game engine 的市場大多被 Unreal 和 Unity 吃下來，所以自研引擎和遊戲目前都是小眾（但「戰神」系列的 CTO 之前說新遊戲要改用 Rust 做不知道現在怎樣了）。 物理引擎： 講完遊戲就要講它底層的物理引擎，最知名的應該是 rapier（nphysics 繼任者），當然物理引擎少不了 algebra library（還有其他小的但我忘了） parser 和程式語言： parser 不少，例如 peg parser 的 pest，或是另一個 nom parser 和 haskell parsec inspired 的 combine。用 Rust 寫出來的程式語言更多，我這邊懶得列 XDDD serialize/deserialize： 基本上這塊被 serde 一統江湖（python 超快 orjson 就是 serde binding），支援的格式很多，和 haskell 很像，只要在 struct 上面加 annotation 就會自動產生序列化反序列化的實作。而像是 Google 的 flatbuffer 也有 Rust 支援。 Graphics： 基本上 gfx-rs 整個 org 都在做 vulkan metal 還是什麼顯卡 render pipeline 的串接，剩下還有一些小的 lyon 像，Embark Studio 也在嘗試把 Rust 作為 GPU 界一等公民語言。 GUI library： 不免俗 GTK 有 binding（GNOME 官方），然後最新版的 GNOME 已經有 built-in app 是用 Rust 寫的。剩下還有什麼 azul 啊 druid 等很多，不過都沒有 Qt 成熟，也不像 Electron 方便，可以參考 areweguiyet.com 資料庫： TiKV 是 TiDB 底層的 kv storage，原生支援分散式、Sled 是小型類似 SQLite 的 KV storage 適合用在 IoT（ORM 我就不想講了） 作業系統： 這個主題比較有趣，有 AWS 開源給 container VM 的 bottlerocket，還有 AWS lambda serverless 底層的 firecracker、有 Google 下一代作業系統 Fuchsia（核心部分一半 Rust 一半 C++），還有從 kernel 開始自幹重寫的作業系統 Redox OS（真的可以在裸機上面安裝） 安全元件：openssl 的替代品 rustls 最近經過一些第三方審計，可以免除 OpenSSL heart bleeding 的問題；Sequoia-PGP 是維護 GnuPG 團隊其中三個人自己出來幹的 PGP（GPG）實作。 嵌入式系統： 這塊我比較不熟（文章都跳過），但 Rust 官方有個 dedicated 團隊在搞這個，基本上常見的開發版都能編譯，而且 Rust struct 編譯出來最後會是 zero cost abstraction，所以寫嵌入式變得更語義化，而不是一直在搞 bit。Google 和一堆知名大學也合力開發 Tock 安全嵌入式系統。 視訊、音訊： 這邊我也比較不熟，但 Mozilla 有小組在搞下一代影音格式 rav1e，應該是 AV1 官方之外最快最 robust 的選擇；image-rs 也是非常實用的各種圖片格式轉換的函式庫 前端框架與 WASM： 因為 Rust 原生支援 compile 成 WebAssembly，所以就有了好幾套前端框架，最大一套叫做 yew，核心維護者現在在台灣（是外國人）。當然 WebAssembly 目前就是 Rust 的天下，例如 WASI 這個跑在非瀏覽器的標準就是用 Rust PoC。其他 Python（RustPython） 或 Ruby（Artichoke） 的 in browser interpreter 都是借助 Rust combine to WASM 很方便才辦得到。 Scientific computing： 這塊死了又活活了又死，有很多 dataframe 或類似 pandas Weld，不過看起來還是 Python 比較有優勢。 C library binding： 太多，都可以透過工具搞出來，基本上有 C 就可以幾乎自動搞一個零成本 Rust binding 沒問題。  Cross-Compilation、Distribution 工具支援程度 接下來是「Cross-Compilation、Distribution 工具支援程度」。\n Rust 基本上 cross compilation 非常方便，除了 rustc 支援，也 cross 工具省去部分設定的麻煩，這個列出 rustc tier 1 2 3 支援列表，加上 rust compiler 現在目前就只有 rustc 一個實作，所以沒有什麼 gcc llvm 支不支援哪個 feature 的問題。 針對不同平台的 conditional compilation 也非常方便，在你要的 function struct 或是各種 item 上加 #[cfg(windows)] #[cfg(not(unix))] 之類的就可以 ，所以真的實作不同可以直接分開不用 runtime 判斷。 Rust 編譯出來的東西就是一個 binary 或 .so .dylib .dll ，如果不是 no-std（給嵌入式的特殊 cfg），除非你有另外使用其他特殊函式庫，基本上只 depends on libc，所以完全 portable，不會有什麼要 apt-get install python3-dev 之類的。 在 Linux distro 分發 Rust 的工具我知道的目前 Debian Fedora Ubuntu 已經在做，不過都是終端工具，dynamic lib 目前好像還沒有，主要是 Rust ABI 還沒有 stable 的問題 一個範例是我自己的小工具，CI 就寫這樣，然後就可以在三大平台跑測試，CD 也是類似的指定 target，就可編譯出三大平台的 binary 供下載。 另一個八卦是 ARM 最近給 Rust team 錢和編譯機器資源，想要提升 Rust 對 arm 的編譯支援程度達到 tier-1 等級，RFC 已經合併了。  IDE 和 debugger、測試和開發工具支援程度 有關「IDE 和 debugger、測試和開發工具支援程度」：\n這個你就來對時間了，如果你在 2019 年來，我會說只有 Intellij IDEA 這個 IDE 可以用，但 Rust 社群最近寫出了一個 langauge server 套件 rust-analyzer，基本上類似 reimplement rust 編譯器的部分實作，我覺得用在 VIM 搭配 YouCompleteMe 完全無違和（雖然我最近改成 Neovim built-in LSP），從 root 開 30 萬行大型專案基本上有時候一點點卡，但通常都只會進到 submodule 去修改就完全不卡。\nRust 我寫到現在很少用到 debugger，而且因為通常編譯錯誤多於 runtime error，所以其實相較之下很少用到 debugger，如果真的要用就要靠 Intellij IDEA 的 IDE 支援，或是 VS Code + rust-analyzer 下 breakpoint，這是我自己不熟從 terminal 下斷點啦，不過 Rust 最容易被誇獎的地方就是 compile error 非常明確告知是什麼原因，甚至會教你要怎麼改寫，我覺得 DX 很好。\nRust 編譯不用自己 link，類似 cmake 和 ninja 的工具叫做 cargo，其實應該算 npm + build system 集大成，所以不用記得一堆指令，寫好 Cargo.toml（Rust 的 package.json）一切搞定。測試，benchmark，產生 API doc、發佈、跑 example 都是透過 cargo 這個工具。cargo 這個東西也支援 plugin subcommand，所以除了內建 cargo build 編譯，也可以安裝社群的 cargo cache 清理快取， cargo audit 對 dependency 安全檢查，或是 cargo afl 做 fuzz testing，有夠實用的就可能會納入官方 subcommand。\n另一個很實用的就是 Rust 的 docstring 是 markdown，所以非常好撰寫文件，我覺得可以用 markdown 當作 docstring 的原因是因為 compile strong type language 不需要再寫 parameter 是什麼，反正都在 function signature 上面。然後所有發佈到 crates.io 的 library，它的 API doc 都會統一在 docs.rs 上面出現，例如這個 Redis client 就是從 docstring 生成的文件。\nRust 的測試就更有趣了：\n Unit test： 和 source code 寫在同一個檔案裡，用 #[cfg(test)] 做到 conditional compilation，只會在編譯測試時被編譯，編譯 debug/release mode 不會，這樣除了要測試的 code 和 unit test 很接近以外，也不用再考慮「這個內部函式到底要不要測試，我是不是要 public 一下測試但在註解說不要用這是內部函式」，反正在同一個檔案都可以 access Integration test： 獨立在另一個資料夾，基本上就和大多數語言一樣，只能 access public interface，自己是一個獨立的 compile target 沒什麼太特別 Benchmark： 這算特殊的 test compile target，這裡面的測試會多跑幾次跑出統計結果這樣。 Doctest： 剛剛講的 docstring，如果 markdown 裡面有 rust code block，就可以透過 doctest 測試你的 rust code block 是否可以正確編譯成功，不會讓 doc outdated，這裡有一個很好玩的 feature，假如你的 doc 只希望顯示 3 行 code ，但 setup 這 3 行需要其他 10 行才能成功編譯，你可以用特殊的 # prefix 隱藏你不想要顯示的行數。 Examples： Rust 內建 code example compile target，在跑測試也可以一併跑這些範例，讓你範例不要 outdated  Rust 官方也有一個 formatter rustfmt，是選用的（不像 go format 不過編譯就不會過….），但是很多專案都會用，可以省去很多格式上的爭論；另外也有類似 eslint pep8 這種可以移除 bad smell 讓 code 更 rusty 的 rust-clippy（clippy 就是以前 windows 迴紋針小幫手的名字 XDD），但有時候太刁鑽個人沒有特別喜歡。\nRust 官方自己有出一個類似 nvm rvm rbenv pyenv 這種工具叫做 rustup，從下載不同版本的 Rust，安裝一些 rust 工具週邊（在 Rust 叫做 component），到鎖定某個資料夾要用哪個版本編譯，編譯的 target 要是 linux-musl 還是 linux-gnu ，32 bit 還是 64 bit，都可透過 rustup 直接 override 你的 default 設定，原本測試跑在穩定版 cargo test 你想要測試 nightly 版也只要 cargo +nightly test 就可以，神之方便。\n我自己覺得 2020 年是 Rust 開發體驗大躍進的一年，整個開發阻力降低非常多，很適合入場。\n穩定性與 Compatibility 剩最後一點「穩定性與 Compatibility」我快速打完：\n有人說 Rust 語言很新一直更版不穩定，事實上 Rust 非常嚴格遵守語義化版號 semver。從 2015 五月十五日 Rust 1.0 發佈到現在穩定版的 1.46，基本上沒有任何 breaking change。而且 Rust 版本發佈非常規率，嚴格的六週發佈一個 minor version，所以跟著官方就會一直升級上去不會有特別的問題。\nRust 團隊想要導入 breaking change 的時候怎麼辦，他們開發了一種叫做 edition 的機制，目前預計是每三年發佈一次（有點像 c++11 14 17？），這個 edition 可能會有很小的 breaking change，例如將 async 原本不是關鍵字改為關鍵字，這種情況下 Rust 官方為了不要真的引入 breaking change，用了幾個手法緩解：\n 第一個就是 edition 是可以選擇的，如果你不想要升級到 2018 版本，那就留在 2015，所有東西都照常可以使用，只是 2018 一些新的語法糖就享受不到，但所有 compile 更新什麼的都會獲得，並不是 LTS 的概念。 第二個就是 Rust 團隊為了這個 edition 專門寫了一本 Edition Guide 告訴你每個版本有什麼新功能，你需不需要，要怎麼改寫或不改寫。 第三個就是直接提供 codemod 工具 cargo fix subcommand，協助你 migrate 到新版本，但你留在 2015 版，你還是可以獲得幾乎所有編譯器的新 feature 和 bugfix，不會有任何問題和差異，就是寫法舊了點繞了點。  Rust 團隊接下來可能會為了 compatibility 做的功夫是可以在 Cargo.toml 指定最低支援的 Rust version，這可以讓社群的函式庫作者或使用者都能明確得知他的 rustc 版本是否足夠支援使用該 library，作者也可以很放心的寫出什麼時候要 drop 哪一個版本的 rustc 支援，我個人非常其他這個功能實現，但應該要一段不少的時間。\n大概以上，我還沒想到更多。\n","wordCount":"5159","inLanguage":"en","datePublished":"2020-11-01T08:00:00+08:00","dateModified":"2020-11-01T08:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://weihanglo.tw/posts/2020/rust-2020-tooling-ecosystem/"},"publisher":{"@type":"Organization","name":"Life is a refactoring process without tests","logo":{"@type":"ImageObject","url":"https://weihanglo.tw/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://weihanglo.tw accesskey=h title="Life is a refactoring process without tests (Alt + H)">Life is a refactoring process without tests</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=https://weihanglo.tw/ title=Home>
<span>Home</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
我眼中的 Rust 2020：生態工具發展
</h1>
<div class=post-meta><span title="2020-11-01 08:00:00 +0800 +0800">November 1, 2020</span>&nbsp;·&nbsp;11 min
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e8%88%87%e5%85%b6%e4%bb%96%e8%aa%9e%e8%a8%80%e7%9a%84-interpolation aria-label="與其他語言的 Interpolation">與其他語言的 Interpolation</a></li>
<li>
<a href=#%e6%9c%89%e5%a4%9a%e5%b0%91%e5%87%bd%e5%bc%8f%e5%ba%ab%e9%83%bd%e5%9c%a8%e7%99%bc%e5%b1%95%e4%bb%80%e9%ba%bc%e8%bc%aa%e5%ad%90 aria-label=有多少函式庫，都在發展什麼輪子>有多少函式庫，都在發展什麼輪子</a></li>
<li>
<a href=#cross-compilationdistribution-%e5%b7%a5%e5%85%b7%e6%94%af%e6%8f%b4%e7%a8%8b%e5%ba%a6 aria-label="Cross-Compilation、Distribution 工具支援程度">Cross-Compilation、Distribution 工具支援程度</a></li>
<li>
<a href=#ide-%e5%92%8c-debugger%e6%b8%ac%e8%a9%a6%e5%92%8c%e9%96%8b%e7%99%bc%e5%b7%a5%e5%85%b7%e6%94%af%e6%8f%b4%e7%a8%8b%e5%ba%a6 aria-label="IDE 和 debugger、測試和開發工具支援程度">IDE 和 debugger、測試和開發工具支援程度</a></li>
<li>
<a href=#%e7%a9%a9%e5%ae%9a%e6%80%a7%e8%88%87-compatibility aria-label="穩定性與 Compatibility">穩定性與 Compatibility</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>最近越來越多人想要學 Rust，也有一些朋友來諮詢 Rust 相關的生態，這裡稍微囉嗦一下我眼中的 Rust 2020 吧。</p>
<p>如果沒有拖稿的話，文章應該會分三篇，表列如下：</p>
<ul>
<li><a href=../rust-2020-tooling-ecosystem>Rust 生態工具發展</a>
<ul>
<li><a href=#%E6%9C%89%E5%A4%9A%E5%B0%91%E5%87%BD%E5%BC%8F%E5%BA%AB%E9%83%BD%E5%9C%A8%E7%99%BC%E5%B1%95%E4%BB%80%E9%BA%BC%E8%BC%AA%E5%AD%90>有多少函式庫，都在發展什麼輪子</a></li>
<li><a href=#ide-%E5%92%8C-debugger%E6%B8%AC%E8%A9%A6%E5%92%8C%E9%96%8B%E7%99%BC%E5%B7%A5%E5%85%B7%E6%94%AF%E6%8F%B4%E7%A8%8B%E5%BA%A6>IDE 和 Debugger、測試和開發工具支援程度</a></li>
<li><a href=#cross-compilationdistribution-%E5%B7%A5%E5%85%B7%E6%94%AF%E6%8F%B4%E7%A8%8B%E5%BA%A6>Cross-Compilation、Distribution 工具支援程度</a></li>
<li><a href=#%E8%88%87%E5%85%B6%E4%BB%96%E8%AA%9E%E8%A8%80%E7%9A%84-interpolation>與其他語言的 Interpolation</a></li>
<li><a href=#%E7%A9%A9%E5%AE%9A%E6%80%A7%E8%88%87-compatibility>穩定性與 Compatibility</a></li>
</ul>
</li>
<li>Rust 業界採用情形</li>
<li>Rust 開源社群運作與生態</li>
</ul>
<p>本篇將會介紹 <strong>「Rust 生態工具發展」</strong>。</p>
<blockquote>
<p>註零：本文會有大量連結，歡迎點進去。</p>
<p>註一：本文是於 2020-09-19 和朋友討論的文字整理，所以會和「好讀文章」有點差距，請見諒。</p>
<p>註二：本文和 Rust 官方的 <a href=https://blog.rust-lang.org/2019/10/29/A-call-for-blogs-2020.html>Call for blogs 2020</a> 無關，主要是回顧 2020 這年 Rust 在我眼中如何存在。</p>
</blockquote>
<h2 id=與其他語言的-interpolation>與其他語言的 Interpolation<a hidden class=anchor aria-hidden=true href=#與其他語言的-interpolation>#</a></h2>
<p>我先從「與其他語言的 Interpolation」來說：</p>
<p>Rust 其實一開始的定位就是 system programming language，沒有 GC，沒有 runtime（或 minimal runtime），所以跟 C 溝通非常容易，社群也有很多工具可以<a href=https://github.com/eqrion/cbindgen>自動產生 header 給 C call</a> 或是從 <a href=https://github.com/rust-lang/rust-bindgen>C lib 建立給 Rust 用的 FFI</a> 的工具，很多社群選擇用 Rust 包裹一層 C code 就是因為 Rust 相對有許多安全檢查（預設 <a href=https://rust-lang.tw/book-tw/ch04-00-understanding-ownership.html>move semantic</a> + <a href=https://rust-lang.tw/book-tw/ch10-03-lifetime-syntax.html>object lifetime</a> 檢查），讓 C 的 library 可稍微 robust 一點，至少 caller 這端不用自己 free 有 boundary check 不會 buffer overflow。</p>
<p>對 C++ 來說也是一樣，有<a href=https://github.com/dtolnay/cxx>生成 binding 的工具</a>，最近 Google 實驗在 <a href=https://www.chromium.org/Home/chromium-security/memory-safety/rust-and-c-interoperability>Chromium 導入 Rust</a>，所以開發了<a href=https://github.com/google/autocxx>自動生成 binding 的工具</a>，雖然 Rust 和 C++ 有諸多雷同之處（<a href=https://github.com/nrc/r4cppp>Rust for C++ programmers</a> 參考手冊），但因為 C++ 過於複雜，所以 binding 工具有些爭議（有人怕會錯）。</p>
<p>其他 GC 類語言的 binding 像 <a href=https://github.com/PyO3/pyo3>Python binding</a>、<a href=https://github.com/danielpclark/rutie>Ruby binding</a>、<a href=https://neon-bindings.com/>Node.js binding</a>（<a href=https://github.com/napi-rs/napi-rs>N-API binding</a>）、 Java <a href=https://github.com/jni-rs/jni-rs>JNI binding</a> and <a href=https://github.com/astonbitecode/j4rs>another</a> 都在蓬勃發展，我知道前四個都用用在大公司正式環境，尤其是 Python binding 看起來做得很好，基本上串接其他語言不會很痛。</p>
<p>另外，敝司之前為了降低 sha256 hash 過慢，曾經用另一個快速的 cryptographic hash <a href=https://github.com/BLAKE3-team/BLAKE3>BLAKE3</a> 就是用 Rust 寫然後 Node.js binding 的 node module。</p>
<h2 id=有多少函式庫都在發展什麼輪子>有多少函式庫，都在發展什麼輪子<a hidden class=anchor aria-hidden=true href=#有多少函式庫都在發展什麼輪子>#</a></h2>
<p>再來是「有多少函式庫，都在發展什麼輪子」。</p>
<p>Rust 的函式庫走的是中心化 npm 風格，叫做 <a href=http://crates.io/>crates.io</a>，上面充滿各式各樣有用和無用的函式庫，不過基本上你想做的東西一切都有，例如：</p>
<ul>
<li><strong>Event loop、async runtime：</strong> 這塊目前算很成熟，官方語法只定義了 future 的介面，其他 runtime reactor task 都讓社群實作，所以出現有 libuv 等級的 <a href=https://tokio.rs>tokio</a>，第二大的 <a href=https://async.rs/>async-std</a>，也有半官方工具包 <a href=https://github.com/rust-lang/futures-rs/>futures</a>，我自己覺得比 Python async 更成熟（感覺啦）</li>
<li><strong>Concurrency tools：</strong> 這塊非常多，有 parallism 和 channel 之類的工具，例如 <a href=https://github.com/rayon-rs/rayon>rayon</a> 的目標就是 data parallism，而 <a href=https://github.com/crossbeam-rs/crossbeam>crossbeam</a> 則是 std 的 concurrency 強化版。</li>
<li><strong>Web framework：</strong> 有點像 Python 一樣多頭馬車，<a href=https://actix.rs/>actix</a>、<a href=https://rocket.rs/>rocket</a>、<a href=https://github.com/seanmonstar/warp>warp</a> 這三個自己比較推薦，但都沒有 Django 和 Rails 這麼功能豐富而肥大，比較像 falcon 那樣簡單精巧。
HTTP/gRPC：<a href=https://hyper.rs/>hyper</a> 基本上是 de-facto HTTP lib，我貢獻過一些，品質不錯，最近 <a href=https://www.abetterinternet.org/post/memory-safe-curl/>cURL 的作者想要底層可以抽換 hyper 這樣</a>；gPRC 大概有三家 <a href=https://github.com/hyperium/tonic/>tonic</a>、<a href=https://github.com/google/tarpc>tarpc</a>（Google 內部使用）、和 <a href=https://github.com/tikv/grpc-rs>grpc-rs</a>（TiDB 使用），tonic 的 benchmark 印象中和 Google 自己的 gRPC C library 比起來成績平分秋色。</li>
<li><strong>搜尋引擎：</strong> 搜尋引擎和 web framework 一樣不少選項，有最近拿到融資的開源版 Algolia <a href=https://www.meilisearch.com/>MeiliSearch</a>，Elasticsearch 替代方案的 <a href=https://github.com/valeriansaliou/sonic>Sonic</a>、<a href=https://github.com/toshi-search/Toshi>Toshi</a>，有加上 Raft 搜尋引擎 <a href=https://github.com/bayard-search/bayard>Bayard</a>，還有作為 Lucene 潛在對手的 <a href=https://github.com/tantivy-search/tantivy>Tantivy</a>。</li>
<li><strong>遊戲引擎：</strong> Rust 就是在蠶食鯨吞 C++ 的疆域，所以有許多優秀的 engine，上次分享過的 <a href=https://bevyengine.org/>bevy</a>、看起來很強的 <a href=https://amethyst.rs/>Amethyst</a>，還有 <a href=https://www.piston.rs/>Piston</a>，不過 game engine 的市場大多被 Unreal 和 Unity 吃下來，所以自研引擎和遊戲目前都是小眾（但「戰神」系列的 CTO 之前說新遊戲要改用 Rust 做不知道現在怎樣了）。</li>
<li><strong>物理引擎：</strong> 講完遊戲就要講它底層的物理引擎，最知名的應該是 <a href=https://rapier.rs/>rapier</a>（<a href=https://nphysics.org/>nphysics</a> 繼任者），當然物理引擎少不了 <a href=https://nalgebra.org/>algebra library</a>（還有其他小的但我忘了）</li>
<li><strong>parser 和程式語言：</strong> parser 不少，例如 peg parser 的 <a href=https://pest.rs/>pest</a>，或是另一個 <a href=https://github.com/Geal/nom>nom</a> parser 和 haskell parsec inspired 的 <a href=https://github.com/Marwes/combine>combine</a>。用 Rust 寫出來的程式語言更多，我這邊懶得列 XDDD</li>
<li><strong>serialize/deserialize：</strong> 基本上這塊被 <a href=https://github.com/serde-rs/serde>serde</a> 一統江湖（python 超快 <a href=https://github.com/ijl/orjson/>orjson</a> 就是 serde binding），支援的格式很多，和 haskell 很像，只要在 struct 上面加 annotation 就會自動產生序列化反序列化的實作。而像是 Google 的 <a href=https://github.com/google/flatbuffers/tree/master/rust>flatbuffer 也有 Rust 支援</a>。</li>
<li><strong>Graphics：</strong> 基本上 <a href=https://github.com/gfx-rs>gfx-rs</a> 整個 org 都在做 vulkan metal 還是什麼顯卡 render pipeline 的串接，剩下還有一些小的 <a href=https://github.com/nical/lyon>lyon</a> 像，Embark Studio 也在嘗試把 Rust 作為 <a href=https://github.com/EmbarkStudios/rust-gpu>GPU 界一等公民語言</a>。</li>
<li><strong>GUI library：</strong> 不免俗 <a href=https://gtk-rs.org/>GTK 有 binding</a>（GNOME 官方），然後最新版的 GNOME 已經有 built-in app 是用 Rust 寫的。剩下還有什麼 <a href=https://azul.rs/>azul</a> 啊 <a href=https://github.com/linebender/druid>druid</a> 等很多，不過都沒有 Qt 成熟，也不像 Electron 方便，可以參考 <a href=https://www.areweguiyet.com/>areweguiyet.com</a></li>
<li><strong>資料庫：</strong> <a href=https://tikv.org>TiKV</a> 是 TiDB 底層的 kv storage，原生支援分散式、<a href=https://sled.rs/>Sled</a> 是小型類似 SQLite 的 KV storage 適合用在 IoT（ORM 我就不想講了）</li>
<li><strong>作業系統：</strong> 這個主題比較有趣，有 AWS 開源給 container VM 的 <a href=https://github.com/bottlerocket-os/bottlerocket>bottlerocket</a>，還有 AWS lambda serverless 底層的 <a href=https://github.com/firecracker-microvm/firecracker>firecracker</a>、有 Google 下一代作業系統 Fuchsia（核心部分一半 Rust 一半 C++），還有從 kernel 開始自幹重寫的作業系統 <a href=https://www.redox-os.org/>Redox OS</a>（真的可以在裸機上面安裝）
安全元件：openssl 的替代品 <a href=https://github.com/ctz/rustls>rustls</a> 最近經過一些第三方審計，可以免除 OpenSSL heart bleeding 的問題；<a href=https://sequoia-pgp.org/>Sequoia-PGP</a> 是維護 GnuPG 團隊其中三個人自己出來幹的 PGP（GPG）實作。</li>
<li><strong>嵌入式系統：</strong> 這塊我比較不熟（文章都跳過），但 Rust 官方有個 <a href=https://github.com/rust-embedded>dedicated 團隊在搞這個</a>，基本上常見的開發版都能編譯，而且 Rust struct 編譯出來最後會是 zero cost abstraction，所以寫嵌入式變得更語義化，而不是一直在搞 bit。Google 和一堆知名大學也合力開發 <a href=https://www.tockos.org/>Tock 安全嵌入式系統</a>。</li>
<li><strong>視訊、音訊：</strong> 這邊我也比較不熟，但 Mozilla 有小組在搞下一代影音格式 <a href=https://github.com/xiph/rav1e>rav1e</a>，應該是 AV1 官方之外最快最 robust 的選擇；<a href=https://github.com/image-rs/image>image-rs</a> 也是非常實用的各種圖片格式轉換的函式庫</li>
<li><strong>前端框架與 WASM：</strong> 因為 Rust 原生支援 compile 成 WebAssembly，所以就有了好幾套前端框架，最大一套叫做 <a href=https://yew.rs/>yew</a>，核心維護者現在在台灣（是外國人）。當然 WebAssembly 目前就是 Rust 的天下，例如 <a href=https://wasi.dev/>WASI</a> 這個跑在非瀏覽器的標準就是用 Rust PoC。其他 Python<a href=https://rustpython.github.io/>（RustPython）</a> 或 Ruby<a href=https://www.artichokeruby.org/>（Artichoke）</a> 的 in browser interpreter 都是借助 Rust combine to WASM 很方便才辦得到。</li>
<li><strong>Scientific computing：</strong> 這塊死了又活活了又死，有很多 dataframe 或類似 pandas <a href=https://www.weld.rs/>Weld</a>，不過看起來還是 Python 比較有優勢。</li>
<li><strong>C library binding：</strong> 太多，都可以透過工具搞出來，基本上有 C 就可以幾乎自動搞一個零成本 Rust binding 沒問題。</li>
</ul>
<h2 id=cross-compilationdistribution-工具支援程度>Cross-Compilation、Distribution 工具支援程度<a hidden class=anchor aria-hidden=true href=#cross-compilationdistribution-工具支援程度>#</a></h2>
<p>接下來是「Cross-Compilation、Distribution 工具支援程度」。</p>
<ul>
<li>Rust 基本上 cross compilation 非常方便，除了 rustc 支援，也 <a href=https://github.com/rust-embedded/cross>cross 工具</a>省去部分設定的麻煩，<a href=https://doc.rust-lang.org/nightly/rustc/platform-support.html>這個列出 rustc tier 1 2 3 支援列表</a>，加上 rust compiler 現在目前就只有 rustc 一個實作，所以沒有什麼 gcc llvm 支不支援哪個 feature 的問題。</li>
<li>針對不同平台的 conditional compilation 也非常方便，在你要的 function struct 或是各種 item 上加 <code>#[cfg(windows)]</code> <code>#[cfg(not(unix))]</code> 之類的就可以 ，所以真的實作不同可以直接分開不用 runtime 判斷。</li>
<li>Rust 編譯出來的東西就是一個 binary 或 .so .dylib .dll ，如果不是 no-std（給嵌入式的特殊 cfg），除非你有另外使用其他特殊函式庫，基本上只 depends on libc，所以完全 portable，不會有什麼要 apt-get install python3-dev 之類的。</li>
<li>在 Linux distro 分發 Rust 的工具我知道的目前 Debian Fedora Ubuntu 已經在做，不過都是終端工具，dynamic lib 目前好像還沒有，主要是 Rust ABI 還沒有 stable 的問題</li>
<li>一個範例是我自己的小工具，<a href=https://git.io/JTHYe>CI 就寫這樣</a>，然後就可以在三大平台跑測試，CD 也是類似的指定 target，就可<a href=https://git.io/JTHYe>編譯出三大平台的 binary</a> 供下載。</li>
<li>另一個八卦是 ARM 最近給 Rust team 錢和編譯機器資源，想要提升 Rust 對 arm 的編譯支援程度達到 tier-1 等級，<a href=https://git.io/JTHYz>RFC 已經合併了</a>。</li>
</ul>
<h2 id=ide-和-debugger測試和開發工具支援程度>IDE 和 debugger、測試和開發工具支援程度<a hidden class=anchor aria-hidden=true href=#ide-和-debugger測試和開發工具支援程度>#</a></h2>
<p>有關「IDE 和 debugger、測試和開發工具支援程度」：</p>
<p>這個你就來對時間了，如果你在 2019 年來，我會說只有 Intellij IDEA 這個 IDE 可以用，但 Rust 社群最近寫出了一個 langauge server 套件 <a href=https://rust-analyzer.github.io/>rust-analyzer</a>，基本上類似 reimplement rust 編譯器的部分實作，我覺得用在 VIM 搭配 YouCompleteMe 完全無違和（雖然我最近改成 <a href=https://neovim.io/doc/user/lsp.html>Neovim built-in LSP</a>），從 root 開 30 萬行大型專案基本上有時候一點點卡，但通常都只會進到 submodule 去修改就完全不卡。</p>
<p>Rust 我寫到現在很少用到 debugger，而且因為通常編譯錯誤多於 runtime error，所以其實相較之下很少用到 debugger，如果真的要用就要靠 Intellij IDEA 的 IDE 支援，或是 VS Code + rust-analyzer 下 breakpoint，這是我自己不熟從 terminal 下斷點啦，不過 Rust 最容易被誇獎的地方就是 compile error 非常明確告知是什麼原因，甚至會教你要怎麼改寫，我覺得 DX 很好。</p>
<p>Rust 編譯不用自己 link，類似 cmake 和 ninja 的工具叫做 <a href=https://doc.rust-lang.org/stable/cargo/>cargo</a>，其實應該算 npm + build system 集大成，所以不用記得一堆指令，寫好 <a href=https://doc.rust-lang.org/stable/cargo/getting-started/first-steps.html>Cargo.toml</a>（Rust 的 package.json）一切搞定。測試，benchmark，產生 API doc、發佈、跑 example 都是透過 cargo 這個工具。cargo 這個東西也支援 plugin subcommand，所以除了內建 <code>cargo build</code> 編譯，也可以安裝社群的 cargo cache 清理快取， <code>cargo audit</code> 對 dependency 安全檢查，或是 <code>cargo afl</code> 做 fuzz testing，有夠實用的就可能會納入官方 subcommand。</p>
<p>另一個很實用的就是 Rust 的 docstring 是 markdown，所以非常好撰寫文件，我覺得可以用 markdown 當作 docstring 的原因是因為 compile strong type language 不需要再寫 parameter 是什麼，反正都在 function signature 上面。然後所有發佈到 crates.io 的 library，它的 API doc 都會統一在 docs.rs 上面出現，例如這個 Redis client 就是從 docstring 生成的文件。</p>
<p>Rust 的測試就更有趣了：</p>
<ul>
<li><strong>Unit test：</strong> 和 source code 寫在同一個檔案裡，用 <code>#[cfg(test)]</code> 做到 conditional compilation，只會在編譯測試時被編譯，編譯 debug/release mode 不會，這樣除了要測試的 code 和 unit test 很接近以外，也不用再考慮「這個內部函式到底要不要測試，我是不是要 public 一下測試但在註解說不要用這是內部函式」，反正在同一個檔案都可以 access</li>
<li><strong>Integration test：</strong> 獨立在另一個資料夾，基本上就和大多數語言一樣，只能 access public interface，自己是一個獨立的 compile target 沒什麼太特別</li>
<li><strong>Benchmark：</strong> 這算特殊的 test compile target，這裡面的測試會多跑幾次跑出統計結果這樣。</li>
<li><strong>Doctest：</strong> 剛剛講的 docstring，如果 markdown 裡面有 rust code block，就可以透過 doctest 測試你的 rust code block 是否可以正確編譯成功，不會讓 doc outdated，這裡有一個很好玩的 feature，假如你的 doc 只希望顯示 3 行 code ，但 setup 這 3 行需要其他 10 行才能成功編譯，你可以用<a href=https://github.com/hyperium/hyper/blob/e90f0037d3864ce91dad59eda49659db0e6ca322/src/client/connect/http.rs#L48-L66>特殊的 <code>#</code> prefix 隱藏你不想要顯示的行數</a>。</li>
<li><strong>Examples：</strong> Rust 內建 code example compile target，在跑測試也可以一併跑這些範例，讓你範例不要 outdated</li>
</ul>
<p>Rust 官方也有一個 formatter <a href=https://github.com/rust-lang/rustfmt>rustfmt</a>，是選用的（不像 go format 不過編譯就不會過….），但是很多專案都會用，可以省去很多格式上的爭論；另外也有類似 eslint pep8 這種可以移除 bad smell 讓 code 更 rusty 的 <a href=https://github.com/rust-lang/rust-clippy>rust-clippy</a>（clippy 就是以前 windows 迴紋針小幫手的名字 XDD），但有時候太刁鑽個人沒有特別喜歡。</p>
<p>Rust 官方自己有出一個類似 nvm rvm rbenv pyenv 這種工具叫做 <a href=https://rustup.rs/>rustup</a>，從下載不同版本的 Rust，安裝一些 rust 工具週邊（在 Rust 叫做 component），到鎖定某個資料夾要用哪個版本編譯，編譯的 target 要是 linux-musl 還是 linux-gnu ，32 bit 還是 64 bit，都可透過 rustup 直接 override 你的 default 設定，原本測試跑在穩定版 <code>cargo test</code> 你想要測試 nightly 版也只要 <code>cargo +nightly test</code> 就可以，神之方便。</p>
<p>我自己覺得 2020 年是 Rust 開發體驗大躍進的一年，整個開發阻力降低非常多，很適合入場。</p>
<h2 id=穩定性與-compatibility>穩定性與 Compatibility<a hidden class=anchor aria-hidden=true href=#穩定性與-compatibility>#</a></h2>
<p>剩最後一點「穩定性與 Compatibility」我快速打完：</p>
<p>有人說 Rust 語言很新一直更版不穩定，事實上 Rust 非常嚴格遵守語義化版號 semver。從 2015 五月十五日 Rust 1.0 發佈到現在穩定版的 1.46，基本上沒有任何 breaking change。而且 Rust 版本發佈非常規率，嚴格的<a href=https://forge.rust-lang.org/#current-release-versions>六週發佈一個 minor version</a>，所以跟著官方就會一直升級上去不會有特別的問題。</p>
<p>Rust 團隊想要導入 breaking change 的時候怎麼辦，他們開發了一種叫做 edition 的機制，目前預計是每三年發佈一次（有點像 c++11 14 17？），這個 edition 可能會有很小的 breaking change，例如將 <code>async</code> 原本不是關鍵字改為關鍵字，這種情況下 Rust 官方為了不要真的引入 breaking change，用了幾個手法緩解：</p>
<ul>
<li>第一個就是 edition 是可以選擇的，如果你不想要升級到 2018 版本，那就留在 2015，所有東西都照常可以使用，只是 2018 一些新的語法糖就享受不到，但所有 compile 更新什麼的都會獲得，並不是 LTS 的概念。</li>
<li>第二個就是 Rust 團隊為了這個 edition 專門寫了一本 <a href=https://doc.rust-lang.org/edition-guide/>Edition Guide</a> 告訴你每個版本有什麼新功能，你需不需要，要怎麼改寫或不改寫。</li>
<li>第三個就是直接提供 codemod 工具 cargo fix subcommand，協助你 migrate 到新版本，但你留在 2015 版，你還是可以獲得幾乎所有編譯器的新 feature 和 bugfix，不會有任何問題和差異，就是寫法舊了點繞了點。</li>
</ul>
<p>Rust 團隊接下來可能會為了 compatibility 做的功夫是可以<a href=https://rust-lang.tw/rfcs-tw/2495-min-rust-version.html>在 <code>Cargo.toml</code> 指定最低支援的 Rust version</a>，這可以讓社群的函式庫作者或使用者都能明確得知他的 rustc 版本是否足夠支援使用該 library，作者也可以很放心的寫出什麼時候要 drop 哪一個版本的 rustc 支援，我個人非常其他這個功能實現，但應該要一段不少的時間。</p>
<p>大概以上，我還沒想到更多。</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://weihanglo.tw/tags/rust/>Rust</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://weihanglo.tw/posts/2021/deque/>
<span class=title>« Prev</span>
<br>
<span>雙端佇列 Deque</span>
</a>
<a class=next href=https://weihanglo.tw/posts/2020/bloom-filter/>
<span class=title>Next »</span>
<br>
<span>布隆過濾器 Bloom Filter</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>CC BY-NC-SA 4.0</span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>