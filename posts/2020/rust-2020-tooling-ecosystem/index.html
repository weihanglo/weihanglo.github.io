<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="最近越來越多人想要學 Rust，也有一些朋友來諮詢 Rust 相關的生態，這裡稍微囉嗦一下我眼中的 Rust 2020 吧。
如果沒有拖稿的話，文章應該會分三篇，表列如下：
 Rust 生態工具發展  有多少函式庫，都在發展什麼輪子 IDE 和 Debugger、測試和開發工具支援程度 Cross-Compilation、Distribution 工具支援程度 與其他語言的 Interpolation 穩定性與 Compatibility   Rust 業界採用情形  大型公司如 FAANG、RedHat、Dropbox、Mozilla 等如何採用 Cloudflare、Fastly 等 CDN 服務商對 Rust 的適用 區塊鏈、高頻交易、加密貨幣領域的公司 嵌入式系統、遊戲界與其他領域   Rust 開源社群  Rust 團隊開放分工的作法 工作組專案組的籌備 核心團隊對 Rust 語言的展望和規劃 研討會 Meetup 和線上討論的風氣與聚集地 台灣、華文圈的 Rust 生態    本篇將會介紹 「Rust 生態工具發展」。
 註零：本文會有大量連結，歡迎點進去。
註一：本文是於 2020-09-19 和朋友討論的文字整理，所以會和「好讀文章」有點差距，請見諒。
註二：本文和 Rust 官方的 Call for blogs 2020 無關，主要是回顧 2020 這年 Rust 在我眼中如何存在。"><meta name=theme-color content="#ffcd00"><meta property="og:title" content="我眼中的 Rust 2020：生態工具發展 • Weihang Lo"><meta property="og:description" content="最近越來越多人想要學 Rust，也有一些朋友來諮詢 Rust 相關的生態，這裡稍微囉嗦一下我眼中的 Rust 2020 吧。
如果沒有拖稿的話，文章應該會分三篇，表列如下：
 Rust 生態工具發展  有多少函式庫，都在發展什麼輪子 IDE 和 Debugger、測試和開發工具支援程度 Cross-Compilation、Distribution 工具支援程度 與其他語言的 Interpolation 穩定性與 Compatibility   Rust 業界採用情形  大型公司如 FAANG、RedHat、Dropbox、Mozilla 等如何採用 Cloudflare、Fastly 等 CDN 服務商對 Rust 的適用 區塊鏈、高頻交易、加密貨幣領域的公司 嵌入式系統、遊戲界與其他領域   Rust 開源社群  Rust 團隊開放分工的作法 工作組專案組的籌備 核心團隊對 Rust 語言的展望和規劃 研討會 Meetup 和線上討論的風氣與聚集地 台灣、華文圈的 Rust 生態    本篇將會介紹 「Rust 生態工具發展」。
 註零：本文會有大量連結，歡迎點進去。
註一：本文是於 2020-09-19 和朋友討論的文字整理，所以會和「好讀文章」有點差距，請見諒。
註二：本文和 Rust 官方的 Call for blogs 2020 無關，主要是回顧 2020 這年 Rust 在我眼中如何存在。"><meta property="og:url" content="https://weihanglo.tw/posts/2020/rust-2020-tooling-ecosystem/"><meta property="og:site_name" content="Weihang Lo"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:tag" content="Rust"><meta property="article:published_time" content="2020-11-01T08:00:00+08:00"><meta property="article:modified_time" content="2020-11-01T08:00:00+08:00"><meta name=twitter:card content="summary"><meta name=generator content="Hugo 0.74.3"><title>我眼中的 Rust 2020：生態工具發展 • Weihang Lo</title><link rel=canonical href=https://weihanglo.tw/posts/2020/rust-2020-tooling-ecosystem/><link rel=icon href=/favicon.ico><link rel=stylesheet href=/assets/css/main.ab98e12b.css><link rel=stylesheet href=/css/custom.css><style>:root{--color-accent:#ffcd00}</style></head><body class="page type-posts"><div class=site><a class=screen-reader-text href=#content>Skip to Content</a><div class=main><nav id=main-menu class="menu main-menu" aria-label="Main Menu"><div class=container><ul><li class=item><a href=/>Home</a></li><li class=item><a href=/posts/>Posts</a></li><li class=item><a href=/tags/>Tags</a></li><li class=item><a href=/about/>About</a></li></ul></div></nav><div class=header-widgets><div class=container></div></div><header id=header class="header site-header"><div class="container sep-after"><div class=header-info><p class="site-title title">Weihang Lo</p><p class="desc site-desc"></p></div></div></header><main id=content><article lang=en class=entry><header class="header entry-header"><div class="container sep-after"><div class=header-info><h1 class=title>我眼中的 Rust 2020：生態工具發展</h1></div><div class=entry-meta><span class=posted-on><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg><span class=screen-reader-text>Posted on</span>
<time class=entry-date datetime=2020-11-01T08:00:00+08:00>2020, Nov 01</time></span>
<span class=reading-time><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 15 15"/></svg>5 mins read</span></div></div></header><div class="container entry-content"><p>最近越來越多人想要學 Rust，也有一些朋友來諮詢 Rust 相關的生態，這裡稍微囉嗦一下我眼中的 Rust 2020 吧。</p><p>如果沒有拖稿的話，文章應該會分三篇，表列如下：</p><ul><li><a href=../rust-2020-tooling-ecosystem>Rust 生態工具發展</a><ul><li><a href=#%E6%9C%89%E5%A4%9A%E5%B0%91%E5%87%BD%E5%BC%8F%E5%BA%AB%E9%83%BD%E5%9C%A8%E7%99%BC%E5%B1%95%E4%BB%80%E9%BA%BC%E8%BC%AA%E5%AD%90>有多少函式庫，都在發展什麼輪子</a></li><li><a href=#ide-%E5%92%8C-debugger%E6%B8%AC%E8%A9%A6%E5%92%8C%E9%96%8B%E7%99%BC%E5%B7%A5%E5%85%B7%E6%94%AF%E6%8F%B4%E7%A8%8B%E5%BA%A6>IDE 和 Debugger、測試和開發工具支援程度</a></li><li><a href=#cross-compilationdistribution-%E5%B7%A5%E5%85%B7%E6%94%AF%E6%8F%B4%E7%A8%8B%E5%BA%A6>Cross-Compilation、Distribution 工具支援程度</a></li><li><a href=#%E8%88%87%E5%85%B6%E4%BB%96%E8%AA%9E%E8%A8%80%E7%9A%84-interpolation>與其他語言的 Interpolation</a></li><li><a href=#%E7%A9%A9%E5%AE%9A%E6%80%A7%E8%88%87-compatibility>穩定性與 Compatibility</a></li></ul></li><li>Rust 業界採用情形<ul><li>大型公司如 FAANG、RedHat、Dropbox、Mozilla 等如何採用</li><li>Cloudflare、Fastly 等 CDN 服務商對 Rust 的適用</li><li>區塊鏈、高頻交易、加密貨幣領域的公司</li><li>嵌入式系統、遊戲界與其他領域</li></ul></li><li>Rust 開源社群<ul><li>Rust 團隊開放分工的作法</li><li>工作組專案組的籌備</li><li>核心團隊對 Rust 語言的展望和規劃</li><li>研討會 Meetup 和線上討論的風氣與聚集地</li><li>台灣、華文圈的 Rust 生態</li></ul></li></ul><p>本篇將會介紹 <strong>「Rust 生態工具發展」</strong>。</p><blockquote><p>註零：本文會有大量連結，歡迎點進去。</p><p>註一：本文是於 2020-09-19 和朋友討論的文字整理，所以會和「好讀文章」有點差距，請見諒。</p><p>註二：本文和 Rust 官方的 <a href=https://blog.rust-lang.org/2019/10/29/A-call-for-blogs-2020.html>Call for blogs 2020</a> 無關，主要是回顧 2020 這年 Rust 在我眼中如何存在。</p></blockquote><h2 id=與其他語言的-interpolation>與其他語言的 Interpolation</h2><p>我先從「與其他語言的 Interpolation」來說：</p><p>Rust 其實一開始的定位就是 system programming language，沒有 GC，沒有 runtime（或 minimal runtime），所以跟 C 溝通非常容易，社群也有很多工具可以<a href=https://github.com/eqrion/cbindgen>自動產生 header 給 C call</a> 或是從 <a href=https://github.com/rust-lang/rust-bindgen>C lib 建立給 Rust 用的 FFI</a> 的工具，很多社群選擇用 Rust 包裹一層 C code 就是因為 Rust 相對有許多安全檢查（預設 <a href=https://rust-lang.tw/book-tw/ch04-00-understanding-ownership.html>move semantic</a> + <a href=https://rust-lang.tw/book-tw/ch10-03-lifetime-syntax.html>object lifetime</a> 檢查），讓 C 的 library 可稍微 robust 一點，至少 caller 這端不用自己 free 有 boundary check 不會 buffer overflow。</p><p>對 C++ 來說也是一樣，有<a href=https://github.com/dtolnay/cxx>生成 binding 的工具</a>，最近 Google 實驗在 <a href=https://www.chromium.org/Home/chromium-security/memory-safety/rust-and-c-interoperability>Chromium 導入 Rust</a>，所以開發了<a href=https://github.com/google/autocxx>自動生成 binding 的工具</a>，雖然 Rust 和 C++ 有諸多雷同之處（<a href=https://github.com/nrc/r4cppp>Rust for C++ programmers</a> 參考手冊），但因為 C++ 過於複雜，所以 binding 工具有些爭議（有人怕會錯）。</p><p>其他 GC 類語言的 binding 像 <a href=https://github.com/PyO3/pyo3>Python binding</a>、<a href=https://github.com/danielpclark/rutie>Ruby binding</a>、<a href=https://neon-bindings.com/>Node.js binding</a>（<a href=https://github.com/napi-rs/napi-rs>N-API binding</a>）、 Java <a href=https://github.com/jni-rs/jni-rs>JNI binding</a> and <a href=https://github.com/astonbitecode/j4rs>another</a> 都在蓬勃發展，我知道前四個都用用在大公司正式環境，尤其是 Python binding 看起來做得很好，基本上串接其他語言不會很痛。</p><p>另外，敝司之前為了降低 sha256 hash 過慢，曾經用另一個快速的 cryptographic hash <a href=https://github.com/BLAKE3-team/BLAKE3>BLAKE3</a> 就是用 Rust 寫然後 Node.js binding 的 node module。</p><h2 id=有多少函式庫都在發展什麼輪子>有多少函式庫，都在發展什麼輪子</h2><p>再來是「有多少函式庫，都在發展什麼輪子」。</p><p>Rust 的函式庫走的是中心化 npm 風格，叫做 <a href=http://crates.io/>crates.io</a>，上面充滿各式各樣有用和無用的函式庫，不過基本上你想做的東西一切都有，例如：</p><ul><li><strong>Event loop、async runtime：</strong> 這塊目前算很成熟，官方語法只定義了 future 的介面，其他 runtime reactor task 都讓社群實作，所以出現有 libuv 等級的 <a href=https://tokio.rs>tokio</a>，第二大的 <a href=https://async.rs/>async-std</a>，也有半官方工具包 <a href=https://github.com/rust-lang/futures-rs/>futures</a>，我自己覺得比 Python async 更成熟（感覺啦）</li><li><strong>Concurrency tools：</strong> 這塊非常多，有 parallism 和 channel 之類的工具，例如 <a href=https://github.com/rayon-rs/rayon>rayon</a> 的目標就是 data parallism，而 <a href=https://github.com/crossbeam-rs/crossbeam>crossbeam</a> 則是 std 的 concurrency 強化版。</li><li><strong>Web framework：</strong> 有點像 Python 一樣多頭馬車，<a href=https://actix.rs/>actix</a>、<a href=https://rocket.rs/>rocket</a>、[warp
(https://github.com/seanmonstar/warp) 這三個自己比較推薦，但都沒有 Django 和 Rails 這麼功能豐富而肥大，比較像 falcon 那樣簡單精巧。
HTTP/gRPC：<a href=https://hyper.rs/>hyper</a> 基本上是 de-facto HTTP lib，我貢獻過一些，品質不錯，最近 <a href=https://www.abetterinternet.org/post/memory-safe-curl/>cURL 的作者想要底層可以抽換 hyper 這樣</a>；gPRC 大概有三家 <a href=https://github.com/hyperium/tonic/>tonic</a>、<a href=https://github.com/google/tarpc>tarpc</a>（Google 內部使用）、和 <a href=https://github.com/tikv/grpc-rs>grpc-rs</a>（TiDB 使用），tonic 的 benchmark 印象中和 Google 自己的 gRPC C library 比起來成績平分秋色。</li><li><strong>搜尋引擎：</strong> 搜尋引擎和 web framework 一樣不少選項，有最近拿到融資的開源版 Algolia <a href=https://www.meilisearch.com/>MeiliSearch</a>，Elasticsearch 替代方案的 <a href=https://github.com/valeriansaliou/sonic>Sonic</a>、<a href=https://github.com/toshi-search/Toshi>Toshi</a>，有加上 Raft 搜尋引擎 <a href=https://github.com/bayard-search/bayard>Bayard</a>，還有作為 Lucene 潛在對手的 <a href=https://github.com/tantivy-search/tantivy>Tantivy</a>。</li><li><strong>遊戲引擎：</strong> Rust 就是在蠶食鯨吞 C++ 的疆域，所以有許多優秀的 engine，上次分享過的 <a href=https://bevyengine.org/>bevy</a>、看起來很強的 <a href=https://amethyst.rs/>Amethyst</a>，還有 <a href=https://www.piston.rs/>Piston</a>，不過 game engine 的市場大多被 Unreal 和 Unity 吃下來，所以自研引擎和遊戲目前都是小眾（但「戰神」系列的 CTO 之前說新遊戲要改用 Rust 做不知道現在怎樣了）。</li><li><strong>物理引擎：</strong> 講完遊戲就要講它底層的物理引擎，最知名的應該是 <a href=https://rapier.rs/>rapier</a>（<a href=https://nphysics.org/>nphysics</a> 繼任者），當然物理引擎少不了 <a href=https://nalgebra.org/>algebra library</a>（還有其他小的但我忘了）</li><li><strong>parser 和程式語言：</strong> parser 不少，例如 peg parser 的 <a href=https://pest.rs/>pest</a>，或是另一個 <a href=https://github.com/Geal/nom>nom</a> parser 和 haskell parsec inspired 的 <a href=https://github.com/Marwes/combine>combine</a>。用 Rust 寫出來的程式語言更多，我這邊懶得列 XDDD</li><li><strong>serialize/deserialize：</strong> 基本上這塊被 <a href=https://github.com/serde-rs/serde>serde</a> 一統江湖（python 超快 <a href=https://github.com/ijl/orjson/>orjson</a> 就是 serde binding），支援的格式很多，和 haskell 很像，只要在 struct 上面加 annotation 就會自動產生序列化反序列化的實作。而像是 Google 的 <a href=https://github.com/google/flatbuffers/tree/master/rust>flatbuffer 也有 Rust 支援</a>。</li><li><strong>Graphics：</strong> 基本上 <a href=https://github.com/gfx-rs>gfx-rs</a> 整個 org 都在做 vulkan metal 還是什麼顯卡 render pipeline 的串接，剩下還有一些小的 <a href=https://github.com/nical/lyon>lyon</a> 像，Embark Studio 也在嘗試把 Rust 作為 <a href=https://github.com/EmbarkStudios/rust-gpu>GPU 界一等公民語言</a>。</li><li><strong>GUI library：</strong> 不免俗 <a href=https://gtk-rs.org/>GTK 有 binding</a>（GNOME 官方），然後最新版的 GNOME 已經有 built-in app 是用 Rust 寫的。剩下還有什麼 <a href=https://azul.rs/>azul</a> 啊 <a href=https://github.com/linebender/druid>druid</a> 等很多，不過都沒有 Qt 成熟，也不像 Electron 方便，可以參考 <a href=https://www.areweguiyet.com/>areweguiyet.com</a>
資料庫：<a href=https://tikv.org>TiKV</a> 是 TiDB 底層的 kv storage，原生支援分散式、<a href=https://sled.rs/>Sled</a> 是小型類似 SQLite 的 KV storage 適合用在 IoT（ORM 我就不想講了）</li><li><strong>作業系統：</strong> 這個主題比較有趣，有 AWS 開源給 container VM 的 <a href=https://github.com/bottlerocket-os/bottlerocket>bottlerocket</a>，還有 AWS lambda serverless 底層的 <a href=https://github.com/firecracker-microvm/firecracker>firecracker</a>、有 Google 下一代作業系統 Fuchsia（核心部分一半 Rust 一半 C++），還有從 kernel 開始自幹重寫的作業系統 <a href=https://www.redox-os.org/>Redox OS</a>（真的可以在裸機上面安裝）
安全元件：openssl 的替代品 <a href=https://github.com/ctz/rustls>rustls</a> 最近經過一些第三方審計，可以免除 OpenSSL heart bleeding 的問題；<a href=https://sequoia-pgp.org/>Sequoia-PGP</a> 是維護 GnuPG 團隊其中三個人自己出來幹的 PGP（GPG）實作。</li><li><strong>嵌入式系統：</strong> 這塊我比較不熟（文章都跳過），但 Rust 官方有個 <a href=https://github.com/rust-embedded>dedicated 團隊在搞這個</a>，基本上常見的開發版都能編譯，而且 Rust struct 編譯出來最後會是 zero cost abstraction，所以寫嵌入式變得更語義化，而不是一直在搞 bit。Google 和一堆知名大學也合力開發 <a href=https://www.tockos.org/>Tock 安全嵌入式系統</a>。</li><li><strong>視訊、音訊：</strong> 這邊我也比較不熟，但 Mozilla 有小組在搞下一代影音格式 <a href=https://github.com/xiph/rav1e>rav1e</a>，應該是 AV1 官方之外最快最 robust 的選擇；<a href=https://github.com/image-rs/image>image-rs</a> 也是非常實用的各種圖片格式轉換的函式庫</li><li><strong>前端框架與 WASM：</strong> 因為 Rust 原生支援 compile 成 WebAssembly，所以就有了好幾套前端框架，最大一套叫做 <a href=https://yew.rs/>yew</a>，核心維護者現在在台灣（是外國人）。當然 WebAssembly 目前就是 Rust 的天下，例如 <a href=https://wasi.dev/>WASI</a> 這個跑在非瀏覽器的標準就是用 Rust PoC。其他 Python<a href=https://rustpython.github.io/>（RustPython）</a> 或 Ruby<a href=https://www.artichokeruby.org/>（Artichoke）</a> 的 in browser interpreter 都是借助 Rust combine to WASM 很方便才辦得到。</li><li><strong>Scientific computing：</strong> 這塊死了又活活了又死，有很多 dataframe 或類似 pandas <a href=https://www.weld.rs/>Weld</a>，不過看起來還是 Python 比較有優勢。</li><li><strong>C library binding：</strong> 太多，都可以透過工具搞出來，基本上有 C 就可以幾乎自動搞一個零成本 Rust binding 沒問題。</li></ul><h2 id=cross-compilationdistribution-工具支援程度>Cross-Compilation、Distribution 工具支援程度</h2><p>接下來是「Cross-Compilation、Distribution 工具支援程度」。</p><ul><li>Rust 基本上 cross compilation 非常方便，除了 rustc 支援，也 <a href=https://github.com/rust-embedded/cross>cross 工具</a>省去部分設定的麻煩，<a href=https://doc.rust-lang.org/nightly/rustc/platform-support.html>這個列出 rustc tier 1 2 3 支援列表</a>，加上 rust compiler 現在目前就只有 rustc 一個實作，所以沒有什麼 gcc llvm 支不支援哪個 feature 的問題。</li><li>針對不同平台的 conditional compilation 也非常方便，在你要的 function struct 或是各種 item 上加 <code>#[cfg(windows)]</code> <code>#[cfg(not(unix))]</code> 之類的就可以 ，所以真的實作不同可以直接分開不用 runtime 判斷。</li><li>Rust 編譯出來的東西就是一個 binary 或 .so .dylib .dll ，如果不是 no-std（給嵌入式的特殊 cfg），除非你有另外使用其他特殊函式庫，基本上只 depends on libc，所以完全 portable，不會有什麼要 apt-get install python3-dev 之類的。</li><li>在 Linux distro 分發 Rust 的工具我知道的目前 Debian Fedora Ubuntu 已經在做，不過都是終端工具，dynamic lib 目前好像還沒有，主要是 Rust ABI 還沒有 stable 的問題</li><li>一個範例是我自己的小工具，<a href=https://git.io/JTHYe>CI 就寫這樣</a>，然後就可以在三大平台跑測試，CD 也是類似的指定 target，就可<a href=https://git.io/JTHYe>編譯出三大平台的 binary</a> 供下載。</li><li>另一個八卦是 ARM 最近給 Rust team 錢和編譯機器資源，想要提升 Rust 對 arm 的編譯支援程度達到 tier-1 等級，<a href=https://git.io/JTHYz>RFC 已經合併了</a>。</li></ul><h2 id=ide-和-debugger測試和開發工具支援程度>IDE 和 debugger、測試和開發工具支援程度</h2><p>有關「IDE 和 debugger、測試和開發工具支援程度」：</p><p>這個你就來對時間了，如果你在 2019 年來，我會說只有 Intellij IDEA 這個 IDE 可以用，但 Rust 社群最近寫出了一個 langauge server 套件 <a href=https://rust-analyzer.github.io/>rust-analyzer</a>，基本上類似 reimplement rust 編譯器的部分實作，我覺得用在 VIM 搭配 YouCompleteMe 完全無違和（雖然我最近改成 <a href=https://neovim.io/doc/user/lsp.html>Neovim built-in LSP</a>），從 root 開 30 萬行大型專案基本上有時候一點點卡，但通常都只會進到 submodule 去修改就完全不卡。</p><p>Rust 我寫到現在很少用到 debugger，而且因為通常編譯錯誤多於 runtime error，所以其實相較之下很少用到 debugger，如果真的要用就要靠 Intellij IDEA 的 IDE 支援，或是 VS Code + rust-analyzer 下 breakpoint，這是我自己不熟從 terminal 下斷點啦，不過 Rust 最容易被誇獎的地方就是 compile error 非常明確告知是什麼原因，甚至會教你要怎麼改寫，我覺得 DX 很好。</p><p>Rust 編譯不用自己 link，類似 cmake 和 ninja 的工具叫做 <a href=https://doc.rust-lang.org/stable/cargo/>cargo</a>，其實應該算 npm + build system 集大成，所以不用記得一堆指令，寫好 <a href=https://doc.rust-lang.org/stable/cargo/getting-started/first-steps.html>Cargo.toml</a>（Rust 的 package.json）一切搞定。測試，benchmark，產生 API doc、發佈、跑 example 都是透過 cargo 這個工具。cargo 這個東西也支援 plugin subcommand，所以除了內建 <code>cargo build</code> 編譯，也可以安裝社群的 cargo cache 清理快取， <code>cargo audit</code> 對 dependency 安全檢查，或是 <code>cargo afl</code> 做 fuzz testing，有夠實用的就可能會納入官方 subcommand。</p><p>另一個很實用的就是 Rust 的 docstring 是 markdown，所以非常好撰寫文件，我覺得可以用 markdown 當作 docstring 的原因是因為 compile strong type language 不需要再寫 parameter 是什麼，反正都在 function signature 上面。然後所有發佈到 crates.io 的 library，它的 API doc 都會統一在 docs.rs 上面出現，例如這個 Redis client 就是從 docstring 生成的文件。</p><p>Rust 的測試就更有趣了：</p><ul><li><strong>Unit test：</strong> 和 source code 寫在同一個檔案裡，用 <code>#[cfg(test)]</code> 做到 conditional compilation，只會在編譯測試時被編譯，編譯 debug/release mode 不會，這樣除了要測試的 code 和 unit test 很接近以外，也不用再考慮「這個內部函式到底要不要測試，我是不是要 public 一下測試但在註解說不要用這是內部函式」，反正在同一個檔案都可以 access</li><li><strong>Integration test：</strong> 獨立在另一個資料夾，基本上就和大多數語言一樣，只能 access public interface，自己是一個獨立的 compile target 沒什麼太特別</li><li><strong>Benchmark：</strong> 這算特殊的 test compile target，這裡面的測試會多跑幾次跑出統計結果這樣。</li><li><strong>Doctest：</strong> 剛剛講的 docstring，如果 markdown 裡面有 rust code block，就可以透過 doctest 測試你的 rust code block 是否可以正確編譯成功，不會讓 doc outdated，這裡有一個很好玩的 feature，假如你的 doc 只希望顯示 3 行 code ，但 setup 這 3 行需要其他 10 行才能成功編譯，你可以用<a href=https://github.com/hyperium/hyper/blob/e90f0037d3864ce91dad59eda49659db0e6ca322/src/client/connect/http.rs#L48-L66>特殊的 <code>#</code> prefix 隱藏你不想要顯示的行數</a>。</li><li><strong>Examples：</strong> Rust 內建 code example compile target，在跑測試也可以一併跑這些範例，讓你範例不要 outdated</li></ul><p>Rust 官方也有一個 formatter <a href=https://github.com/rust-lang/rustfmt>rustfmt</a>，是選用的（不像 go format 不過編譯就不會過….），但是很多專案都會用，可以省去很多格式上的爭論；另外也有類似 eslint pep8 這種可以移除 bad smell 讓 code 更 rusty 的 <a href=https://github.com/rust-lang/rust-clippy>rust-clippy</a>（clippy 就是以前 windows 迴紋針小幫手的名字 XDD），但有時候太刁鑽個人沒有特別喜歡。</p><p>Rust 官方自己有出一個類似 nvm rvm rbenv pyenv 這種工具叫做 <a href=https://rustup.rs/>rustup</a>，從下載不同版本的 Rust，安裝一些 rust 工具週邊（在 Rust 叫做 component），到鎖定某個資料夾要用哪個版本編譯，編譯的 target 要是 linux-musl 還是 linux-gnu ，32 bit 還是 64 bit，都可透過 rustup 直接 override 你的 default 設定，原本測試跑在穩定版 <code>cargo test</code> 你想要測試 nightly 版也只要 <code>cargo +nightly test</code> 就可以，神之方便。</p><p>我自己覺得 2020 年是 Rust 開發體驗大躍進的一年，整個開發阻力降低非常多，很適合入場。</p><h2 id=穩定性與-compatibility>穩定性與 Compatibility</h2><p>剩最後一點「穩定性與 Compatibility」我快速打完：</p><p>有人說 Rust 語言很新一直更版不穩定，事實上 Rust 非常嚴格遵守語義化版號 semver。從 2015 五月十五日 Rust 1.0 發佈到現在穩定版的 1.46，基本上沒有任何 breaking change。而且 Rust 版本發佈非常規率，嚴格的<a href=https://forge.rust-lang.org/#current-release-versions>六週發佈一個 minor version</a>，所以跟著官方就會一直升級上去不會有特別的問題。</p><p>Rust 團隊想要導入 breaking change 的時候怎麼辦，他們開發了一種叫做 edition 的機制，目前預計是每三年發佈一次（有點像 c++11 14 17？），這個 edition 可能會有很小的 breaking change，例如將 <code>async</code> 原本不是關鍵字改為關鍵字，這種情況下 Rust 官方為了不要真的引入 breaking change，用了幾個手法緩解：</p><ul><li>第一個就是 edition 是可以選擇的，如果你不想要升級到 2018 版本，那就留在 2015，所有東西都照常可以使用，只是 2018 一些新的語法糖就享受不到，但所有 compile 更新什麼的都會獲得，並不是 LTS 的概念。</li><li>第二個就是 Rust 團隊為了這個 edition 專門寫了一本 <a href=https://doc.rust-lang.org/edition-guide/>Edition Guide</a> 告訴你每個版本有什麼新功能，你需不需要，要怎麼改寫或不改寫。</li><li>第三個就是直接提供 codemod 工具 cargo fix subcommand，協助你 migrate 到新版本，但你留在 2015 版，你還是可以獲得幾乎所有編譯器的新 feature 和 bugfix，不會有任何問題和差異，就是寫法舊了點繞了點。</li></ul><p>Rust 團隊接下來可能會為了 compatibility 做的功夫是可以<a href=https://rust-lang.tw/rfcs-tw/2495-min-rust-version.html>在 <code>Cargo.toml</code> 指定最低支援的 Rust version</a>，這可以讓社群的函式庫作者或使用者都能明確得知他的 rustc 版本是否足夠支援使用該 library，作者也可以很放心的寫出什麼時候要 drop 哪一個版本的 rustc 支援，我個人非常其他這個功能實現，但應該要一段不少的時間。</p><p>大概以上，我還沒想到更多。</p></div><footer class=entry-footer><div class="container sep-before"><div class=tags><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2H12l8.59 8.59A2 2 0 0120.59 13.41z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=screen-reader-text>Tags: </span><a class=tag href=/tags/rust/>Rust</a></div></div><div style=text-align:center;padding-top:2em><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/><img src=https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png alt=cc-by-nc-sa-4></a></div></footer></article><nav class=entry-nav><div class=container><div class="prev-entry sep-before"><a href=/posts/2020/bloom-filter/><span aria-hidden=true><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="20" y1="12" x2="4" y2="12"/><polyline points="10 18 4 12 10 6"/></svg>Previous</span>
<span class=screen-reader-text>Previous post: </span>布隆過濾器 Bloom Filter</a></div></div></nav></main><footer id=footer class=footer><div class="container sep-before"><section class="widget widget-social_menu sep-after"><nav aria-label="Social Menu"><ul><li><a href=https://github.com/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Github account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li><a href=https://facebook.com/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Facebook account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M18 2h-3a5 5 0 00-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 011-1h3z"/></svg></a></li><li><a href=https://twitter.com/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Twitter account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><title>Twitter icon</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></li><li><a href=https://linkedin.com/in/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Linkedin account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></li><li><a href=https://t.me/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Telegram account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><title>Telegram icon</title><path d="M23.91 3.79 20.3 20.84c-.25 1.21-.98 1.5-2 .94l-5.5-4.07-2.66 2.57c-.3.3-.55.56-1.1.56-.72.0-.6-.27-.84-.95L6.3 13.7l-5.45-1.7c-1.18-.35-1.19-1.16.26-1.75l21.26-8.2c.97-.43 1.9.24 1.53 1.73z"/></svg></a></li></ul></nav></section><div class=copyright><p>&copy; 2017-2020 Weihang Lo</p></div></div></footer></div></div><script>window.__assets_js_src="/assets/js/"</script><script src=/assets/js/main.c3bcf2df.js></script><script src=/js/custom.js></script><link rel=stylesheet href=//unpkg.com/katex/dist/katex.min.css><script src=//unpkg.com/katex/dist/katex.min.js></script><script src=//unpkg.com/katex/dist/contrib/auto-render.min.js></script><script type=text/javascript>renderMathInElement(document.querySelector('.entry-content'),{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":false,"left":"$","right":"$"}]});</script></body></html>