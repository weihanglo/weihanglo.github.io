<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The missing parts in Cargo | Life is a refactoring process without tests</title>
<meta name=keywords content="Rust"><meta name=description content="When people discuss the merits of Rust, they often mention its strict ownership rules, excellent diagnostics, and impressive performance. Cargo and the crates.io ecosystem frequently receive praise as well. Initially, when I started learning Rust, I couldn&rsquo;t understand why Cargo was so highly loved. Having extensive experience with JavaScript, I was accustomed to convenient package managers and couldn&rsquo;t grasp the enthusiasm—wasn&rsquo;t such a tool a given for any serious programming language?"><meta name=author content><link rel=canonical href=https://weihanglo.tw/posts/2024/the-missing-parts-in-cargo/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://weihanglo.tw/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://weihanglo.tw/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://weihanglo.tw/favicon-32x32.png><link rel=apple-touch-icon href=https://weihanglo.tw/apple-touch-icon.png><link rel=mask-icon href=https://weihanglo.tw/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://weihanglo.tw/posts/2024/the-missing-parts-in-cargo/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:title" content="The missing parts in Cargo"><meta property="og:description" content="When people discuss the merits of Rust, they often mention its strict ownership rules, excellent diagnostics, and impressive performance. Cargo and the crates.io ecosystem frequently receive praise as well. Initially, when I started learning Rust, I couldn&rsquo;t understand why Cargo was so highly loved. Having extensive experience with JavaScript, I was accustomed to convenient package managers and couldn&rsquo;t grasp the enthusiasm—wasn&rsquo;t such a tool a given for any serious programming language?"><meta property="og:type" content="article"><meta property="og:url" content="https://weihanglo.tw/posts/2024/the-missing-parts-in-cargo/"><meta property="og:image" content="https://weihanglo.tw/posts/2024/the-missing-parts-in-cargo/cargo-ship-stagnate.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-13T17:00:00+00:00"><meta property="article:modified_time" content="2024-07-13T17:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://weihanglo.tw/posts/2024/the-missing-parts-in-cargo/cargo-ship-stagnate.png"><meta name=twitter:title content="The missing parts in Cargo"><meta name=twitter:description content="When people discuss the merits of Rust, they often mention its strict ownership rules, excellent diagnostics, and impressive performance. Cargo and the crates.io ecosystem frequently receive praise as well. Initially, when I started learning Rust, I couldn&rsquo;t understand why Cargo was so highly loved. Having extensive experience with JavaScript, I was accustomed to convenient package managers and couldn&rsquo;t grasp the enthusiasm—wasn&rsquo;t such a tool a given for any serious programming language?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://weihanglo.tw/posts/"},{"@type":"ListItem","position":2,"name":"The missing parts in Cargo","item":"https://weihanglo.tw/posts/2024/the-missing-parts-in-cargo/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The missing parts in Cargo","name":"The missing parts in Cargo","description":"When people discuss the merits of Rust, they often mention its strict ownership rules, excellent diagnostics, and impressive performance. Cargo and the crates.io ecosystem frequently receive praise as well. Initially, when I started learning Rust, I couldn\u0026rsquo;t understand why Cargo was so highly loved. Having extensive experience with JavaScript, I was accustomed to convenient package managers and couldn\u0026rsquo;t grasp the enthusiasm—wasn\u0026rsquo;t such a tool a given for any serious programming language?","keywords":["Rust"],"articleBody":"When people discuss the merits of Rust, they often mention its strict ownership rules, excellent diagnostics, and impressive performance. Cargo and the crates.io ecosystem frequently receive praise as well. Initially, when I started learning Rust, I couldn’t understand why Cargo was so highly loved. Having extensive experience with JavaScript, I was accustomed to convenient package managers and couldn’t grasp the enthusiasm—wasn’t such a tool a given for any serious programming language? Surprisingly, not every programming language boasts a robust toolchain. While scripting languages often excel in this area, solutions for system-level programming is nearly empty.\nA sweet meet in the universe Cargo is incredibly user-friendly for most individual developers because it JUST WORKS. You can create a new package with cargo new foo, add dependencies using cargo add, and build with the blazing-fast Rust tool using cargo build. Cool! Then, you cargo publish to crates.io and share your project on r/rust. This process mirrors npm in the JavaScript ecosystem—download, build, publish. It’s a seamless, one-stop shop without unnecessary boilerplate or system dependency hassles 1. For individual developers, it’s a blessed tool.\nWhen Rust grows beyond Cargo Although Cargo is an advanced package manager and build tool for pure Rust projects, it falls short for more complex, polyglot projects. Enterprise development environments often face resource constraints—no network access, limited access to pre-approved open-source projects, unusual linkage setups, outdated or customized C compiler toolchains, stringent security audits, and advanced but incompatible cache mechanisms.\nFrustration mounts when developers discover Cargo’s limitations for their projects. They either request specific features (sometimes broadly useful, sometimes not) or abandon Cargo altogether. This is disheartening, particularly as Cargo begins to lose users from some of the world’s largest companies 2.\nMost wanted features that never arrive Examining issues with most thumb-ups and most comments reveals the community’s needs. As of 2024-07-11, the rust-lang/cargo repository has 1,398 open issues—a manageable number, but nearly at its limit. Many issues appear to be duplicates with slight but essential differences, complicating the search for a general solution that covers various workflows.\nLet’s look at the features the community has longed for Cargo to support over the years:\nIt’s all about cache Cargo uses two major types of caches:\nGlobal Cache: This cache stores downloaded dependency sources (.crate tarballs and Git repositories) under the ~/.cargo directory. It never invalidates. Local Cache: This is a per-workspace-level cache for intermediate build artifacts (the target directory). This cache invalidates when a rebuild is needed. We will focus on this. Cargo relies heavily on file modification times (mtime) reported by the operating system to determine cache freshness. However, this rebuild detection method is notoriously unreliable. For example, the clock may go backward, or the system mtime may have low precision, such as on Docker or Apple’s HFS. Some developers have been exploring content-hash based solutions to address this issue, though the main challenge is performance. This could potentially be solved by reusing hashing results from rustc, but it requires significant investigation and cross-team communication.\nRust build times can be quite slow. To improve this, there is interest in reusing build artifacts between different projects for common crates like syn, serde, and rand. Although this seems logical, it is challenging. Cargo has a complex model for conditional compilation based on different compiler flags, Cargo features, and target platforms. The rebuild detection mechanism, known as the fingerprint, tracks these properties. If any of them changes, Cargo rebuilds. This means we need to track not only what to build but also how to build it. Without knowing “how,” it’s hard to provide a generalized fix for docker-cache layers.\nThus, simply reusing compiled artifact caches or sharing target-dirs is not very useful if we implement a basic cache-everything solution. We need a design that separates artifacts based on different combinations of flags, features, platforms, and configurations, providing an easy-to-use interface for users to define what to cache and how.\nIf your CI system generates a random path for each build, there’s another issue. The seemingly static download sources will affect cache freshness by changing the value of CARGO_HOME. This happens because the CARGO_HOME path is embedded in debug symbols.\nThe situation becomes even more complex when considering the non-determinism of build scripts and proc macros, but I will stop here for now.\nPhases of a cargo build Cargo wasn’t designed to be a complete “build system”. It was just a package manager that helps fetch dependencies from the internet, simply builds, and publishes them to crates.io. Okay, I guess I just stepped on a trap of defining what a build system should be. A build system, or build orchestrator, is software that generates a set of actions from user-provided build tasks. It can “optionally” execute these actions (Yes, so CMake is a build system in my mind).\nThe potential of offloading build executions to other tools is essential. It makes transparent how build tasks should be executed with desired inputs and outputs, bringing a more deterministic and analyzable build. By separating the execution phase from a build, Cargo could be able to tell why a crate is rebuilt, without actually rebuilding it. Also, clearly no need to guess the test executable name with jq and grep magics.\nTo push it further, a build task with well-defined input/output could open a door for different kinds of pre/post build processing. Hmm… I shouldn’t say pre/post processing. Tasks ought to be composable. Apart from the execution order, the interface of defining a build task should be pretty much the same, regardless of whether it is pre or post processing. Designing such an interface is unfortunately the most difficult part that slows down the design and development. For now, Cargo prefers TOML for build configuration. Its static property ensures Cargo only does things in a defined manner. When you are not on the happy path and need an escape hatch, Cargo provides a complete unsandboxed environment to do arbitrary things. Yes, that’s called “build scripts”.\nThese two approaches are at opposite ends of the spectrum. There is a huge gap in between that Cargo doesn’t even look into. Why? Because developers who look at it often end up inventing a programming language (e.g., Nickel, Nix, and Starlark). Should Cargo evolve toward that direction? I don’t know. There is a proposal for sandboxing build scripts, but it’s more like a patch for build scripts themselves, not a total solution for build task composability. Ed Page’s post last year also provides an overview and potential solutions for it. It’s short and worth a read.\nSpeaking of breaking a build into phases, Bazel and Buck2 are good examples. From my truly belief, by doing so, it also helps achieve distributed executions and remote caching for their use cases. It may not be a necessary feature for indie developers or small startups. Think about it: What if we solved the cache issue and someone just built a sharable cache service that benefits everyone’s CI pipeline?\nBuild script is not a C package manager Speaking of build scripts, they deserve credit for Rust’s growing popularity. As a tool for system-level programming, Cargo is praised for its simplicity — just cargo build and you’re set. Even if a package needs a missing C library, build.rs steps in to fetch and build it from source.\nBut convenience comes with trade-offs. A build script isn’t a proper C package manager. Its imperative, dynamic nature can make dependency management tricky. Take the “Cargo feature unification” issue: once a vendored feature is on in the dependency graph, you can’t turn it off. We could use a declarative approach like system-deps to handle this better. Yet, how do we model a powerful build system like CMake in TOML, a less flexible language? It all loops back to defining the interface of build tasks. Or maybe someone should create a C package manager that becomes mainstream, so Cargo can just call it?\nThe unconditional conditional compilation Alright, let’s dive into the less glamorous side.\nConditional compilation in Cargo revolves around “Cargo features”. These features can:\nToggle code blocks with corresponding --cfg flags for the compiler Activate optional dependencies Activate other features This seems more powerful than traditional C’s #ifdef, but actually not. To prevent excessive compilation overhead, the dependency resolver picks only one compatible version when a crate appears in the dependency graph multiple times, and each is within the SemVer-compatible versions defined. And because they are deemed compatible, Cargo gets one step further that unconditionally merges all activated features into a union of them. This is the “additive” property. You have no way to opt-out of this behavior. If you desperately need mutually exclusive features, you and downstream users of your crate likely hit the ground hard, as there is no simple way to support this (remember the vendored problem mentioned earlier). It will become a compatibility hazard if a crate doesn’t respect SemVer-compatibility and the additive nature of Cargo features.\nTo make the situation worse, developers want to activate dependencies based on feature activations, which may in turn activate more features. How long will it take for a feature unification to converge if that is allowed? I don’t really know. That said, it is a valid feature request. Just too hard to make the design right. The Cargo team has made several attempts to make feature resolution better, for example feature resolver v2. None of them is a clear win, as users need to know in which situations a feature resolution may be different. Those attempts even confuse maintainers of Cargo!\nA piece of good news is that RFC 3416 was merged, allowing future extensions of feature metadata like public/private or unstable features. It will make feature resolution smarter with the sacrifice of software complexity, from the perspective of both tool users and maintainers.\nFinger-crossed cross-compilation When it comes to cross-compilation, people often highlight its built-in support through Rustup and Cargo. While this is true, they didn’t tell you the full story.\nFirst of all, if you’re in a pure Rust world, you are the luckiest person in the world. No need to deal with different compiler flags and linkers. No need to configure target..rustflags and find the dual behavior between build scripts and normal dependencies. While target-applies-to-host is a solution to this, it never comes stabilized as it may break some subtle workflows around passing rustflags.\nBeyond flag configurations, it’s challenging to determine from Cargo.toml whether a package supports or requires building on certain platforms. While we have per-package-target, its semantics remain unclear, especially in relation to artifact dependencies and building the standard library (build-std). An even trickier part is the right timiing of filtering supported platforms. Should dependency resolution be aware of this? Should the lockfile track dependencies for supported platforms?\nAll of these questions above are not yet answered.\nIf all we have is a dependency resolver As a package manager, selecting the correct dependency versions is the primary goal of Cargo. Cargo has its own ad-hoc dependency resolution algorithm that only a few people understand. Cargo made conditional compilation part of the resolver, so it can pick the correct set of optional dependencies and features within a valid version range. It understands [patch] because the resolver needs to pretend a patched dependency is from the original source. It knows the preferred Rust toolchain version in mind so that it can perform an MSRV-aware resolution.\nWhile keeping in mind that Cargo’s resolver and the entire community follow SemVer strictly, there is still a huge desire for allowing multiple SemVer-compatible versions in a dependency graph. Different strategies have been proposed, such as resolving to minimal versions. Restrictions like disallowing duplicate native lib linkage in one graph are looking for a lift. Besides, there is a potential need for support in resolving platform-specific dependencies.\nEvery feature request seems minimal. However, every problem becomes a version-solving problem if all we have is a dependency resolver. And that exacerbates the hard-to-maintain situation worse. The resolver is not an LLM, but it is still a myth to some maintainers how it actually works.\nWe should be glad that one of the Cargo maintainers decided to stand out and pursue a goal to modularize Cargo’s ad-hoc resolver. To be more precise, it is letting the top-notch dependency resolver library pubgrub understand all shenanigans Cargo is doing right now. While this is a bold project, I am really looking forward to the outcome. You can track the progress by subscribing to this Zulip topic.\nStability with stagnation The stability guarantee of Cargo is both a blessing and a curse to the community. It’s a blessing that we don’t worry too much when running rustup update every six weeks. To make it worse, Cargo is one of the fastest-growing programming languages. Even an unstable nightly feature cannot be slightly removed due to the large adoption these days.\n“Stability without stagnation” is a principle Rust holds. This is the gist of the 6-weeks “release train” model. However, people are too creative to invent their own workflows to fix the inability of all the aforementioned missing features. Cargo is stuck in these implicit dependent relations, which makes maintainers3 stressed out and reluctant to take risks on new stuff. You can see how the discussion RFC 3537 went, regardless of the intention of it was finding a middle ground to improve the current situation.\nMaybe because of the stability guarantee, people put a much higher bar for new features to be “perfect” and satisfy everyone. There is a [summary of the docker cache problem] calling out:\nFor a feature to be stablized in cargo, it needs to fit into the cohesive whole, meaning it needs to work without a lot of caveats. It can’t be a second tier solution\nThere is a dream that Cargo has its own release cadence, so it is free from the strict guarantee of stability and can then ship major version releases.\nMaximize compatibility with minimal compatibility Well, it might be more than a dream to evolve Cargo without stagnation. A great example is cargo-nextest. As a non-official third-party Cargo plugin, cargo-nextest doesn’t need to hold the stability guarantee like other official Rust tools. Instead, it ships a performant test execution model that is deemed a breaking change if it were made to Cargo. It turns out that people love it and are willing to update their test code accordingly in exchange for test execution speed-up. Not to say that in most scenarios, cargo-nextest is just a drop-in replacement.\nIn the success story of cargo-nextest, its maintainers got a space to experiment on different design ideas, as well as gain some adoptions for feedback. Is it possible to achieve that for other parts of Cargo? To answer the question, first, we need to figure out the minimal set of functionalities Cargo must provide to be compatible with the crates.io ecosystem. Calling out being compatible with crates.io is because, to be honest, Cargo is nothing if there is no such ecosystem. If we want to see a wide adoption of our cargo-nextbuild, cargo-nextrun, or else, we would like to maximize compatibility with the crates.io ecosystem. You don’t ever want to recreate a whole new ecosystem for Rust, trust me.\nLet’s see what the minimal set of functionalities a Cargo-compatible tool needs to have to be free from stagnation.\nNote that a Cargo-compatible tool doesn’t necessarily need to be done from scratch. It can be a wrapper of Cargo or use cargo-the-library.\nMatching the result of dependency resolution In an ideal world, a published crate on crates.io is guaranteed to be buildable. Other developers can fetch its source and build it flawlessly. This guarantee is upheld with the Cargo ad-hoc dependency resolver, and their contract is written in the form of dependencies and features tables in Cargo.toml.\nIf we’re going to build a new dependency resolver, we don’t want to fall into a situation where the old resolver found a solution for a package, whereas the new resolver can’t. That makes the package unbuildable, hurting the compatibility.\nIt is acceptable that two dependency resolvers find different solutions, as long as those solutions are valid for both resolvers.\nIn summary, a Cargo-compatible tool must produce dependency resolution results that are valid in Cargo, and vice versa 4. This also includes correctly parsing dependency information5 from Cargo.toml and Cargo.lock.\nMatching the behavior of running build scripts In a Cargo package, every dependency is statically known, with one exception: Running build scripts. By the nature of build scripts being able to run arbitrary code, they are considered “dynamic dependencies”. Cargo doesn’t know what will be produced until a build script has run.\nCargo has a set of build script instructions that defines corresponding behavior before, during, and after running a build script. For example, a Cargo-compatible tool must not run if the path given by cargo::rerun-if-changed=PATH has no change. When a cargo::rustc-env=VAR=VALUE instruction is emitted, the env var must be set for the compiler invocation of the crate-being-built.\nThat is to say, a Cargo-compatible tool must exactly match the behavior of running build scripts, including:\nDetermine whether a rerun is needed. Correctly parse the emitted build script instructions. Configure the compiler invocation based on emitted instructions. Setting environment variables for crates This one is relatively straightforward. Cargo sets environment variables for compiler invocations and build script runs. These variables are either package metadata from Cargo.toml or necessary information helping build scripts do dirty jobs. The tricky part is that some variables are pretty Cargo-centric. For example, it’s odd that a non-Cargo tool setting a path to cargo because a crate requiring the CARGO environment variable to call cargo executable recursively. However, it doesn’t really make the situation worse, as build scripts are already able to do anything.\nClosing In this note, we reviewed the current state of Cargo. There are a bunch of feature requests never done. They stagnate because of the pursuit of perfection or fear of breaking unnoticed workflows. They often have a way too large design space with only a tiny place to experiment.\nWe then looked into a way to break the stagnation. Taking cargo-nextest as an example, we need to ensure a minimal compatible interface is implemented for a Cargo-compatible tool when experimenting with new ideas. Surprisingly, the minimal compatible layer is still of a reasonable size, though we might miss some important aspects that should be covered.\nSo, are we ready for a new adventure?\nThis is a success story for build scripts that they just vendor everything C dependencies, however, silently. It is ironically that it is now considered a failure because silent vendoring is not acceptable from several aspects. See system-deps#97. ↩︎\nApparently, Google and Meta don’t really use Cargo. Projects like Nix and Rust-for-Linux are willing to roll out their own build system for Rust. ↩︎\nAt least for me, I often feel incapable of merging a PR, even when it seemed completely harmless but actually broke 3rd-party plugin users. ↩︎\nThis is actually written in the 2024H2 Project Goals “Extend pubgrub to match cargo’s dependency resolution”. Thanks again to the owner of the goal! ↩︎\nThankfully, not all fields in Cargo.toml are needed for the minimal interface. In Cargo, the core fields are defined in [the Summary struct]. They construct necessary info for the resolver to work. ↩︎\n","wordCount":"3211","inLanguage":"en","image":"https://weihanglo.tw/posts/2024/the-missing-parts-in-cargo/cargo-ship-stagnate.png","datePublished":"2024-07-13T17:00:00Z","dateModified":"2024-07-13T17:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://weihanglo.tw/posts/2024/the-missing-parts-in-cargo/"},"publisher":{"@type":"Organization","name":"Life is a refactoring process without tests","logo":{"@type":"ImageObject","url":"https://weihanglo.tw/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://weihanglo.tw/ accesskey=h title="Life is a refactoring process without tests (Alt + H)">Life is a refactoring process without tests</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://weihanglo.tw/ title=Home><span>Home</span></a></li><li><a href=https://weihanglo.tw/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://weihanglo.tw/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://weihanglo.tw/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">The missing parts in Cargo</h1><div class=post-meta><span title='2024-07-13 17:00:00 +0000 UTC'>July 13, 2024</span>&nbsp;·&nbsp;16 min</div></header><figure class=entry-cover><img loading=eager src=https://weihanglo.tw/posts/2024/the-missing-parts-in-cargo/cargo-ship-stagnate.png alt="A cargo ship stagnated in March, 2021 (Julianne Cona / Instagram)"><p>A cargo ship stagnated in March, 2021 (Julianne Cona / Instagram)</p></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#a-sweet-meet-in-the-universe aria-label="A sweet meet in the universe">A sweet meet in the universe</a></li><li><a href=#when-rust-grows-beyond-cargo aria-label="When Rust grows beyond Cargo">When Rust grows beyond Cargo</a></li><li><a href=#most-wanted-features-that-never-arrive aria-label="Most wanted features that never arrive">Most wanted features that never arrive</a><ul><li><a href=#its-all-about-cache aria-label="It&rsquo;s all about cache">It&rsquo;s all about cache</a></li><li><a href=#phases-of-a-cargo-build aria-label="Phases of a cargo build">Phases of a cargo build</a></li><li><a href=#build-script-is-not-a-c-package-manager aria-label="Build script is not a C package manager">Build script is not a C package manager</a></li><li><a href=#the-unconditional-conditional-compilation aria-label="The unconditional conditional compilation">The unconditional conditional compilation</a></li><li><a href=#finger-crossed-cross-compilation aria-label="Finger-crossed cross-compilation">Finger-crossed cross-compilation</a></li><li><a href=#if-all-we-have-is-a-dependency-resolver aria-label="If all we have is a dependency resolver">If all we have is a dependency resolver</a></li></ul></li><li><a href=#stability-with-stagnation aria-label="Stability with stagnation">Stability with stagnation</a></li><li><a href=#maximize-compatibility-with-minimal-compatibility aria-label="Maximize compatibility with minimal compatibility">Maximize compatibility with minimal compatibility</a><ul><li><a href=#matching-the-result-of-dependency-resolution aria-label="Matching the result of dependency resolution">Matching the result of dependency resolution</a></li><li><a href=#matching-the-behavior-of-running-build-scripts aria-label="Matching the behavior of running build scripts">Matching the behavior of running build scripts</a></li><li><a href=#setting-environment-variables-for-crates aria-label="Setting environment variables for crates">Setting environment variables for crates</a></li></ul></li><li><a href=#closing aria-label=Closing>Closing</a></li></ul></div></details></div><div class=post-content><p>When people discuss the merits of Rust, they often mention its strict ownership rules, excellent diagnostics, and impressive performance. Cargo and the crates.io ecosystem frequently receive praise as well. Initially, when I started learning Rust, I couldn&rsquo;t understand why Cargo was so highly loved. Having extensive experience with JavaScript, I was accustomed to convenient package managers and couldn&rsquo;t grasp the enthusiasm—wasn&rsquo;t such a tool a given for any serious programming language? Surprisingly, not every programming language boasts a robust toolchain. While scripting languages often excel in this area, solutions for system-level programming is nearly empty.</p><h2 id=a-sweet-meet-in-the-universe>A sweet meet in the universe<a hidden class=anchor aria-hidden=true href=#a-sweet-meet-in-the-universe>#</a></h2><p>Cargo is incredibly user-friendly for most individual developers because it JUST WORKS. You can create a new package with <code>cargo new foo</code>, add dependencies using <code>cargo add</code>, and build with the blazing-fast Rust tool using <code>cargo build</code>. Cool! Then, you <code>cargo publish</code> to crates.io and share your project on <code>r/rust</code>. This process mirrors npm in the JavaScript ecosystem—download, build, publish. It’s a seamless, one-stop shop without unnecessary boilerplate or system dependency hassles <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. For individual developers, it’s a blessed tool.</p><h2 id=when-rust-grows-beyond-cargo>When Rust grows beyond Cargo<a hidden class=anchor aria-hidden=true href=#when-rust-grows-beyond-cargo>#</a></h2><p>Although Cargo is an advanced package manager and build tool for pure Rust projects, it falls short for more complex, polyglot projects. Enterprise development environments often face resource constraints—no network access, limited access to pre-approved open-source projects, unusual linkage setups, outdated or customized C compiler toolchains, stringent security audits, and advanced but incompatible cache mechanisms.</p><p>Frustration mounts when developers discover Cargo&rsquo;s limitations for their projects. They either request specific features (sometimes broadly useful, sometimes not) or abandon Cargo altogether. This is disheartening, particularly as Cargo begins to lose users from some of the world&rsquo;s largest companies <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><h2 id=most-wanted-features-that-never-arrive>Most wanted features that never arrive<a hidden class=anchor aria-hidden=true href=#most-wanted-features-that-never-arrive>#</a></h2><p>Examining issues with <a href="https://github.com/rust-lang/cargo/issues?q=is%3Aissue+is%3Aopen+sort%3Areactions-%2B1-desc">most thumb-ups</a> and <a href="https://github.com/rust-lang/cargo/issues?q=is%3Aissue+is%3Aopen+sort%3Acomments-desc">most comments</a> reveals the community&rsquo;s needs. As of 2024-07-11, the rust-lang/cargo repository has 1,398 open issues—a manageable number, but nearly at its limit. Many issues appear to be duplicates with slight but essential differences, complicating the search for a general solution that covers various workflows.</p><p>Let&rsquo;s look at the features the community has longed for Cargo to support over the years:</p><h3 id=its-all-about-cache>It&rsquo;s all about cache<a hidden class=anchor aria-hidden=true href=#its-all-about-cache>#</a></h3><p>Cargo uses two major types of caches:</p><ul><li><strong>Global Cache</strong>: This cache stores downloaded dependency sources (<code>.crate</code> tarballs and Git repositories) under the <code>~/.cargo</code> directory. It never invalidates.</li><li><strong>Local Cache</strong>: This is a per-workspace-level cache for intermediate build artifacts (the <code>target</code> directory). This cache invalidates when a rebuild is needed. We will focus on this.</li></ul><p>Cargo relies heavily on file modification times (mtime) reported by the operating system to determine cache freshness. However, this rebuild detection method is notoriously unreliable. For example, the clock may go backward, or the system mtime <a href=https://github.com/rust-lang/cargo/issues/12060>may have low precision</a>, such as on Docker or Apple&rsquo;s HFS. Some developers have been exploring <a href=https://github.com/rust-lang/cargo/issues/6529>content-hash based solutions</a> to address this issue, though the main challenge is performance. This could potentially be solved by <a href=https://rust-lang.zulipchat.com/#narrow/stream/246057-t-cargo/topic/Implementing.20checksum.20based.20fingerprinting/near/446199539>reusing hashing results from rustc</a>, but it requires significant investigation and cross-team communication.</p><p>Rust build times can be quite slow. To improve this, there is interest in reusing build artifacts between different projects for common crates like <code>syn</code>, <code>serde</code>, and <code>rand</code>. Although this seems logical, it is challenging. Cargo has a complex model for conditional compilation based on different <a href=https://github.com/rust-lang/cargo/issues/8716>compiler flags</a>, <a href=https://github.com/rust-lang/cargo/issues/4463>Cargo features</a>, and target platforms. The rebuild detection mechanism, known as the fingerprint, tracks <a href=https://doc.rust-lang.org/1.79.0/nightly-rustc/cargo/core/compiler/fingerprint/index.html#fingerprints-and-metadata>these properties</a>. If any of them changes, Cargo rebuilds. This means we need to track not only what to build but also how to build it. Without knowing &ldquo;how,&rdquo; it’s hard to provide a generalized fix for <a href=https://github.com/rust-lang/cargo/issues/2644>docker-cache layers</a>.</p><p>Thus, simply <a href=https://github.com/rust-lang/cargo/issues/5931>reusing compiled artifact caches</a> or <a href=https://github.com/rust-lang/cargo/issues/11156>sharing target-dirs</a> is not very useful if we implement a basic cache-everything solution. We need a design that separates artifacts based on different combinations of flags, features, platforms, and configurations, providing an easy-to-use interface for users to define what to cache and how.</p><p>If your CI system generates a random path for each build, there&rsquo;s another issue. The seemingly static download sources will affect cache freshness by <a href=https://github.com/rust-lang/cargo/issues/10915>changing the value of <code>CARGO_HOME</code></a>. This happens because the <code>CARGO_HOME</code> path is embedded in debug symbols.</p><p>The situation becomes even more complex when considering the non-determinism of build scripts and proc macros, but I will stop here for now.</p><h3 id=phases-of-a-cargo-build>Phases of a <code>cargo build</code><a hidden class=anchor aria-hidden=true href=#phases-of-a-cargo-build>#</a></h3><p>Cargo wasn&rsquo;t designed to be a complete &ldquo;build system&rdquo;. It was just a package manager that helps fetch dependencies from the internet, simply builds, and publishes them to crates.io. Okay, I guess I just stepped on a trap of defining what a build system should be. A build system, or build orchestrator, is software that generates a set of actions from user-provided build tasks. It can &ldquo;optionally&rdquo; execute these actions (Yes, so CMake is a build system in my mind).</p><p>The potential of offloading build executions to other tools is essential. It makes transparent how build tasks should be executed with desired inputs and outputs, bringing a more deterministic and analyzable build. By separating the execution phase from a build, Cargo could be able to tell <a href=https://github.com/rust-lang/cargo/issues/2904>why a crate is rebuilt</a>, without actually rebuilding it. Also, clearly no need to <a href=https://github.com/rust-lang/cargo/issues/1924>guess the test executable name</a> with <code>jq</code> and <code>grep</code> magics.</p><p>To push it further, a build task with well-defined input/output could open a door for different kinds of <a href=https://github.com/rust-lang/cargo/issues/7178>pre</a>/<a href=https://github.com/rust-lang/cargo/issues/545>post</a> build processing. Hmm&mldr; I shouldn&rsquo;t say pre/post processing. Tasks ought to be composable. Apart from the execution order, the interface of defining a build task should be pretty much the same, regardless of whether it is pre or post processing. Designing such an interface is unfortunately the most difficult part that slows down the design and development. For now, Cargo prefers TOML for build configuration. Its static property ensures Cargo only does things in a defined manner. When you are not on the happy path and need an escape hatch, Cargo provides a complete unsandboxed environment to do arbitrary things. Yes, that&rsquo;s called &ldquo;build scripts&rdquo;.</p><p>These two approaches are at opposite ends of the spectrum. There is a huge gap in between that Cargo doesn&rsquo;t even look into. Why? Because developers who look at it often end up inventing a programming language (e.g., <a href=https://nickel-lang.org/>Nickel</a>, <a href=https://nix.dev/manual/nix/2.23/language/>Nix</a>, and <a href=https://github.com/bazelbuild/starlark>Starlark</a>). Should Cargo evolve toward that direction? I don&rsquo;t know. There is a proposal for sandboxing build scripts, but it&rsquo;s more like a patch for build scripts themselves, not a total solution for build task composability. <a href=https://epage.github.io/blog/2023/08/are-we-gui-build-yet/>Ed Page&rsquo;s post</a> last year also provides an overview and potential solutions for it. It&rsquo;s short and worth a read.</p><p>Speaking of breaking a build into phases, <a href=https://bazel.build/extending/concepts#evaluation-model>Bazel</a> and <a href=https://buck2.build/docs/developers/architecture/buck2/>Buck2</a> are good examples. From my truly belief, by doing so, it also helps achieve distributed executions and remote caching for their use cases. It may not be a necessary feature for indie developers or small startups. Think about it: What if we solved <a href=#Its-all-about-cache>the cache issue</a> and someone just built a <a href=https://www.cachix.org/>sharable cache service</a> that benefits everyone&rsquo;s CI pipeline?</p><h3 id=build-script-is-not-a-c-package-manager>Build script is not a C package manager<a hidden class=anchor aria-hidden=true href=#build-script-is-not-a-c-package-manager>#</a></h3><p>Speaking of build scripts, they deserve credit for Rust&rsquo;s growing popularity. As a tool for system-level programming, Cargo is praised for its simplicity — just <code>cargo build</code> and you&rsquo;re set. Even if a package needs a missing C library, <code>build.rs</code> steps in to fetch and build it from source.</p><p>But convenience comes with trade-offs. A build script isn&rsquo;t a proper C package manager. Its imperative, dynamic nature can make dependency management tricky. Take the &ldquo;Cargo feature unification&rdquo; issue: once a <code>vendored</code> feature is on in the dependency graph, you can&rsquo;t turn it off. We could use a declarative approach like <a href=https://github.com/gdesmott/system-deps>system-deps</a> to handle this better. Yet, how do we model a powerful build system like CMake in TOML, a less flexible language? It all loops back to <a href=#Phases-of-a-cargo-build>defining the interface of build tasks</a>.
Or maybe someone should create a C package manager that becomes mainstream, so Cargo can just call it?</p><h3 id=the-unconditional-conditional-compilation>The unconditional conditional compilation<a hidden class=anchor aria-hidden=true href=#the-unconditional-conditional-compilation>#</a></h3><p>Alright, let&rsquo;s dive into the less glamorous side.</p><p>Conditional compilation in Cargo revolves around &ldquo;Cargo features&rdquo;. These features can:</p><ul><li>Toggle code blocks with corresponding <code>--cfg</code> flags for the compiler</li><li>Activate optional dependencies</li><li>Activate other features</li></ul><p>This seems more powerful than traditional C&rsquo;s <code>#ifdef</code>, but actually not. To prevent excessive compilation overhead, the dependency resolver picks only one compatible version when a crate appears in the dependency graph multiple times, and each is within the SemVer-compatible versions defined. And because they are deemed compatible, Cargo gets one step further that unconditionally merges all activated features into a union of them. This is the &ldquo;additive&rdquo; property. You have <a href=https://github.com/rust-lang/cargo/issues/3126>no way to opt-out of this behavior</a>. If you desperately need <a href=https://github.com/rust-lang/cargo/issues/2980>mutually exclusive features</a>, you and downstream users of your crate likely hit the ground hard, as there is no simple way to support this (remember the <code>vendored</code> problem mentioned earlier). It will become a compatibility hazard if a crate doesn&rsquo;t respect SemVer-compatibility and the additive nature of Cargo features.</p><p>To make the situation worse, developers want to <a href=https://github.com/rust-lang/cargo/issues/5954>activate dependencies based on feature activations</a>, which may in turn activate more features. How long will it take for a feature unification to converge if that is allowed? I don&rsquo;t really know. That said, it is a valid feature request. Just too hard to make the design right. The Cargo team has made several attempts to make feature resolution better, for example <a href=https://doc.rust-lang.org/cargo/reference/resolver.html#feature-resolver-version-2>feature resolver v2</a>. None of them is a clear win, as users need to know <a href=https://github.com/rust-lang/cargo/issues/10112>in which situations a feature resolution may be different</a>. Those attempts even <a href=https://rust-lang.zulipchat.com/#narrow/stream/246057-t-cargo/topic/Odd.20cargo.20resolver.20behavior>confuse maintainers of Cargo</a>!</p><p>A piece of good news is that <a href=https://rust-lang.github.io/rfcs/3416-feature-metadata.html>RFC 3416</a> was merged, allowing future extensions of feature metadata like public/private or unstable features. It will make feature resolution smarter with the sacrifice of software complexity, from the perspective of both tool users and maintainers.</p><h3 id=finger-crossed-cross-compilation>Finger-crossed cross-compilation<a hidden class=anchor aria-hidden=true href=#finger-crossed-cross-compilation>#</a></h3><p>When it comes to cross-compilation, people often highlight its built-in support through Rustup and Cargo. While this is true, they didn&rsquo;t tell you the full story.</p><p>First of all, if you&rsquo;re in a pure Rust world, you are the luckiest person in the world. No need to deal with different <a href=https://github.com/rust-lang/cargo/issues/4897>compiler flags</a> and <a href=https://github.com/rust-lang/cargo/issues/4133>linkers</a>. No need to configure <code>target.&lt;cfg>.rustflags</code> and find <a href=https://github.com/rust-lang/cargo/issues/9453>the dual behavior</a> between build scripts and normal dependencies. While <code>target-applies-to-host</code> is a solution to this, it never comes stabilized as it <a href=https://github.com/rust-lang/cargo/pull/10395#issuecomment-1051023136>may break some subtle workflows</a> around passing rustflags.</p><p>Beyond flag configurations, it&rsquo;s challenging to determine from <code>Cargo.toml</code> whether a package supports or <a href=https://github.com/rust-lang/cargo/issues/6179>requires building on certain platforms</a>. While we have <a href=https://github.com/rust-lang/cargo/issues/9406>per-package-target</a>, its semantics remain unclear, especially in relation to <a href=https://github.com/rust-lang/cargo/pull/9096>artifact dependencies</a> and <a href=https://github.com/rust-lang/wg-cargo-std-aware>building the standard library</a> (<code>build-std</code>). An even trickier part is the right timiing of filtering supported platforms. Should dependency resolution be aware of this? Should the lockfile track dependencies for supported platforms?</p><p>All of these questions above are not yet answered.</p><h3 id=if-all-we-have-is-a-dependency-resolver>If all we have is a dependency resolver<a hidden class=anchor aria-hidden=true href=#if-all-we-have-is-a-dependency-resolver>#</a></h3><p>As a package manager, selecting the correct dependency versions is the primary goal of Cargo. Cargo has its own ad-hoc dependency resolution algorithm that only a few people understand. Cargo made <a href=#The-unconditional-conditional-compilation>conditional compilation</a> part of the resolver, so it can pick the correct set of optional dependencies and features within a valid version range. It understands <code>[patch]</code> because <a href=https://github.com/rust-lang/cargo/blob/b60a1555155111e962018007a6d0ef85207db463/src/cargo/core/resolver/context.rs#L121-L135>the resolver needs to pretend a patched dependency is from the original source</a>. It knows the preferred Rust toolchain version in mind so that it can perform an <a href=https://github.com/rust-lang/cargo/issues/9930>MSRV-aware resolution</a>.</p><p>While keeping in mind that Cargo&rsquo;s resolver and the entire community follow SemVer strictly, there is still a huge desire for allowing <a href=https://github.com/rust-lang/cargo/issues/5640>multiple SemVer-compatible versions</a> in a dependency graph. Different strategies have been proposed, such as <a href=https://github.com/rust-lang/cargo/issues/5657>resolving to minimal versions</a>. Restrictions like <a href=https://github.com/rust-lang/cargo/issues/5237>disallowing duplicate native lib linkage in one graph</a> are looking for a lift. Besides, there is a potential need for support in resolving <a href=#Finger-crossed-cross-compilation>platform-specific</a> dependencies.</p><p>Every feature request seems minimal. However, every problem becomes a version-solving problem if all we have is a dependency resolver. And that exacerbates the hard-to-maintain situation worse. The resolver is not an LLM, but it is still a myth to some maintainers how it actually works.</p><p>We should be glad that one of the Cargo maintainers decided to stand out and pursue a goal to <a href=https://rust-lang.github.io/rust-project-goals/2024h2/pubgrub-in-cargo.html>modularize Cargo&rsquo;s ad-hoc resolver</a>. To be more precise, it is letting the top-notch dependency resolver library <code>pubgrub</code> understand all shenanigans Cargo is doing right now. While this is a bold project, I am really looking forward to the outcome. You can track the progress by subscribing to <a href=https://rust-lang.zulipchat.com/#narrow/stream/260232-t-cargo.2FPubGrub/topic/Progress.20report>this Zulip topic</a>.</p><h2 id=stability-with-stagnation>Stability with stagnation<a hidden class=anchor aria-hidden=true href=#stability-with-stagnation>#</a></h2><p>The stability guarantee of Cargo is both a blessing and a curse to the community. It&rsquo;s a blessing that we don&rsquo;t worry too much when running <code>rustup update</code> every six weeks. To make it worse, Cargo is one of the fastest-growing programming languages. Even <a href=https://github.com/rust-lang/cargo/issues/7614#issuecomment-1444692932>an unstable nightly feature cannot be slightly removed</a> due to the large adoption these days.</p><p><a href=https://doc.rust-lang.org/book/appendix-07-nightly-rust.html#stability-without-stagnation>&ldquo;Stability without stagnation&rdquo;</a> is a principle Rust holds. This is the gist of the 6-weeks &ldquo;release train&rdquo; model. However, people are too creative to invent their own workflows to fix the inability of all the aforementioned missing features. Cargo is stuck in these implicit dependent relations, which makes maintainers<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> stressed out and reluctant to take risks on new stuff. You can see how the discussion <a href=https://github.com/rust-lang/rfcs/pull/3537>RFC 3537</a> went, regardless of the intention of it was finding a middle ground to improve the current situation.</p><p>Maybe because of the stability guarantee, people put a much higher bar for new features to be &ldquo;perfect&rdquo; and satisfy everyone. There is a [summary of the docker cache problem] calling out:</p><blockquote><p>For a feature to be stablized in cargo, it needs to fit into the cohesive whole, meaning it needs to work without a lot of caveats. <em>It can&rsquo;t be a second tier solution</em></p></blockquote><p>There is a dream that Cargo has its own release cadence, so it is free from the strict guarantee of stability and can then ship major version releases.</p><h2 id=maximize-compatibility-with-minimal-compatibility>Maximize compatibility with minimal compatibility<a hidden class=anchor aria-hidden=true href=#maximize-compatibility-with-minimal-compatibility>#</a></h2><p>Well, it might be more than a dream to evolve Cargo without stagnation. A great example is <a href=https://nexte.st/><code>cargo-nextest</code></a>. As a non-official third-party Cargo plugin, <code>cargo-nextest</code> doesn&rsquo;t need to hold the stability guarantee like other official Rust tools. Instead, it ships a performant test execution model that is <a href=https://github.com/rust-lang/cargo/issues/5609>deemed a breaking change</a> if it were made to Cargo. It turns out that people love it and are willing to update their test code accordingly in exchange for test execution speed-up. Not to say that in most scenarios, <code>cargo-nextest</code> is just a drop-in replacement.</p><p>In the success story of <code>cargo-nextest</code>, its maintainers got a space to experiment on different design ideas, as well as gain some adoptions for feedback. Is it possible to achieve that for other parts of Cargo? To answer the question, first, we need to figure out the minimal set of functionalities Cargo must provide to be compatible with the crates.io ecosystem. Calling out being compatible with crates.io is because, to be honest, Cargo is nothing if there is no such ecosystem. If we want to see a wide adoption of our <code>cargo-nextbuild</code>, <code>cargo-nextrun</code>, or else, we would like to maximize compatibility with the crates.io ecosystem. You don&rsquo;t ever want to recreate a whole new ecosystem for Rust, trust me.</p><p>Let&rsquo;s see what the minimal set of functionalities a Cargo-compatible tool needs to have to be free from stagnation.</p><blockquote><p>Note that a Cargo-compatible tool doesn&rsquo;t necessarily need to be done from scratch. It can be a wrapper of Cargo or use cargo-the-library.</p></blockquote><h3 id=matching-the-result-of-dependency-resolution>Matching the result of dependency resolution<a hidden class=anchor aria-hidden=true href=#matching-the-result-of-dependency-resolution>#</a></h3><p>In an ideal world, a published crate on crates.io is guaranteed to be buildable. Other developers can fetch its source and build it flawlessly. This guarantee is upheld with the Cargo ad-hoc dependency resolver, and their contract is written in the form of <code>dependencies</code> and <code>features</code> tables in <code>Cargo.toml</code>.</p><p>If we&rsquo;re going to build a new dependency resolver, we don&rsquo;t want to fall into a situation where the old resolver found a solution for a package, whereas the new resolver can&rsquo;t. That makes the package unbuildable, hurting the compatibility.</p><p>It is acceptable that two dependency resolvers find different solutions, as long as those solutions are valid for both resolvers.</p><p>In summary, a Cargo-compatible tool must produce dependency resolution results that are valid in Cargo, and vice versa <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>. This also includes correctly parsing dependency information<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> from <code>Cargo.toml</code> and <code>Cargo.lock</code>.</p><h3 id=matching-the-behavior-of-running-build-scripts>Matching the behavior of running build scripts<a hidden class=anchor aria-hidden=true href=#matching-the-behavior-of-running-build-scripts>#</a></h3><p>In a Cargo package, every dependency is statically known, with one exception: Running build scripts. By the nature of build scripts being able to run arbitrary code, they are considered &ldquo;dynamic dependencies&rdquo;. Cargo doesn&rsquo;t know what will be produced until a build script has run.</p><p>Cargo has a set of <a href=https://doc.rust-lang.org/nightly/cargo/reference/build-scripts.html>build script instructions</a> that defines corresponding behavior before, during, and after running a build script. For example, a Cargo-compatible tool must not run if the path given by <code>cargo::rerun-if-changed=PATH</code> has no change. When a <code>cargo::rustc-env=VAR=VALUE</code> instruction is emitted, the env var must be set for the compiler invocation of the crate-being-built.</p><p>That is to say, a Cargo-compatible tool must exactly match the behavior of running build scripts, including:</p><ul><li>Determine whether a rerun is needed.</li><li>Correctly parse the emitted build script instructions.</li><li>Configure the compiler invocation based on emitted instructions.</li></ul><h3 id=setting-environment-variables-for-crates>Setting environment variables for crates<a hidden class=anchor aria-hidden=true href=#setting-environment-variables-for-crates>#</a></h3><p>This one is relatively straightforward. Cargo <a href=https://doc.rust-lang.org/nightly/cargo/reference/environment-variables.html>sets environment variables for compiler invocations and build script runs</a>. These variables are either package metadata from <code>Cargo.toml</code> or necessary information helping build scripts do dirty jobs. The tricky part is that some variables are pretty Cargo-centric. For example, it&rsquo;s odd that a non-Cargo tool setting a path to cargo because a crate requiring the <code>CARGO</code> environment variable to call <code>cargo</code> executable recursively. However, it doesn&rsquo;t really make the situation worse, as build scripts are already able to do anything.</p><h2 id=closing>Closing<a hidden class=anchor aria-hidden=true href=#closing>#</a></h2><p>In this note, we reviewed the current state of Cargo. There are a bunch of feature requests never done. They stagnate because of the pursuit of perfection or fear of breaking unnoticed workflows. They often have a way too large design space with only a tiny place to experiment.</p><p>We then looked into a way to break the stagnation. Taking <code>cargo-nextest</code> as an example, we need to ensure a minimal compatible interface is implemented for a Cargo-compatible tool when experimenting with new ideas. Surprisingly, the minimal compatible layer is still of a reasonable size, though we might miss some important aspects that should be covered.</p><p>So, are we ready for a new adventure?</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>This is a success story for build scripts that they just vendor everything C dependencies, however, silently. It is ironically that it is now considered a failure because silent vendoring is not acceptable from several aspects. See <a href=https://github.com/gdesmott/system-deps/issues/97>system-deps#97</a>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Apparently, Google and Meta don&rsquo;t really use Cargo. Projects like Nix and Rust-for-Linux are willing to roll out their own build system for Rust.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>At least for me, I often feel incapable of merging a PR, even when it seemed completely harmless but actually <a href=https://github.com/rust-lang/cargo/issues/11487>broke 3rd-party plugin users</a>.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>This is actually written in the 2024H2 Project Goals <a href=https://rust-lang.github.io/rust-project-goals/2024h2/pubgrub-in-cargo.html#milestones>&ldquo;Extend pubgrub to match cargo&rsquo;s dependency resolution&rdquo;</a>. Thanks again to the owner of the goal!&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>Thankfully, not all fields in <code>Cargo.toml</code> are needed for the minimal interface. In Cargo, the core fields are defined in [the <code>Summary</code> struct]. They construct necessary info for the resolver to work.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://weihanglo.tw/tags/rust/>Rust</a></li></ul><nav class=paginav><a class=next href=https://weihanglo.tw/posts/2023/become-a-real-londoner/><span class=title>Next »</span><br><span>如何成為正港倫敦人</span></a></nav></footer></article></main><footer class=footer><span>CC BY-NC-SA 4.0</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>