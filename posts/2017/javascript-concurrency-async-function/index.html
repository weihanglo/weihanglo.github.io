<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="在前一篇介紹 JavaScript Concurrency 的文章中，Promise 提供開發者安全統一的標準 API，透過 thenable 減少 callback hell，巨幅降低開發非同步程式的門檻，大大提升可維護性。不過，Promise 仍沒達到 JS 社群的目標「Write async code synchronously」。本篇文章將簡單最新的 Concurrency Solution「Async Functions」，利用同步的語法寫非同步的程式，整個人都變潮了呢！
（撰於 2017-06-17，基於 ECMAScript 7+）
Introduction Async Functions 在去年進入 Stage 4，正式成為 ECMAScript 7 標準，這對 JS 社群無疑是一大利多。截至目前為止（2017.6），實作 Async Functions 的環境有：
 Node.js 7.6.0 (without --harmony) Chrome 55 Firefox 52 Safari 10.1 Edge 15  可以看到當前 Release 版的 Desktop browser 都可以用了。
從此我們不會在 callback hell 中迷失自我，不需在 then 中塞一堆 console.log，也不需使用蹩足的 generator 語法。ES7 的 async function 完成我們對非同步程式的想像。"><meta name=theme-color content="#ffcd00"><meta property="og:title" content="現代化的 JavaScript 併發 - Async Functions • Weihang Lo"><meta property="og:description" content="在前一篇介紹 JavaScript Concurrency 的文章中，Promise 提供開發者安全統一的標準 API，透過 thenable 減少 callback hell，巨幅降低開發非同步程式的門檻，大大提升可維護性。不過，Promise 仍沒達到 JS 社群的目標「Write async code synchronously」。本篇文章將簡單最新的 Concurrency Solution「Async Functions」，利用同步的語法寫非同步的程式，整個人都變潮了呢！
（撰於 2017-06-17，基於 ECMAScript 7+）
Introduction Async Functions 在去年進入 Stage 4，正式成為 ECMAScript 7 標準，這對 JS 社群無疑是一大利多。截至目前為止（2017.6），實作 Async Functions 的環境有：
 Node.js 7.6.0 (without --harmony) Chrome 55 Firefox 52 Safari 10.1 Edge 15  可以看到當前 Release 版的 Desktop browser 都可以用了。
從此我們不會在 callback hell 中迷失自我，不需在 then 中塞一堆 console.log，也不需使用蹩足的 generator 語法。ES7 的 async function 完成我們對非同步程式的想像。"><meta property="og:url" content="https://weihanglo.tw/posts/2017/javascript-concurrency-async-function/"><meta property="og:site_name" content="Weihang Lo"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:tag" content="JavaScript"><meta property="article:tag" content="Concurrency"><meta property="article:tag" content="Async Function"><meta property="article:tag" content="Generator"><meta property="article:tag" content="Front-end"><meta property="article:published_time" content="2017-06-18T12:45:34+08:00"><meta property="article:modified_time" content="2017-06-18T12:45:34+08:00"><meta name=twitter:card content="summary"><meta name=generator content="Hugo 0.74.3"><title>現代化的 JavaScript 併發 - Async Functions • Weihang Lo</title><link rel=canonical href=https://weihanglo.tw/posts/2017/javascript-concurrency-async-function/><link rel=icon href=/favicon.ico><link rel=stylesheet href=/assets/css/main.ab98e12b.css><link rel=stylesheet href=/css/custom.css><style>:root{--color-accent:#ffcd00}</style></head><body class="page type-posts"><div class=site><a class=screen-reader-text href=#content>Skip to Content</a><div class=main><nav id=main-menu class="menu main-menu" aria-label="Main Menu"><div class=container><ul><li class=item><a href=/>Home</a></li><li class=item><a href=/posts/>Posts</a></li><li class=item><a href=/tags/>Tags</a></li><li class=item><a href=/about/>About</a></li></ul></div></nav><div class=header-widgets><div class=container></div></div><header id=header class="header site-header"><div class="container sep-after"><div class=header-info><p class="site-title title">Weihang Lo</p><p class="desc site-desc"></p></div></div></header><main id=content><article lang=en class=entry><header class="header entry-header"><div class="container sep-after"><div class=header-info><h1 class=title>現代化的 JavaScript 併發 - Async Functions</h1></div><div class=entry-meta><span class=posted-on><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg><span class=screen-reader-text>Posted on</span>
<time class=entry-date datetime=2017-06-18T12:45:34+08:00>2017, Jun 18</time></span>
<span class=reading-time><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 15 15"/></svg>8 mins read</span></div></div></header><div class="container entry-content"><p>在前一篇介紹 <a href=https://weihanglo.github.io/posts/2017/javascript-concurrency-promise/>JavaScript Concurrency 的文章</a>中，Promise 提供開發者安全統一的標準 API，透過 <code>thenable</code> 減少 callback hell，巨幅降低開發非同步程式的門檻，大大提升可維護性。不過，Promise 仍沒達到 JS 社群的目標「Write async code synchronously」。本篇文章將簡單最新的 Concurrency Solution「Async Functions」，利用同步的語法寫非同步的程式，整個人都變潮了呢！</p><p><em>（撰於 2017-06-17，基於 ECMAScript 7+）</em></p><h2 id=introduction>Introduction</h2><p><a href=https://tc39.github.io/ecmascript-asyncawait/>Async Functions</a> 在去年進入 Stage 4，正式成為 ECMAScript 7 標準，這對 JS 社群無疑是一大利多。截至目前為止（2017.6），實作 Async Functions 的環境有：</p><ul><li>Node.js 7.6.0 (without <code>--harmony</code>)</li><li>Chrome 55</li><li>Firefox 52</li><li>Safari 10.1</li><li>Edge 15</li></ul><p>可以看到<a href="https://caniuse.com/#search=async%20functions">當前 Release 版的 Desktop browser 都可以用了</a>。</p><p>從此我們不會在 callback hell 中迷失自我，不需在 <code>then</code> 中塞一堆 <code>console.log</code>，也不需使用蹩足的 generator 語法。ES7 的 <code>async function</code> 完成我們對非同步程式的想像。</p><p><strong>真的有這麼好康嗎？</strong></p><p><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function>MDN</a> 點出 async function 的定位。</p><blockquote><p>The purpose of async/await functions is to simplify the behavior of using promises synchronously and to perform some behavior on a group of Promises. Just like Promises are similar to structured callbacks, async/await is similar to combining generators and promises.</p></blockquote><p>Async functions 的目的在於簡化多個 promise 操作，不需要再串聯一堆 <code>then</code>。如果我們將 Promises 比喻為好讀版的 callbacks，那 async／await 就是 generator + promise 的綜合體，因此，<strong>我們仍需學習 promise 以及 generator 等概念</strong>。</p><p>話不多說，一起快速了解 generator 吧！</p><h2 id=generator-with-async-operations>Generator With Async Operations</h2><p>在 async／await 還沒出世之前，generator function 是非同步程式設計的最新潮的替代品，TJ 的 <a href=https://github.com/tj/co>co</a> 與 Facebook 的 <a href=https://github.com/facebook/regenerator>regenerator</a> 這兩個 libraries 都擁有高人氣。藉由 <a href=https://en.wikipedia.org/wiki/Coroutine>Coroutine（協程）</a> suspend／resume 的機制，讓開發非同步 JS 可以避開多線程煩人的 context-switch、dead lock，能用很直觀的方式撰寫程式。當然，coroutine 仍是在同個 thread 上面執行，並非真實的 parallel computing，不過 browser 這種常出現 I／O 的場景中，coroutine 已綽綽有餘了。</p><p><strong>我只是想了解 async function 怎麼用，為什麼還要學 coroutine 和 generator？不會太複雜嗎？</strong></p><p>別緊張，接下來將淺淺帶過 generator 概念。本人同樣不喜歡 generator 醜陋的 <code>*</code>，<code>*</code> 只該留給最愛的 pointer。介紹 generator 之前，先來了解 ES6 的 <strong>Iterable</strong> 與 <strong>Iterator</strong> 吧 XD！（不是說好快速瞭解 generator 嗎⋯⋯）</p><h3 id=iterable--iterator>Iterable & Iterator</h3><p>ES6 除了引入標準的 <code>Promise</code> object 以外，另一重大的語法變革就是 <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator>Iterator</a> 與 <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator>Generator</a>。熟悉 C++、Swift、Java 或 Python 3 的朋友應該非常熟悉 iterable／iterator 等名詞。在 JavaScript中，名詞解釋大致如下：</p><ul><li><strong>iterable</strong> 是指可迭代的物件，也就是可丟進 loop 運作的物件，會產生 <strong>iterator</strong>，但不一定是 <a href=https://en.wikipedia.org/wiki/Sequence>sequence</a> 或 <a href=https://en.wikipedia.org/wiki/Container_(abstract_data_type)>container</a>。</li><li><strong>iterator</strong> 就是鼎鼎大名的迭代器，如同指針般迭代東西（通常是 <strong>iterable</strong> 提供的值）。</li></ul><p>日常會遇到的 iterable 應該會長這樣：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>obj</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>iterable</span>) {}
<span style=color:#a6e22e>iterable</span>.<span style=color:#a6e22e>forEach</span>()
<span style=color:#a6e22e>iterable</span>.<span style=color:#a6e22e>map</span>()
</code></pre></div><p>這些 <strong>iterable</strong> 有共通特性，就像下面的 list 一樣又臭又長。</p><ul><li>有一個 <code>[Symbol.iterator]</code> method，<ul><li><code>[Symbol.iterator]</code> 會回傳一個 <strong>iterator</strong> object，<ul><li><strong>iterator</strong> 上要有 <code>next</code> method，<ul><li><code>next</code> method 會回傳一個 object 記錄 iteration 當前狀態，其有兩個 property，<ul><li><code>done</code>：當次 iteration 是否結束的 boolean flag</li><li><code>value</code>：當次 iteration 的 return value</li></ul></li></ul></li></ul></li></ul></li></ul><p>看了這種 nested list，是不是眼睛都茫了，想立馬關掉這篇廢文呢？別怕，常用的 <code>Array</code> 和 ES6 的 <code>Map</code>、<code>Set</code> 等都是內建的 iterable，我們不需自己辛苦實作；而 plain <code>Object</code> 雖非 iterable，但也有 <code>Object.entries</code> 等方法供我們轉換成 iterable 呢。</p><p>我們來看一個簡單 Iterator 實作：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>infiniteLoop</span> <span style=color:#f92672>=</span> {}
<span style=color:#a6e22e>infiniteLoop</span>[<span style=color:#a6e22e>Symbol</span>.<span style=color:#a6e22e>iterator</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> () { <span style=color:#75715e>// 實作 iterator 建構 funtion
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
  <span style=color:#66d9ef>return</span> { <span style=color:#75715e>// 回傳有 `next` method 的 object
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>next</span><span style=color:#f92672>:</span> () =&gt; ({ <span style=color:#75715e>// 回傳記錄當前 iteration state 的 object
</span><span style=color:#75715e></span>      <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#f92672>++</span><span style=color:#a6e22e>v</span>,
      <span style=color:#a6e22e>done</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>
    })
  }
}

<span style=color:#75715e>// 無限迴圈
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>v</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>infiniteLoop</span>) {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>v</span>)
}
</code></pre></div><blockquote><p>有興趣了解相關 protocols，可以<a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator>看此</a>。</p></blockquote><h3 id=generator>Generator</h3><p>上一節最後，我們從頭打造了一個 Iterator，看起來十分不易，其實 iterator 實作繁瑣，是每種語言皆然，<a href=https://stackoverflow.com/a/7542261>連 Python 3 也不例外</a>，於是，<strong>generator</strong> 就誕生了。 Generator 基於 iterator 概念之上，利用<del>簡單明瞭</del>的語法，讓建構 iterator 不必這麼痛苦。我們將前一節的例子改成 generator 試試看。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>function</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>genFunc</span> () { <span style=color:#75715e>// `*` 宣告一個 generator function，即是 iterator factory
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
  <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
    <span style=color:#66d9ef>yield</span> <span style=color:#f92672>++</span><span style=color:#a6e22e>v</span> <span style=color:#75715e>// generator function 的 body 內才能使用 `yield` keyword
</span><span style=color:#75715e></span>  }
}

<span style=color:#75715e>// 無限迴圈
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>g</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>genFunc</span>() <span style=color:#75715e>// 產生一個 iterator
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>next</span>() <span style=color:#75715e>// 取得 iterator 下一個 state
</span><span style=color:#75715e></span><span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>done</span>) {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>value</span>)
  <span style=color:#a6e22e>v</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>next</span>()
}
</code></pre></div><p>乍看之下，似乎沒比 iterator 簡單，而且又多了 <code>function*</code> 和 <code>yield</code>，是要嚇死人嗎？這裡的重點並非語法，而是一開始提及的 <a href=https://en.wikipedia.org/wiki/Coroutine>Coroutine</a>概念。這種 coroutine 的概念與一般逐行執行的程式不同，運作流程如下：</p><ol><li>執行到 <code>yield</code>，暫停。</li><li>將執行權交給外部，等待外部 call <code>next</code>。</li><li>外部 call <code>next</code>，回到步驟一繼續執行。</li></ol><p>套在我們的例子中，就是：</p><ul><li>當每次 <code>genFunc</code> 執行到 <code>yield</code> 時，會停下來，</li><li>將程式執行權交給外部 caller，</li><li>等到外部調用者再次 call <code>next</code> method，<code>genFunc</code> 再接著執行。</li></ul><p>簡而言之，<strong>「Generator 是 coroutine 的一種形式，是一個 pause／resume 的執行流程」</strong>。但這樣到底與非同步程式設計有啥鬼關係？</p><p>重點在於「透過 coroutine 將程式執行權交給外部 caller」，這可好玩了，如果我們讓 <code>yield</code> 返回一個 promise，程式執行權就會回到 caller 上，而 caller 不僅有程式執行權，可以執行其他程式片段，也可以取得非同步操作的結果。想像中的程式碼長這樣：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 想像中的程式碼
</span><span style=color:#75715e>// fetch 是一個 promise-based 非同步 function
</span><span style=color:#75715e></span><span style=color:#66d9ef>function</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>asyncFunc</span> () {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>yield</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;a&#39;</span>)
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>a</span>)
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>yield</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;b&#39;</span>)
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>b</span>)
}
</code></pre></div><p>看起來非常驚人！可惜這是虛擬的程式碼，<code>a</code>、<code>b</code> 都是一個 Promise，需要利用 <code>then</code> method 取得 resolve value。不過，JS 社群當然不會放過 generator 這個裝逼的好工具，大神們透過各種奇淫巧技，讓我得以利用 generator 優美地寫出 synchronously asynchronous code，以下這個例子便是透過 <code>spawn</code> 自動執行 <code>next</code> 的 helper function 達成。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// Helper Function
</span><span style=color:#75715e>// from: Jake Archibald - JavaScript Promises: an Introduction
</span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>spawn</span> (<span style=color:#a6e22e>generatorFunc</span>) {
  <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>continuer</span> (<span style=color:#a6e22e>verb</span>, <span style=color:#a6e22e>arg</span>) {
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>result</span>
    <span style=color:#66d9ef>try</span> {
      <span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>generator</span>[<span style=color:#a6e22e>verb</span>](<span style=color:#a6e22e>arg</span>)
    } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>err</span>) {
      <span style=color:#66d9ef>return</span> Promise.<span style=color:#a6e22e>reject</span>(<span style=color:#a6e22e>err</span>)
    }
    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>done</span>) {
      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>value</span>
    }
    <span style=color:#66d9ef>return</span> Promise.<span style=color:#a6e22e>resolve</span>(<span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>value</span>).<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>onFulfilled</span>, <span style=color:#a6e22e>onRejected</span>)
  }
  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>generator</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>generatorFunc</span>()
  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>onFulfilled</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>continuer</span>.<span style=color:#a6e22e>bind</span>(<span style=color:#a6e22e>continuer</span>, <span style=color:#e6db74>&#39;next&#39;</span>)
  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>onRejected</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>continuer</span>.<span style=color:#a6e22e>bind</span>(<span style=color:#a6e22e>continuer</span>, <span style=color:#e6db74>&#39;throw&#39;</span>)
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>onFulfilled</span>()
}

<span style=color:#75715e>// 利用 spawn 包裹，自動執行 generator function
</span><span style=color:#75715e>// 這是一個 sequential(serial) operation
</span><span style=color:#75715e></span><span style=color:#a6e22e>spawn</span>(<span style=color:#66d9ef>function</span><span style=color:#f92672>*</span> () {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>yield</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;a&#39;</span>) <span style=color:#75715e>// 等待 fetch(&#39;a&#39;)，並將結果 assign to a
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>a</span>) <span style=color:#75715e>// a 是一個
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>yield</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;b&#39;</span>) <span style=color:#75715e>// 等待 fetch(&#39;b&#39;)，並將結果 assign to b
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>b</span>)
})
</code></pre></div><p>這就是 async generator 的實作，很美，但過程十分嚇人。</p><blockquote><p>Note：Coroutine（協程）比較明確的定義是，指執行權從一個 coroutine 交至另外一個 coroutine，不過概念上類似，這裡借用一下，特此說明。</p></blockquote><h2 id=debut-of-async-functions>Debut of Async Functions</h2><p>使用上面這些燒腦的東西，雖達成任務，不過太疊床架屋，抽象概念難以消化。這時候就該主角 <strong>Async Function</strong> 登場！可以將 async functions 想像為 generator + promise，不過更直接的講法是：<strong>「Async Function 是內置 <code>spawn</code> 的 generator function」</strong>。</p><p>接下來，將前面使用 <code>spawn</code> 執行的 generator function 改寫成 async function。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 利用 `async` keyword 宣告 一個 async function
</span><span style=color:#75715e></span><span style=color:#a6e22e>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>run</span> () {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;a&#39;</span>) <span style=color:#75715e>// 使用 `await` 等待 fetch(&#39;a&#39;)，並將結果 assign to a
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>a</span>)
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;b&#39;</span>) <span style=color:#75715e>// 使用 `await` 等待 fetch(&#39;b&#39;)，並將結果 assign to b
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>b</span>)
}

<span style=color:#75715e>// 執行 async function，不需自己寫 `spawn`，如同正常的 function call。
</span><span style=color:#75715e></span><span style=color:#a6e22e>run</span>()
</code></pre></div><p>Async functions 使用語意清楚的 <code>async</code>／<code>await</code> 取代 <code>function*</code>／<code>yield</code>，除此之外，幾乎與 generator 版本一模一樣。其差異如下：</p><ul><li>不需額外的 helper function 來執行，一般的 function call 即可。</li><li>回傳值為 promise。（相比於 generator 回傳 iterator，async function 復用／組合性較高）</li></ul><h3 id=usage>Usage</h3><p>使用方法如下，非常簡單：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>myAsyncFunc</span> () {
  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>result</span>
  <span style=color:#66d9ef>try</span> { <span style=color:#75715e>// 慣例使用 try-catch 處理錯誤
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>fetchA</span>() <span style=color:#75715e>// async operation
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>fetchB</span>() <span style=color:#75715e>// async operation
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> {<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>}
  } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>e</span>) {
    <span style=color:#75715e>// 將 error 吃掉
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`Error occurred: </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>e</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>)
  }
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>result</span>
}
</code></pre></div><h3 id=await>Await</h3><p><code>await</code> 是用來等待 Promise resolution 的運算子，語法與特性如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript>[<span style=color:#a6e22e>rv</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>expression</span>
<span style=color:#75715e>// rv -&gt; return value of await expression
</span></code></pre></div><ul><li>僅能用在 async function 內部。</li><li>expression 若是 promise 以外的 value，直接返回該 value</li><li>expression 若接 promise object，則等待該 promise resolution。<ul><li>若 promise fulfilled，直接返回該 value。</li><li>若 promise rejected，拋出 Error 到 async function context 中（不被 promise 本身吃掉）。</li></ul></li></ul><p>這裡要注意的是，<code>await</code> 會等待 promise resolution 後才 return value，所以行為與 synchronous code 一致。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// async arrow function
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fun</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>async</span> () =&gt; {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> Promise.<span style=color:#a6e22e>resolve</span>()
  <span style=color:#75715e>// 等待 a 處理完畢，再往下執行
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>process</span>()
  <span style=color:#75715e>// 等待 b 處理完畢，再往下執行
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>process</span>()
  <span style=color:#75715e>// 返回最終的結果 c
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>
}
</code></pre></div><h3 id=return-value>Return Value</h3><p>我們知道，Async function 的 return value 會是一個 promise，那這個 promise 什麼時候會 fulfill，什麼時候會被 reject 呢？</p><p>情況其實不複雜，整理如下：</p><ol><li><code>return</code> 語句會使 async function 直接 resolve，不再往下執行。</li></ol><ul><li>若 <code>return</code> 一個 promise，則以該 promise 為 return value。</li><li>若 <code>return</code> 一個非 promise 的 value，則以 <code>Promise.resolve</code> 包裹該 value。</li></ul><ol start=2><li>function context 內部拋出任何 <strong>error</strong>，都會直接 reject，不再往下執行。</li></ol><p>舉幾個簡單例子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 直接拋出 Error
</span><span style=color:#75715e>// Return 的 promise 是 rejected 狀態
</span><span style=color:#75715e></span><span style=color:#a6e22e>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>throwDirectly</span> () {
  <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#39;Rejected!&#39;</span>)
}

<span style=color:#75715e>// 從 await 表達式中拋出錯誤
</span><span style=color:#75715e>// await 會把 promise 中的 error 向外傳遞到 async function context 中
</span><span style=color:#75715e>// Return 的 promise 是 rejected 狀態
</span><span style=color:#75715e></span><span style=color:#a6e22e>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>throwFromAwait</span> () {
  <span style=color:#a6e22e>await</span> Promise.<span style=color:#a6e22e>reject</span>(<span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#39;Rejected!&#39;</span>))
}

<span style=color:#75715e>// 透過 try-catch 處理錯誤，錯誤不繼續傳遞
</span><span style=color:#75715e>// Return 的 promise 不會被 reject
</span><span style=color:#75715e></span><span style=color:#a6e22e>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>handleError</span> () {
  <span style=color:#66d9ef>try</span> {
    <span style=color:#a6e22e>await</span> Promise.<span style=color:#a6e22e>reject</span>(<span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#39;Rejected!&#39;</span>))
  } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>e</span>) {
    <span style=color:#75715e>// Explicitly swallow errors
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`Got error: </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>e</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>)
  }
}

<span style=color:#75715e>// 利用其他流程控制語句，達到 early return 的效果
</span><span style=color:#75715e></span><span style=color:#a6e22e>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>earlyReturn</span> () {
  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>someRuleFulfill</span>) {
    <span style=color:#75715e>// 直接 return value，外部會收到 `Promise.resolve(&#39;Return Value&#39;)`
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;Return Value&#39;</span>
  }
  <span style=color:#75715e>// 由於原本即是 return a promise，所以不需使用 `await` 等待結果
</span><span style=color:#75715e></span>  <span style=color:#75715e>// No need to: `return await heavyAsyncProcess()`
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>heavyAsyncProcess</span>()
}
</code></pre></div><p>看完範例，我們可以得知 Async function 的錯誤處理模式與一般的 function 如出一轍，即「由 context 的執行情形來決定何時 return，何時該 throw Error」。</p><p>另外，Async function 的 return value 與 Error 傳到 caller context 時會以 promise 包裹。不會讓整個 call frame 掛掉，但也如同 promise 對錯誤比較 silent，所以再次提醒，慣例會在 async function 內部透過 <strong>try-catch</strong> 處理錯誤，不讓錯誤傳遞過遠，好比 promise 最後必會掛個 catch 處理錯誤。</p><h3 id=declarations>Declarations</h3><p>Async function 既然是 function，想必有許多不同的宣告方式，在此將常用的方式列出來。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// function declaration
</span><span style=color:#75715e></span><span style=color:#a6e22e>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>asyncFunc</span> () {}

<span style=color:#75715e>// IIFE (Immediately Invoked Function Expression)
</span><span style=color:#75715e></span>(<span style=color:#a6e22e>async</span> <span style=color:#66d9ef>function</span> () {<span style=color:#75715e>/* ... */</span>}())

<span style=color:#75715e>// ES6 Arrow Function
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>myAsync</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>async</span> () =&gt; {}

<span style=color:#75715e>// An object props
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>obj</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>async</span> <span style=color:#a6e22e>myAsync</span> () {},
  <span style=color:#a6e22e>otherProp</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1234</span>
}

<span style=color:#75715e>// A method of a class
</span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span> {
  <span style=color:#a6e22e>async</span> <span style=color:#a6e22e>myAsync</span> () {}
}
</code></pre></div><h2 id=advanced-usage>Advanced Usage</h2><h3 id=sequential-operation>Sequential Operation</h3><p>還記得<a href=https://weihanglo.github.io/posts/2017/javascript-concurrency-promise/>上一篇文章</a>，我們利用 <code>Array#reduce</code> 與 <code>Array#forEach</code> 實作 serial operation 嗎？雖然 promise + functional programming 看起來很有逼格，但又多了一層抽象理解層次。藉由 async function <code>await</code> 的特性，我們可以寫出很直觀 sequential operations，避開那些 hack。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 直觀的同步操作，每個 await 皆會等 promise resolution 再往下執行
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>processInSequence</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>async</span> (<span style=color:#a6e22e>url</span>) =&gt; {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>resA</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>getAsyncResult</span>(<span style=color:#e6db74>&#39;a&#39;</span>)
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>resB</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>getAsyncResult</span>(<span style=color:#e6db74>&#39;b&#39;</span>)
  <span style=color:#66d9ef>return</span> {<span style=color:#a6e22e>resA</span>, <span style=color:#a6e22e>resB</span>}
}
</code></pre></div><p>透過 <code>for</code> loop，也可達成 sequential 的效果。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 利用 for loop，iterate 所有 url，逐一等待 promise resolution
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fetchInSequence</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>async</span> <span style=color:#a6e22e>urls</span> =&gt; {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> []
  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>url</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>urls</span>) {
    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>res</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>url</span>)
    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>json</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>()
    <span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>json</span>)
  }
}
</code></pre></div><h3 id=parallel-operation>Parallel Operation</h3><p>如果 <code>await</code> 會阻塞該 context（正確說來是轉移執行權），那我如何設計 parallel operation 呢？</p><p>非常簡單，那就提前讓 promise 開始執行嘛！</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 平行執行兩個 promise
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>operationInParallel</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>async</span> () =&gt; {
  <span style=color:#75715e>// 不加 await，一次執行兩個 promise
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>pA</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>getAsyncResult</span>(<span style=color:#e6db74>&#39;a&#39;</span>)
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>pB</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>getAsyncResult</span>(<span style=color:#e6db74>&#39;b&#39;</span>)
  <span style=color:#75715e>// 加上 await，耐心等待 promise 的結果
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>resA</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>pA</span>
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>resB</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>pB</span>
  <span style=color:#66d9ef>return</span> [<span style=color:#a6e22e>resA</span>, <span style=color:#a6e22e>resB</span>]
}
</code></pre></div><p>自幹兩個 promises 很不直觀？不然我們改用 <code>Promise.all</code>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 使用 Promise.all await 多個 promises
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>promiseAllInParallel</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>async</span> () =&gt; {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>await</span> Promise.<span style=color:#a6e22e>all</span>([
    <span style=color:#a6e22e>getAsyncResult</span>(<span style=color:#e6db74>&#39;a&#39;</span>),
    <span style=color:#a6e22e>getAsyncResult</span>(<span style=color:#e6db74>&#39;b&#39;</span>)
  ])
}
</code></pre></div><p>蛤！<code>Promise.all</code> 又出現了！使用 async function 不就是為了拋棄 promise 嗎？很抱歉，在有更清楚的語言特性出現前，只能選擇這種方式，畢竟 async funciton 整個 tech stack 就是建立於 promise 之上。</p><p>如果是多個 promise，也可以利用 <code>Array#map</code> 建立新的 context（function scope）來實作 parallel operation，這種方式看起來也稍微 hack，不過仍是本著 async function 的概念。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 利用 `Array#map` 實作 parallel operations
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fetchInParallel</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>async</span> <span style=color:#a6e22e>urls</span> =&gt; {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>jsonPromises</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>urls</span>.<span style=color:#a6e22e>map</span>(<span style=color:#a6e22e>async</span> <span style=color:#a6e22e>url</span> =&gt; { <span style=color:#75715e>// 建立新的 async function context
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>res</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>rul</span>) <span style=color:#75715e>// await 只會在這個 context 內等待
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>()
  })
  <span style=color:#75715e>// 我們可以按順序地印出結果
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>jsonPromise</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>jsonPromises</span>) {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>await</span> <span style=color:#a6e22e>jsonPromise</span>) <span style=color:#75715e>// 等待個別 promise resolution
</span><span style=color:#75715e></span>  }
}
</code></pre></div><h3 id=promiserace>Promise.race</h3><p>想模擬 <code>Promise.race</code>，該如何實作？就直接用 <code>Promise.race</code> 吧。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>getFirstResolutionInParallel</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>async</span> <span style=color:#a6e22e>urls</span> =&gt; {
  <span style=color:#75715e>// 利用 Promise.race 取得第一個 resolution (either reject or fulfill) 的 promise
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> Promise.<span style=color:#a6e22e>race</span>(<span style=color:#a6e22e>urls</span>.<span style=color:#a6e22e>map</span>(<span style=color:#a6e22e>async</span> <span style=color:#a6e22e>url</span> =&gt; {
    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>res</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>url</span>)
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>()
  }))
}
</code></pre></div><h3 id=first-fulfillment>First Fulfillment</h3><p>在前一篇 Promise 文章中，我們 invert <code>onRejected</code> <code>onFulfilled</code> 兩個 callback，取得首個 fullfillment result。那在 async function 該如何實作呢？</p><p>當然，我們可以直接拿 Promise 做一樣的事，不過時代在走，人要進步，讓我們嘗試使用 <code>try-catch</code> 吧！</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// from Stackoverflow https://stackoverflow.com/a/39941616
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>invert</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>p</span> =&gt; <span style=color:#66d9ef>new</span> Promise((<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>rej</span>) =&gt; <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>rej</span>, <span style=color:#a6e22e>res</span>))

<span style=color:#75715e>// 利用 try catch 實作 get first fullfillment（但仍須借助 Promise 的 API）
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>firstFulfillmentInParallel</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>async</span> <span style=color:#a6e22e>urls</span> =&gt; {
  <span style=color:#66d9ef>try</span> {
    <span style=color:#a6e22e>await</span> Promise.<span style=color:#a6e22e>all</span>(
      <span style=color:#a6e22e>urls</span>.<span style=color:#a6e22e>map</span>(<span style=color:#a6e22e>async</span> <span style=color:#a6e22e>url</span> =&gt; {
        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>res</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>url</span>)
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>()
      }).<span style=color:#a6e22e>map</span>(<span style=color:#a6e22e>invert</span>)
    )
  } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>e</span>) {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>e</span> <span style=color:#75715e>// 直接返回 inversion 的 fulfillment
</span><span style=color:#75715e></span>  }
}
</code></pre></div><p>雖然有達到目的，但 fulfillment 卻是從 <code>catch</code> block 返回，實作漸漸不直觀了。</p><h2 id=async-interation>Async Interation</h2><p>我們知道，async function 原理上是 generator 的 syntax sugar，利用 iterator 與 <code>yield</code> 轉換控制權，達成 asynchronous operation 效果，但是 <code>iterator.next</code> 這個 method 卻只有 synchronous 版本，有些場景（例如 streaming）需要非同步的 iterator 來取得 streaming data，這時候就該 <strong>async interator</strong> 出場了。</p><p><a href=https://github.com/tc39/proposal-async-iteration>這個提議</a>目前已在 Stage 3 了，即將納入標準，可以開始瞭解它了。</p><p>話不多說，附上提議的範例程式碼，感受一下吧！</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// for-await-of loop
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>await</span> (<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>line</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>readLines</span>(<span style=color:#a6e22e>filePath</span>)) {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>line</span>);
}

<span style=color:#75715e>// Async generator functions
</span><span style=color:#75715e></span><span style=color:#a6e22e>async</span> <span style=color:#66d9ef>function</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>readLines</span>(<span style=color:#a6e22e>path</span>) {
  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>file</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>fileOpen</span>(<span style=color:#a6e22e>path</span>);

  <span style=color:#66d9ef>try</span> {
    <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>EOF</span>) {
      <span style=color:#66d9ef>yield</span> <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>readLine</span>();
    }
  } <span style=color:#66d9ef>finally</span> {
    <span style=color:#a6e22e>await</span> <span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>close</span>();
  }
}
</code></pre></div><h2 id=further-reading>Further Reading</h2><p>比起 promises，async functions 相對沒這麼多文獻供參考，想要入門，依然推薦阮大大的 <a href=http://es6.ruanyifeng.com/#docs/async>ECMAScript 6 入门：async 函数</a>，真的是非常豐富的 ES6 大全。當然，<a href=https://developers.google.com/web/fundamentals/getting-started/primers/async-functions>Google Web Fundamentals</a> 也值得一看，但沒有 Promise 篇含金量這麼高就是了。</p><p>Medium 上也有許多作者在評論 async functions，<a href=https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9>Hacker Noon 這篇推坑文</a>比較了 promise 與 async function 的優劣，算是蠻清楚的入門文，看看 async function 是否符合妳的期待。另外，也有人寫了不少篇<del>批判</del>反思 async function 的文章，<a href=https://medium.com/@bluepnume/learn-about-promises-before-you-start-using-async-await-eb148164a9c8>這篇告訴你還是需要理解 promise</a> 才能以正確的姿勢使用 async／await，另一篇則告訴你，<a href=https://medium.com/@bluepnume/even-with-async-await-you-probably-still-need-promises-9b259854c161>promise 還是比較厲害</a>的啦。</p><p>當然，沒有任何 unit tests，就算程式碼可讀性再高，仍然非常脆弱，所以，別花太多時間看這些新技術，乖乖地補上缺漏的 tests 比較實在 XD。</p><h2 id=reference>Reference</h2><ul><li><a href=https://developer.mozilla.org/>Mozilla Developer Network</a></li><li><a href=https://developers.google.com/web/fundamentals/getting-started/primers/async-functions>Google Web Fundamentals: Async functions - making promises friendly</a></li><li><a href=http://es6.ruanyifeng.com/#docs/generator-async>ECMAScript 6 入门：Generator 函数的异步应用</a></li><li><a href=http://es6.ruanyifeng.com/#docs/async>ECMAScript 6 入门：async 函数</a></li><li><a href=https://medium.com/@bluepnume/learn-about-promises-before-you-start-using-async-await-eb148164a9c8>Daniel Brain: Understand promises before you start using async/await</a></li><li><a href=https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9>Haker Noon: 6 Reasons Why JavaScript’s Async/Await Blows Promises Away</a></li></ul></div><footer class=entry-footer><div class="container sep-before"><div class=tags><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2H12l8.59 8.59A2 2 0 0120.59 13.41z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=screen-reader-text>Tags: </span><a class=tag href=/tags/javascript/>JavaScript</a>, <a class=tag href=/tags/concurrency/>Concurrency</a>, <a class=tag href=/tags/async-function/>Async Function</a>, <a class=tag href=/tags/generator/>Generator</a>, <a class=tag href=/tags/front-end/>Front-end</a></div></div><div style=text-align:center;padding-top:2em><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/><img src=https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png alt=cc-by-nc-sa-4></a></div></footer></article><nav class=entry-nav><div class=container><div class="prev-entry sep-before"><a href=/posts/2017/javascript-concurrency-promise/><span aria-hidden=true><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="20" y1="12" x2="4" y2="12"/><polyline points="10 18 4 12 10 6"/></svg>Previous</span>
<span class=screen-reader-text>Previous post: </span>現代化的 JavaScript 併發 - Promises</a></div><div class="next-entry sep-before"><a href=/posts/2017/days-with-internet-explorer/><span class=screen-reader-text>Next post: </span>與 IE 相處的日子<span aria-hidden=true>Next<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="4" y1="12" x2="20" y2="12"/><polyline points="14 6 20 12 14 18"/></svg></span></a></div></div></nav></main><footer id=footer class=footer><div class="container sep-before"><section class="widget widget-social_menu sep-after"><nav aria-label="Social Menu"><ul><li><a href=https://github.com/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Github account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li><a href=https://facebook.com/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Facebook account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M18 2h-3a5 5 0 00-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 011-1h3z"/></svg></a></li><li><a href=https://twitter.com/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Twitter account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><title>Twitter icon</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></li><li><a href=https://linkedin.com/in/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Linkedin account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></li><li><a href=https://t.me/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Telegram account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><title>Telegram icon</title><path d="M23.91 3.79 20.3 20.84c-.25 1.21-.98 1.5-2 .94l-5.5-4.07-2.66 2.57c-.3.3-.55.56-1.1.56-.72.0-.6-.27-.84-.95L6.3 13.7l-5.45-1.7c-1.18-.35-1.19-1.16.26-1.75l21.26-8.2c.97-.43 1.9.24 1.53 1.73z"/></svg></a></li></ul></nav></section><div class=copyright><p>&copy; 2017-2021 Weihang Lo</p></div></div></footer></div></div><script>window.__assets_js_src="/assets/js/"</script><script src=/assets/js/main.c3bcf2df.js></script><script src=/js/custom.js></script></body></html>