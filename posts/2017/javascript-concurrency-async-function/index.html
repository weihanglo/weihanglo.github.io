<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>現代化的 JavaScript 併發 - Async Functions | Life is a refactoring process without tests</title>
<meta name=keywords content="JavaScript,Concurrency,Async Function,Generator,Front-end">
<meta name=description content="在前一篇介紹 JavaScript Concurrency 的文章中，Promise 提供開發者安全統一的標準 API，透過 thenable 減少 callback hell，巨幅降低開發非同步程式的門檻，大大提升可維護性">
<meta name=author content>
<link rel=canonical href=https://weihanglo.tw/posts/2017/javascript-concurrency-async-function/>
<link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style>
<link rel=icon href=https://weihanglo.tw/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://weihanglo.tw/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://weihanglo.tw/favicon-32x32.png>
<link rel=apple-touch-icon href=https://weihanglo.tw/apple-touch-icon.png>
<link rel=mask-icon href=https://weihanglo.tw/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:!0},{left:'$',right:'$',display:!1},{left:'\\(',right:'\\)',display:!1},{left:'\\[',right:'\\]',display:!0}],throwOnError:!1})})</script>
<meta property="og:title" content="現代化的 JavaScript 併發 - Async Functions">
<meta property="og:description" content="在前一篇介紹 JavaScript Concurrency 的文章中，Promise 提供開發者安全統一的標準 API，透過 thenable 減少 callback hell，巨幅降低開發非同步程式的門檻，大大提升可維護性">
<meta property="og:type" content="article">
<meta property="og:url" content="https://weihanglo.tw/posts/2017/javascript-concurrency-async-function/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2017-06-18T12:45:34+08:00">
<meta property="article:modified_time" content="2017-06-18T12:45:34+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="現代化的 JavaScript 併發 - Async Functions">
<meta name=twitter:description content="在前一篇介紹 JavaScript Concurrency 的文章中，Promise 提供開發者安全統一的標準 API，透過 thenable 減少 callback hell，巨幅降低開發非同步程式的門檻，大大提升可維護性">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://weihanglo.tw/posts/"},{"@type":"ListItem","position":3,"name":"現代化的 JavaScript 併發 - Async Functions","item":"https://weihanglo.tw/posts/2017/javascript-concurrency-async-function/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"現代化的 JavaScript 併發 - Async Functions","name":"現代化的 JavaScript 併發 - Async Functions","description":"在前一篇介紹 JavaScript Concurrency 的文章中，Promise 提供開發者安全統一的標準 API，透過 thenable 減少 callback hell，巨幅降低開發非同步程式的門檻，大大提升可維護性","keywords":["JavaScript","Concurrency","Async Function","Generator","Front-end"],"articleBody":"在前一篇介紹 JavaScript Concurrency 的文章中，Promise 提供開發者安全統一的標準 API，透過 thenable 減少 callback hell，巨幅降低開發非同步程式的門檻，大大提升可維護性。不過，Promise 仍沒達到 JS 社群的目標「Write async code synchronously」。本篇文章將簡單最新的 Concurrency Solution「Async Functions」，利用同步的語法寫非同步的程式，整個人都變潮了呢！\n（撰於 2017-06-17，基於 ECMAScript 7+）\nIntroduction Async Functions 在去年進入 Stage 4，正式成為 ECMAScript 7 標準，這對 JS 社群無疑是一大利多。截至目前為止（2017.6），實作 Async Functions 的環境有：\n Node.js 7.6.0 (without --harmony) Chrome 55 Firefox 52 Safari 10.1 Edge 15  可以看到當前 Release 版的 Desktop browser 都可以用了。\n從此我們不會在 callback hell 中迷失自我，不需在 then 中塞一堆 console.log，也不需使用蹩足的 generator 語法。ES7 的 async function 完成我們對非同步程式的想像。\n真的有這麼好康嗎？\nMDN 點出 async function 的定位。\n The purpose of async/await functions is to simplify the behavior of using promises synchronously and to perform some behavior on a group of Promises. Just like Promises are similar to structured callbacks, async/await is similar to combining generators and promises.\n Async functions 的目的在於簡化多個 promise 操作，不需要再串聯一堆 then。如果我們將 Promises 比喻為好讀版的 callbacks，那 async／await 就是 generator + promise 的綜合體，因此，我們仍需學習 promise 以及 generator 等概念。\n話不多說，一起快速了解 generator 吧！\nGenerator With Async Operations 在 async／await 還沒出世之前，generator function 是非同步程式設計的最新潮的替代品，TJ 的 co 與 Facebook 的 regenerator 這兩個 libraries 都擁有高人氣。藉由 Coroutine（協程） suspend／resume 的機制，讓開發非同步 JS 可以避開多線程煩人的 context-switch、dead lock，能用很直觀的方式撰寫程式。當然，coroutine 仍是在同個 thread 上面執行，並非真實的 parallel computing，不過 browser 這種常出現 I／O 的場景中，coroutine 已綽綽有餘了。\n我只是想了解 async function 怎麼用，為什麼還要學 coroutine 和 generator？不會太複雜嗎？\n別緊張，接下來將淺淺帶過 generator 概念。本人同樣不喜歡 generator 醜陋的 *，* 只該留給最愛的 pointer。介紹 generator 之前，先來了解 ES6 的 Iterable 與 Iterator 吧 XD！（不是說好快速瞭解 generator 嗎⋯⋯）\nIterable \u0026 Iterator ES6 除了引入標準的 Promise object 以外，另一重大的語法變革就是 Iterator 與 Generator。熟悉 C++、Swift、Java 或 Python 3 的朋友應該非常熟悉 iterable／iterator 等名詞。在 JavaScript中，名詞解釋大致如下：\n iterable 是指可迭代的物件，也就是可丟進 loop 運作的物件，會產生 iterator，但不一定是 sequence 或 container。 iterator 就是鼎鼎大名的迭代器，如同指針般迭代東西（通常是 iterable 提供的值）。  日常會遇到的 iterable 應該會長這樣：\nfor (let obj of iterable) {} iterable.forEach() iterable.map() 這些 iterable 有共通特性，就像下面的 list 一樣又臭又長。\n 有一個 [Symbol.iterator] method，  [Symbol.iterator] 會回傳一個 iterator object，  iterator 上要有 next method，  next method 會回傳一個 object 記錄 iteration 當前狀態，其有兩個 property，  done：當次 iteration 是否結束的 boolean flag value：當次 iteration 的 return value          看了這種 nested list，是不是眼睛都茫了，想立馬關掉這篇廢文呢？別怕，常用的 Array 和 ES6 的 Map、Set 等都是內建的 iterable，我們不需自己辛苦實作；而 plain Object 雖非 iterable，但也有 Object.entries 等方法供我們轉換成 iterable 呢。\n我們來看一個簡單 Iterator 實作：\nconst infiniteLoop = {} infiniteLoop[Symbol.iterator] = function () { // 實作 iterator 建構 funtion  let v = 0 return { // 回傳有 `next` method 的 object  next: () = ({ // 回傳記錄當前 iteration state 的 object  value: ++v, done: false }) } } // 無限迴圈 for (let v of infiniteLoop) { console.log(v) }  有興趣了解相關 protocols，可以看此。\n Generator 上一節最後，我們從頭打造了一個 Iterator，看起來十分不易，其實 iterator 實作繁瑣，是每種語言皆然，連 Python 3 也不例外，於是，generator 就誕生了。 Generator 基於 iterator 概念之上，利用簡單明瞭的語法，讓建構 iterator 不必這麼痛苦。我們將前一節的例子改成 generator 試試看。\nfunction* genFunc () { // `*` 宣告一個 generator function，即是 iterator factory  let v = 0 while (true) { yield ++v // generator function 的 body 內才能使用 `yield` keyword  } } // 無限迴圈 const g = genFunc() // 產生一個 iterator let v = g.next() // 取得 iterator 下一個 state while (!v.done) { console.log(v.value) v = g.next() } 乍看之下，似乎沒比 iterator 簡單，而且又多了 function* 和 yield，是要嚇死人嗎？這裡的重點並非語法，而是一開始提及的 Coroutine概念。這種 coroutine 的概念與一般逐行執行的程式不同，運作流程如下：\n 執行到 yield，暫停。 將執行權交給外部，等待外部 call next。 外部 call next，回到步驟一繼續執行。  套在我們的例子中，就是：\n 當每次 genFunc 執行到 yield 時，會停下來， 將程式執行權交給外部 caller， 等到外部調用者再次 call next method，genFunc 再接著執行。  簡而言之，「Generator 是 coroutine 的一種形式，是一個 pause／resume 的執行流程」。但這樣到底與非同步程式設計有啥鬼關係？\n重點在於「透過 coroutine 將程式執行權交給外部 caller」，這可好玩了，如果我們讓 yield 返回一個 promise，程式執行權就會回到 caller 上，而 caller 不僅有程式執行權，可以執行其他程式片段，也可以取得非同步操作的結果。想像中的程式碼長這樣：\n// 想像中的程式碼 // fetch 是一個 promise-based 非同步 function function* asyncFunc () { const a = yield fetch('a') console.log(a) const b = yield fetch('b') console.log(b) } 看起來非常驚人！可惜這是虛擬的程式碼，a、b 都是一個 Promise，需要利用 then method 取得 resolve value。不過，JS 社群當然不會放過 generator 這個裝逼的好工具，大神們透過各種奇淫巧技，讓我得以利用 generator 優美地寫出 synchronously asynchronous code，以下這個例子便是透過 spawn 自動執行 next 的 helper function 達成。\n// Helper Function // from: Jake Archibald - JavaScript Promises: an Introduction function spawn (generatorFunc) { function continuer (verb, arg) { var result try { result = generator[verb](arg) } catch (err) { return Promise.reject(err) } if (result.done) { return result.value } return Promise.resolve(result.value).then(onFulfilled, onRejected) } var generator = generatorFunc() var onFulfilled = continuer.bind(continuer, 'next') var onRejected = continuer.bind(continuer, 'throw') return onFulfilled() } // 利用 spawn 包裹，自動執行 generator function // 這是一個 sequential(serial) operation spawn(function* () { const a = yield fetch('a') // 等待 fetch('a')，並將結果 assign to a  console.log(a) // a 是一個  const b = yield fetch('b') // 等待 fetch('b')，並將結果 assign to b  console.log(b) }) 這就是 async generator 的實作，很美，但過程十分嚇人。\n Note：Coroutine（協程）比較明確的定義是，指執行權從一個 coroutine 交至另外一個 coroutine，不過概念上類似，這裡借用一下，特此說明。\n Debut of Async Functions 使用上面這些燒腦的東西，雖達成任務，不過太疊床架屋，抽象概念難以消化。這時候就該主角 Async Function 登場！可以將 async functions 想像為 generator + promise，不過更直接的講法是：「Async Function 是內置 spawn 的 generator function」。\n接下來，將前面使用 spawn 執行的 generator function 改寫成 async function。\n// 利用 `async` keyword 宣告 一個 async function async function run () { const a = await fetch('a') // 使用 `await` 等待 fetch('a')，並將結果 assign to a  console.log(a) const b = await fetch('b') // 使用 `await` 等待 fetch('b')，並將結果 assign to b  console.log(b) } // 執行 async function，不需自己寫 `spawn`，如同正常的 function call。 run() Async functions 使用語意清楚的 async／await 取代 function*／yield，除此之外，幾乎與 generator 版本一模一樣。其差異如下：\n 不需額外的 helper function 來執行，一般的 function call 即可。 回傳值為 promise。（相比於 generator 回傳 iterator，async function 復用／組合性較高）  Usage 使用方法如下，非常簡單：\nasync function myAsyncFunc () { let result try { // 慣例使用 try-catch 處理錯誤  const a = await fetchA() // async operation  const b = await fetchB() // async operation  result = {a, b} } catch (e) { // 將 error 吃掉  console.log(`Error occurred: ${e}`) } return result } Await await 是用來等待 Promise resolution 的運算子，語法與特性如下：\n[rv] = await expression // rv - return value of await expression  僅能用在 async function 內部。 expression 若是 promise 以外的 value，直接返回該 value expression 若接 promise object，則等待該 promise resolution。  若 promise fulfilled，直接返回該 value。 若 promise rejected，拋出 Error 到 async function context 中（不被 promise 本身吃掉）。    這裡要注意的是，await 會等待 promise resolution 後才 return value，所以行為與 synchronous code 一致。\n// async arrow function const fun = async () = { const a = await Promise.resolve() // 等待 a 處理完畢，再往下執行  const b = await a.process() // 等待 b 處理完畢，再往下執行  const c = await b.process() // 返回最終的結果 c  return c } Return Value 我們知道，Async function 的 return value 會是一個 promise，那這個 promise 什麼時候會 fulfill，什麼時候會被 reject 呢？\n情況其實不複雜，整理如下：\n return 語句會使 async function 直接 resolve，不再往下執行。   若 return 一個 promise，則以該 promise 為 return value。 若 return 一個非 promise 的 value，則以 Promise.resolve 包裹該 value。  function context 內部拋出任何 error，都會直接 reject，不再往下執行。  舉幾個簡單例子：\n// 直接拋出 Error // Return 的 promise 是 rejected 狀態 async function throwDirectly () { throw new Error('Rejected!') } // 從 await 表達式中拋出錯誤 // await 會把 promise 中的 error 向外傳遞到 async function context 中 // Return 的 promise 是 rejected 狀態 async function throwFromAwait () { await Promise.reject(new Error('Rejected!')) } // 透過 try-catch 處理錯誤，錯誤不繼續傳遞 // Return 的 promise 不會被 reject async function handleError () { try { await Promise.reject(new Error('Rejected!')) } catch (e) { // Explicitly swallow errors  console.log(`Got error: ${e}`) } } // 利用其他流程控制語句，達到 early return 的效果 async function earlyReturn () { if (someRuleFulfill) { // 直接 return value，外部會收到 `Promise.resolve('Return Value')`  return 'Return Value' } // 由於原本即是 return a promise，所以不需使用 `await` 等待結果  // No need to: `return await heavyAsyncProcess()`  return heavyAsyncProcess() } 看完範例，我們可以得知 Async function 的錯誤處理模式與一般的 function 如出一轍，即「由 context 的執行情形來決定何時 return，何時該 throw Error」。\n另外，Async function 的 return value 與 Error 傳到 caller context 時會以 promise 包裹。不會讓整個 call frame 掛掉，但也如同 promise 對錯誤比較 silent，所以再次提醒，慣例會在 async function 內部透過 try-catch 處理錯誤，不讓錯誤傳遞過遠，好比 promise 最後必會掛個 catch 處理錯誤。\nDeclarations Async function 既然是 function，想必有許多不同的宣告方式，在此將常用的方式列出來。\n// function declaration async function asyncFunc () {} // IIFE (Immediately Invoked Function Expression) (async function () {/* ... */}()) // ES6 Arrow Function const myAsync = async () = {} // An object props var obj = { async myAsync () {}, otherProp: 1234 } // A method of a class class MyClass { async myAsync () {} } Advanced Usage Sequential Operation 還記得上一篇文章，我們利用 Array#reduce 與 Array#forEach 實作 serial operation 嗎？雖然 promise + functional programming 看起來很有逼格，但又多了一層抽象理解層次。藉由 async function await 的特性，我們可以寫出很直觀 sequential operations，避開那些 hack。\n// 直觀的同步操作，每個 await 皆會等 promise resolution 再往下執行 const processInSequence = async (url) = { const resA = await getAsyncResult('a') const resB = await getAsyncResult('b') return {resA, resB} } 透過 for loop，也可達成 sequential 的效果。\n// 利用 for loop，iterate 所有 url，逐一等待 promise resolution const fetchInSequence = async urls = { const result = [] for (let url of urls) { const res = await fetch(url) const json = await res.json() result.push(json) } } Parallel Operation 如果 await 會阻塞該 context（正確說來是轉移執行權），那我如何設計 parallel operation 呢？\n非常簡單，那就提前讓 promise 開始執行嘛！\n// 平行執行兩個 promise const operationInParallel = async () = { // 不加 await，一次執行兩個 promise  const pA = getAsyncResult('a') const pB = getAsyncResult('b') // 加上 await，耐心等待 promise 的結果  const resA = await pA const resB = await pB return [resA, resB] } 自幹兩個 promises 很不直觀？不然我們改用 Promise.all。\n// 使用 Promise.all await 多個 promises const promiseAllInParallel = async () = { return await Promise.all([ getAsyncResult('a'), getAsyncResult('b') ]) } 蛤！Promise.all 又出現了！使用 async function 不就是為了拋棄 promise 嗎？很抱歉，在有更清楚的語言特性出現前，只能選擇這種方式，畢竟 async funciton 整個 tech stack 就是建立於 promise 之上。\n如果是多個 promise，也可以利用 Array#map 建立新的 context（function scope）來實作 parallel operation，這種方式看起來也稍微 hack，不過仍是本著 async function 的概念。\n// 利用 `Array#map` 實作 parallel operations const fetchInParallel = async urls = { const jsonPromises = urls.map(async url = { // 建立新的 async function context  const res = await fetch(rul) // await 只會在這個 context 內等待  return res.json() }) // 我們可以按順序地印出結果  for (let jsonPromise of jsonPromises) { console.log(await jsonPromise) // 等待個別 promise resolution  } } Promise.race 想模擬 Promise.race，該如何實作？就直接用 Promise.race 吧。\nconst getFirstResolutionInParallel = async urls = { // 利用 Promise.race 取得第一個 resolution (either reject or fulfill) 的 promise  return Promise.race(urls.map(async url = { const res = await fetch(url) return res.json() })) } First Fulfillment 在前一篇 Promise 文章中，我們 invert onRejected onFulfilled 兩個 callback，取得首個 fullfillment result。那在 async function 該如何實作呢？\n當然，我們可以直接拿 Promise 做一樣的事，不過時代在走，人要進步，讓我們嘗試使用 try-catch 吧！\n// from Stackoverflow https://stackoverflow.com/a/39941616 const invert = p = new Promise((res, rej) = p.then(rej, res)) // 利用 try catch 實作 get first fullfillment（但仍須借助 Promise 的 API） const firstFulfillmentInParallel = async urls = { try { await Promise.all( urls.map(async url = { const res = await fetch(url) return res.json() }).map(invert) ) } catch (e) { return e // 直接返回 inversion 的 fulfillment  } } 雖然有達到目的，但 fulfillment 卻是從 catch block 返回，實作漸漸不直觀了。\nAsync Interation 我們知道，async function 原理上是 generator 的 syntax sugar，利用 iterator 與 yield 轉換控制權，達成 asynchronous operation 效果，但是 iterator.next 這個 method 卻只有 synchronous 版本，有些場景（例如 streaming）需要非同步的 iterator 來取得 streaming data，這時候就該 async interator 出場了。\n這個提議目前已在 Stage 3 了，即將納入標準，可以開始瞭解它了。\n話不多說，附上提議的範例程式碼，感受一下吧！\n// for-await-of loop for await (const line of readLines(filePath)) { console.log(line); } // Async generator functions async function* readLines(path) { let file = await fileOpen(path); try { while (!file.EOF) { yield await file.readLine(); } } finally { await file.close(); } } Further Reading 比起 promises，async functions 相對沒這麼多文獻供參考，想要入門，依然推薦阮大大的 ECMAScript 6 入门：async 函数，真的是非常豐富的 ES6 大全。當然，Google Web Fundamentals 也值得一看，但沒有 Promise 篇含金量這麼高就是了。\nMedium 上也有許多作者在評論 async functions，Hacker Noon 這篇推坑文比較了 promise 與 async function 的優劣，算是蠻清楚的入門文，看看 async function 是否符合妳的期待。另外，也有人寫了不少篇批判反思 async function 的文章，這篇告訴你還是需要理解 promise 才能以正確的姿勢使用 async／await，另一篇則告訴你，promise 還是比較厲害的啦。\n當然，沒有任何 unit tests，就算程式碼可讀性再高，仍然非常脆弱，所以，別花太多時間看這些新技術，乖乖地補上缺漏的 tests 比較實在 XD。\nReference  Mozilla Developer Network Google Web Fundamentals: Async functions - making promises friendly ECMAScript 6 入门：Generator 函数的异步应用 ECMAScript 6 入门：async 函数 Daniel Brain: Understand promises before you start using async/await Haker Noon: 6 Reasons Why JavaScript’s Async/Await Blows Promises Away  ","wordCount":"5199","inLanguage":"en","datePublished":"2017-06-18T12:45:34+08:00","dateModified":"2017-06-18T12:45:34+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://weihanglo.tw/posts/2017/javascript-concurrency-async-function/"},"publisher":{"@type":"Organization","name":"Life is a refactoring process without tests","logo":{"@type":"ImageObject","url":"https://weihanglo.tw/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://weihanglo.tw accesskey=h title="Life is a refactoring process without tests (Alt + H)">Life is a refactoring process without tests</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=https://weihanglo.tw/ title=Home>
<span>Home</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
現代化的 JavaScript 併發 - Async Functions
</h1>
<div class=post-meta><span title="2017-06-18 12:45:34 +0800 +0800">June 18, 2017</span>&nbsp;·&nbsp;11 min
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#introduction aria-label=Introduction>Introduction</a></li>
<li>
<a href=#generator-with-async-operations aria-label="Generator With Async Operations">Generator With Async Operations</a><ul>
<li>
<a href=#iterable--iterator aria-label="Iterable &amp;amp; Iterator">Iterable & Iterator</a></li>
<li>
<a href=#generator aria-label=Generator>Generator</a></li></ul>
</li>
<li>
<a href=#debut-of-async-functions aria-label="Debut of Async Functions">Debut of Async Functions</a><ul>
<li>
<a href=#usage aria-label=Usage>Usage</a></li>
<li>
<a href=#await aria-label=Await>Await</a></li>
<li>
<a href=#return-value aria-label="Return Value">Return Value</a></li>
<li>
<a href=#declarations aria-label=Declarations>Declarations</a></li></ul>
</li>
<li>
<a href=#advanced-usage aria-label="Advanced Usage">Advanced Usage</a><ul>
<li>
<a href=#sequential-operation aria-label="Sequential Operation">Sequential Operation</a></li>
<li>
<a href=#parallel-operation aria-label="Parallel Operation">Parallel Operation</a></li>
<li>
<a href=#promiserace aria-label=Promise.race>Promise.race</a></li>
<li>
<a href=#first-fulfillment aria-label="First Fulfillment">First Fulfillment</a></li></ul>
</li>
<li>
<a href=#async-interation aria-label="Async Interation">Async Interation</a></li>
<li>
<a href=#further-reading aria-label="Further Reading">Further Reading</a></li>
<li>
<a href=#reference aria-label=Reference>Reference</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>在前一篇介紹 <a href=https://weihanglo.github.io/posts/2017/javascript-concurrency-promise/>JavaScript Concurrency 的文章</a>中，Promise 提供開發者安全統一的標準 API，透過 <code>thenable</code> 減少 callback hell，巨幅降低開發非同步程式的門檻，大大提升可維護性。不過，Promise 仍沒達到 JS 社群的目標「Write async code synchronously」。本篇文章將簡單最新的 Concurrency Solution「Async Functions」，利用同步的語法寫非同步的程式，整個人都變潮了呢！</p>
<p><em>（撰於 2017-06-17，基於 ECMAScript 7+）</em></p>
<h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2>
<p><a href=https://tc39.github.io/ecmascript-asyncawait/>Async Functions</a> 在去年進入 Stage 4，正式成為 ECMAScript 7 標準，這對 JS 社群無疑是一大利多。截至目前為止（2017.6），實作 Async Functions 的環境有：</p>
<ul>
<li>Node.js 7.6.0 (without <code>--harmony</code>)</li>
<li>Chrome 55</li>
<li>Firefox 52</li>
<li>Safari 10.1</li>
<li>Edge 15</li>
</ul>
<p>可以看到<a href="https://caniuse.com/#search=async%20functions">當前 Release 版的 Desktop browser 都可以用了</a>。</p>
<p>從此我們不會在 callback hell 中迷失自我，不需在 <code>then</code> 中塞一堆 <code>console.log</code>，也不需使用蹩足的 generator 語法。ES7 的 <code>async function</code> 完成我們對非同步程式的想像。</p>
<p><strong>真的有這麼好康嗎？</strong></p>
<p><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function>MDN</a> 點出 async function 的定位。</p>
<blockquote>
<p>The purpose of async/await functions is to simplify the behavior of using promises synchronously and to perform some behavior on a group of Promises. Just like Promises are similar to structured callbacks, async/await is similar to combining generators and promises.</p>
</blockquote>
<p>Async functions 的目的在於簡化多個 promise 操作，不需要再串聯一堆 <code>then</code>。如果我們將 Promises 比喻為好讀版的 callbacks，那 async／await 就是 generator + promise 的綜合體，因此，<strong>我們仍需學習 promise 以及 generator 等概念</strong>。</p>
<p>話不多說，一起快速了解 generator 吧！</p>
<h2 id=generator-with-async-operations>Generator With Async Operations<a hidden class=anchor aria-hidden=true href=#generator-with-async-operations>#</a></h2>
<p>在 async／await 還沒出世之前，generator function 是非同步程式設計的最新潮的替代品，TJ 的 <a href=https://github.com/tj/co>co</a> 與 Facebook 的 <a href=https://github.com/facebook/regenerator>regenerator</a> 這兩個 libraries 都擁有高人氣。藉由 <a href=https://en.wikipedia.org/wiki/Coroutine>Coroutine（協程）</a> suspend／resume 的機制，讓開發非同步 JS 可以避開多線程煩人的 context-switch、dead lock，能用很直觀的方式撰寫程式。當然，coroutine 仍是在同個 thread 上面執行，並非真實的 parallel computing，不過 browser 這種常出現 I／O 的場景中，coroutine 已綽綽有餘了。</p>
<p><strong>我只是想了解 async function 怎麼用，為什麼還要學 coroutine 和 generator？不會太複雜嗎？</strong></p>
<p>別緊張，接下來將淺淺帶過 generator 概念。本人同樣不喜歡 generator 醜陋的 <code>*</code>，<code>*</code> 只該留給最愛的 pointer。介紹 generator 之前，先來了解 ES6 的 <strong>Iterable</strong> 與 <strong>Iterator</strong> 吧 XD！（不是說好快速瞭解 generator 嗎⋯⋯）</p>
<h3 id=iterable--iterator>Iterable & Iterator<a hidden class=anchor aria-hidden=true href=#iterable--iterator>#</a></h3>
<p>ES6 除了引入標準的 <code>Promise</code> object 以外，另一重大的語法變革就是 <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator>Iterator</a> 與 <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator>Generator</a>。熟悉 C++、Swift、Java 或 Python 3 的朋友應該非常熟悉 iterable／iterator 等名詞。在 JavaScript中，名詞解釋大致如下：</p>
<ul>
<li><strong>iterable</strong> 是指可迭代的物件，也就是可丟進 loop 運作的物件，會產生 <strong>iterator</strong>，但不一定是 <a href=https://en.wikipedia.org/wiki/Sequence>sequence</a> 或 <a href=https://en.wikipedia.org/wiki/Container_(abstract_data_type)>container</a>。</li>
<li><strong>iterator</strong> 就是鼎鼎大名的迭代器，如同指針般迭代東西（通常是 <strong>iterable</strong> 提供的值）。</li>
</ul>
<p>日常會遇到的 iterable 應該會長這樣：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>obj</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>iterable</span>) {}
<span style=color:#a6e22e>iterable</span>.<span style=color:#a6e22e>forEach</span>()
<span style=color:#a6e22e>iterable</span>.<span style=color:#a6e22e>map</span>()
</code></pre></div><p>這些 <strong>iterable</strong> 有共通特性，就像下面的 list 一樣又臭又長。</p>
<ul>
<li>有一個 <code>[Symbol.iterator]</code> method，
<ul>
<li><code>[Symbol.iterator]</code> 會回傳一個 <strong>iterator</strong> object，
<ul>
<li><strong>iterator</strong> 上要有 <code>next</code> method，
<ul>
<li><code>next</code> method 會回傳一個 object 記錄 iteration 當前狀態，其有兩個 property，
<ul>
<li><code>done</code>：當次 iteration 是否結束的 boolean flag</li>
<li><code>value</code>：當次 iteration 的 return value</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>看了這種 nested list，是不是眼睛都茫了，想立馬關掉這篇廢文呢？別怕，常用的 <code>Array</code> 和 ES6 的 <code>Map</code>、<code>Set</code> 等都是內建的 iterable，我們不需自己辛苦實作；而 plain <code>Object</code> 雖非 iterable，但也有 <code>Object.entries</code> 等方法供我們轉換成 iterable 呢。</p>
<p>我們來看一個簡單 Iterator 實作：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>infiniteLoop</span> <span style=color:#f92672>=</span> {}
<span style=color:#a6e22e>infiniteLoop</span>[<span style=color:#a6e22e>Symbol</span>.<span style=color:#a6e22e>iterator</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> () { <span style=color:#75715e>// 實作 iterator 建構 funtion
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
  <span style=color:#66d9ef>return</span> { <span style=color:#75715e>// 回傳有 `next` method 的 object
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>next</span><span style=color:#f92672>:</span> () =&gt; ({ <span style=color:#75715e>// 回傳記錄當前 iteration state 的 object
</span><span style=color:#75715e></span>      <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#f92672>++</span><span style=color:#a6e22e>v</span>,
      <span style=color:#a6e22e>done</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>
    })
  }
}

<span style=color:#75715e>// 無限迴圈
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>v</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>infiniteLoop</span>) {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>v</span>)
}
</code></pre></div><blockquote>
<p>有興趣了解相關 protocols，可以<a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator>看此</a>。</p>
</blockquote>
<h3 id=generator>Generator<a hidden class=anchor aria-hidden=true href=#generator>#</a></h3>
<p>上一節最後，我們從頭打造了一個 Iterator，看起來十分不易，其實 iterator 實作繁瑣，是每種語言皆然，<a href=https://stackoverflow.com/a/7542261>連 Python 3 也不例外</a>，於是，<strong>generator</strong> 就誕生了。 Generator 基於 iterator 概念之上，利用<del>簡單明瞭</del>的語法，讓建構 iterator 不必這麼痛苦。我們將前一節的例子改成 generator 試試看。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>function</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>genFunc</span> () { <span style=color:#75715e>// `*` 宣告一個 generator function，即是 iterator factory
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
  <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
    <span style=color:#66d9ef>yield</span> <span style=color:#f92672>++</span><span style=color:#a6e22e>v</span> <span style=color:#75715e>// generator function 的 body 內才能使用 `yield` keyword
</span><span style=color:#75715e></span>  }
}

<span style=color:#75715e>// 無限迴圈
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>g</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>genFunc</span>() <span style=color:#75715e>// 產生一個 iterator
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>next</span>() <span style=color:#75715e>// 取得 iterator 下一個 state
</span><span style=color:#75715e></span><span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>done</span>) {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>value</span>)
  <span style=color:#a6e22e>v</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>next</span>()
}
</code></pre></div><p>乍看之下，似乎沒比 iterator 簡單，而且又多了 <code>function*</code> 和 <code>yield</code>，是要嚇死人嗎？這裡的重點並非語法，而是一開始提及的 <a href=https://en.wikipedia.org/wiki/Coroutine>Coroutine</a>概念。這種 coroutine 的概念與一般逐行執行的程式不同，運作流程如下：</p>
<ol>
<li>執行到 <code>yield</code>，暫停。</li>
<li>將執行權交給外部，等待外部 call <code>next</code>。</li>
<li>外部 call <code>next</code>，回到步驟一繼續執行。</li>
</ol>
<p>套在我們的例子中，就是：</p>
<ul>
<li>當每次 <code>genFunc</code> 執行到 <code>yield</code> 時，會停下來，</li>
<li>將程式執行權交給外部 caller，</li>
<li>等到外部調用者再次 call <code>next</code> method，<code>genFunc</code> 再接著執行。</li>
</ul>
<p>簡而言之，<strong>「Generator 是 coroutine 的一種形式，是一個 pause／resume 的執行流程」</strong>。但這樣到底與非同步程式設計有啥鬼關係？</p>
<p>重點在於「透過 coroutine 將程式執行權交給外部 caller」，這可好玩了，如果我們讓 <code>yield</code> 返回一個 promise，程式執行權就會回到 caller 上，而 caller 不僅有程式執行權，可以執行其他程式片段，也可以取得非同步操作的結果。想像中的程式碼長這樣：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 想像中的程式碼
</span><span style=color:#75715e>// fetch 是一個 promise-based 非同步 function
</span><span style=color:#75715e></span><span style=color:#66d9ef>function</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>asyncFunc</span> () {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>yield</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;a&#39;</span>)
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>a</span>)
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>yield</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;b&#39;</span>)
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>b</span>)
}
</code></pre></div><p>看起來非常驚人！可惜這是虛擬的程式碼，<code>a</code>、<code>b</code> 都是一個 Promise，需要利用 <code>then</code> method 取得 resolve value。不過，JS 社群當然不會放過 generator 這個裝逼的好工具，大神們透過各種奇淫巧技，讓我得以利用 generator 優美地寫出 synchronously asynchronous code，以下這個例子便是透過 <code>spawn</code> 自動執行 <code>next</code> 的 helper function 達成。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// Helper Function
</span><span style=color:#75715e>// from: Jake Archibald - JavaScript Promises: an Introduction
</span><span style=color:#75715e></span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>spawn</span> (<span style=color:#a6e22e>generatorFunc</span>) {
  <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>continuer</span> (<span style=color:#a6e22e>verb</span>, <span style=color:#a6e22e>arg</span>) {
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>result</span>
    <span style=color:#66d9ef>try</span> {
      <span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>generator</span>[<span style=color:#a6e22e>verb</span>](<span style=color:#a6e22e>arg</span>)
    } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>err</span>) {
      <span style=color:#66d9ef>return</span> Promise.<span style=color:#a6e22e>reject</span>(<span style=color:#a6e22e>err</span>)
    }
    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>done</span>) {
      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>value</span>
    }
    <span style=color:#66d9ef>return</span> Promise.<span style=color:#a6e22e>resolve</span>(<span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>value</span>).<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>onFulfilled</span>, <span style=color:#a6e22e>onRejected</span>)
  }
  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>generator</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>generatorFunc</span>()
  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>onFulfilled</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>continuer</span>.<span style=color:#a6e22e>bind</span>(<span style=color:#a6e22e>continuer</span>, <span style=color:#e6db74>&#39;next&#39;</span>)
  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>onRejected</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>continuer</span>.<span style=color:#a6e22e>bind</span>(<span style=color:#a6e22e>continuer</span>, <span style=color:#e6db74>&#39;throw&#39;</span>)
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>onFulfilled</span>()
}

<span style=color:#75715e>// 利用 spawn 包裹，自動執行 generator function
</span><span style=color:#75715e>// 這是一個 sequential(serial) operation
</span><span style=color:#75715e></span><span style=color:#a6e22e>spawn</span>(<span style=color:#66d9ef>function</span><span style=color:#f92672>*</span> () {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>yield</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;a&#39;</span>) <span style=color:#75715e>// 等待 fetch(&#39;a&#39;)，並將結果 assign to a
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>a</span>) <span style=color:#75715e>// a 是一個
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>yield</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;b&#39;</span>) <span style=color:#75715e>// 等待 fetch(&#39;b&#39;)，並將結果 assign to b
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>b</span>)
})
</code></pre></div><p>這就是 async generator 的實作，很美，但過程十分嚇人。</p>
<blockquote>
<p>Note：Coroutine（協程）比較明確的定義是，指執行權從一個 coroutine 交至另外一個 coroutine，不過概念上類似，這裡借用一下，特此說明。</p>
</blockquote>
<h2 id=debut-of-async-functions>Debut of Async Functions<a hidden class=anchor aria-hidden=true href=#debut-of-async-functions>#</a></h2>
<p>使用上面這些燒腦的東西，雖達成任務，不過太疊床架屋，抽象概念難以消化。這時候就該主角 <strong>Async Function</strong> 登場！可以將 async functions 想像為 generator + promise，不過更直接的講法是：<strong>「Async Function 是內置 <code>spawn</code> 的 generator function」</strong>。</p>
<p>接下來，將前面使用 <code>spawn</code> 執行的 generator function 改寫成 async function。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 利用 `async` keyword 宣告 一個 async function
</span><span style=color:#75715e></span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>run</span> () {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;a&#39;</span>) <span style=color:#75715e>// 使用 `await` 等待 fetch(&#39;a&#39;)，並將結果 assign to a
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>a</span>)
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;b&#39;</span>) <span style=color:#75715e>// 使用 `await` 等待 fetch(&#39;b&#39;)，並將結果 assign to b
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>b</span>)
}

<span style=color:#75715e>// 執行 async function，不需自己寫 `spawn`，如同正常的 function call。
</span><span style=color:#75715e></span><span style=color:#a6e22e>run</span>()
</code></pre></div><p>Async functions 使用語意清楚的 <code>async</code>／<code>await</code> 取代 <code>function*</code>／<code>yield</code>，除此之外，幾乎與 generator 版本一模一樣。其差異如下：</p>
<ul>
<li>不需額外的 helper function 來執行，一般的 function call 即可。</li>
<li>回傳值為 promise。（相比於 generator 回傳 iterator，async function 復用／組合性較高）</li>
</ul>
<h3 id=usage>Usage<a hidden class=anchor aria-hidden=true href=#usage>#</a></h3>
<p>使用方法如下，非常簡單：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>myAsyncFunc</span> () {
  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>result</span>
  <span style=color:#66d9ef>try</span> { <span style=color:#75715e>// 慣例使用 try-catch 處理錯誤
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetchA</span>() <span style=color:#75715e>// async operation
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetchB</span>() <span style=color:#75715e>// async operation
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> {<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>}
  } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>e</span>) {
    <span style=color:#75715e>// 將 error 吃掉
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`Error occurred: </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>e</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>)
  }
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>result</span>
}
</code></pre></div><h3 id=await>Await<a hidden class=anchor aria-hidden=true href=#await>#</a></h3>
<p><code>await</code> 是用來等待 Promise resolution 的運算子，語法與特性如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript>[<span style=color:#a6e22e>rv</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>expression</span>
<span style=color:#75715e>// rv -&gt; return value of await expression
</span></code></pre></div><ul>
<li>僅能用在 async function 內部。</li>
<li>expression 若是 promise 以外的 value，直接返回該 value</li>
<li>expression 若接 promise object，則等待該 promise resolution。
<ul>
<li>若 promise fulfilled，直接返回該 value。</li>
<li>若 promise rejected，拋出 Error 到 async function context 中（不被 promise 本身吃掉）。</li>
</ul>
</li>
</ul>
<p>這裡要注意的是，<code>await</code> 會等待 promise resolution 後才 return value，所以行為與 synchronous code 一致。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// async arrow function
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fun</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> () =&gt; {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> Promise.<span style=color:#a6e22e>resolve</span>()
  <span style=color:#75715e>// 等待 a 處理完畢，再往下執行
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>process</span>()
  <span style=color:#75715e>// 等待 b 處理完畢，再往下執行
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>process</span>()
  <span style=color:#75715e>// 返回最終的結果 c
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>
}
</code></pre></div><h3 id=return-value>Return Value<a hidden class=anchor aria-hidden=true href=#return-value>#</a></h3>
<p>我們知道，Async function 的 return value 會是一個 promise，那這個 promise 什麼時候會 fulfill，什麼時候會被 reject 呢？</p>
<p>情況其實不複雜，整理如下：</p>
<ol>
<li><code>return</code> 語句會使 async function 直接 resolve，不再往下執行。</li>
</ol>
<ul>
<li>若 <code>return</code> 一個 promise，則以該 promise 為 return value。</li>
<li>若 <code>return</code> 一個非 promise 的 value，則以 <code>Promise.resolve</code> 包裹該 value。</li>
</ul>
<ol start=2>
<li>function context 內部拋出任何 <strong>error</strong>，都會直接 reject，不再往下執行。</li>
</ol>
<p>舉幾個簡單例子：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 直接拋出 Error
</span><span style=color:#75715e>// Return 的 promise 是 rejected 狀態
</span><span style=color:#75715e></span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>throwDirectly</span> () {
  <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#39;Rejected!&#39;</span>)
}

<span style=color:#75715e>// 從 await 表達式中拋出錯誤
</span><span style=color:#75715e>// await 會把 promise 中的 error 向外傳遞到 async function context 中
</span><span style=color:#75715e>// Return 的 promise 是 rejected 狀態
</span><span style=color:#75715e></span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>throwFromAwait</span> () {
  <span style=color:#66d9ef>await</span> Promise.<span style=color:#a6e22e>reject</span>(<span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#39;Rejected!&#39;</span>))
}

<span style=color:#75715e>// 透過 try-catch 處理錯誤，錯誤不繼續傳遞
</span><span style=color:#75715e>// Return 的 promise 不會被 reject
</span><span style=color:#75715e></span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>handleError</span> () {
  <span style=color:#66d9ef>try</span> {
    <span style=color:#66d9ef>await</span> Promise.<span style=color:#a6e22e>reject</span>(<span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#39;Rejected!&#39;</span>))
  } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>e</span>) {
    <span style=color:#75715e>// Explicitly swallow errors
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>`Got error: </span><span style=color:#e6db74>${</span><span style=color:#a6e22e>e</span><span style=color:#e6db74>}</span><span style=color:#e6db74>`</span>)
  }
}

<span style=color:#75715e>// 利用其他流程控制語句，達到 early return 的效果
</span><span style=color:#75715e></span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>earlyReturn</span> () {
  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>someRuleFulfill</span>) {
    <span style=color:#75715e>// 直接 return value，外部會收到 `Promise.resolve(&#39;Return Value&#39;)`
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;Return Value&#39;</span>
  }
  <span style=color:#75715e>// 由於原本即是 return a promise，所以不需使用 `await` 等待結果
</span><span style=color:#75715e></span>  <span style=color:#75715e>// No need to: `return await heavyAsyncProcess()`
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>heavyAsyncProcess</span>()
}
</code></pre></div><p>看完範例，我們可以得知 Async function 的錯誤處理模式與一般的 function 如出一轍，即「由 context 的執行情形來決定何時 return，何時該 throw Error」。</p>
<p>另外，Async function 的 return value 與 Error 傳到 caller context 時會以 promise 包裹。不會讓整個 call frame 掛掉，但也如同 promise 對錯誤比較 silent，所以再次提醒，慣例會在 async function 內部透過 <strong>try-catch</strong> 處理錯誤，不讓錯誤傳遞過遠，好比 promise 最後必會掛個 catch 處理錯誤。</p>
<h3 id=declarations>Declarations<a hidden class=anchor aria-hidden=true href=#declarations>#</a></h3>
<p>Async function 既然是 function，想必有許多不同的宣告方式，在此將常用的方式列出來。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// function declaration
</span><span style=color:#75715e></span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>asyncFunc</span> () {}

<span style=color:#75715e>// IIFE (Immediately Invoked Function Expression)
</span><span style=color:#75715e></span>(<span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> () {<span style=color:#75715e>/* ... */</span>}())

<span style=color:#75715e>// ES6 Arrow Function
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>myAsync</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> () =&gt; {}

<span style=color:#75715e>// An object props
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>obj</span> <span style=color:#f92672>=</span> {
  <span style=color:#66d9ef>async</span> <span style=color:#a6e22e>myAsync</span> () {},
  <span style=color:#a6e22e>otherProp</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1234</span>
}

<span style=color:#75715e>// A method of a class
</span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span> {
  <span style=color:#66d9ef>async</span> <span style=color:#a6e22e>myAsync</span> () {}
}
</code></pre></div><h2 id=advanced-usage>Advanced Usage<a hidden class=anchor aria-hidden=true href=#advanced-usage>#</a></h2>
<h3 id=sequential-operation>Sequential Operation<a hidden class=anchor aria-hidden=true href=#sequential-operation>#</a></h3>
<p>還記得<a href=https://weihanglo.github.io/posts/2017/javascript-concurrency-promise/>上一篇文章</a>，我們利用 <code>Array#reduce</code> 與 <code>Array#forEach</code> 實作 serial operation 嗎？雖然 promise + functional programming 看起來很有逼格，但又多了一層抽象理解層次。藉由 async function <code>await</code> 的特性，我們可以寫出很直觀 sequential operations，避開那些 hack。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 直觀的同步操作，每個 await 皆會等 promise resolution 再往下執行
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>processInSequence</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> (<span style=color:#a6e22e>url</span>) =&gt; {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>resA</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>getAsyncResult</span>(<span style=color:#e6db74>&#39;a&#39;</span>)
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>resB</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>getAsyncResult</span>(<span style=color:#e6db74>&#39;b&#39;</span>)
  <span style=color:#66d9ef>return</span> {<span style=color:#a6e22e>resA</span>, <span style=color:#a6e22e>resB</span>}
}
</code></pre></div><p>透過 <code>for</code> loop，也可達成 sequential 的效果。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 利用 for loop，iterate 所有 url，逐一等待 promise resolution
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fetchInSequence</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> <span style=color:#a6e22e>urls</span> =&gt; {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> []
  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>url</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>urls</span>) {
    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>res</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>url</span>)
    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>json</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>()
    <span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>json</span>)
  }
}
</code></pre></div><h3 id=parallel-operation>Parallel Operation<a hidden class=anchor aria-hidden=true href=#parallel-operation>#</a></h3>
<p>如果 <code>await</code> 會阻塞該 context（正確說來是轉移執行權），那我如何設計 parallel operation 呢？</p>
<p>非常簡單，那就提前讓 promise 開始執行嘛！</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 平行執行兩個 promise
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>operationInParallel</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> () =&gt; {
  <span style=color:#75715e>// 不加 await，一次執行兩個 promise
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>pA</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>getAsyncResult</span>(<span style=color:#e6db74>&#39;a&#39;</span>)
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>pB</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>getAsyncResult</span>(<span style=color:#e6db74>&#39;b&#39;</span>)
  <span style=color:#75715e>// 加上 await，耐心等待 promise 的結果
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>resA</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>pA</span>
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>resB</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>pB</span>
  <span style=color:#66d9ef>return</span> [<span style=color:#a6e22e>resA</span>, <span style=color:#a6e22e>resB</span>]
}
</code></pre></div><p>自幹兩個 promises 很不直觀？不然我們改用 <code>Promise.all</code>。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 使用 Promise.all await 多個 promises
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>promiseAllInParallel</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> () =&gt; {
  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>await</span> Promise.<span style=color:#a6e22e>all</span>([
    <span style=color:#a6e22e>getAsyncResult</span>(<span style=color:#e6db74>&#39;a&#39;</span>),
    <span style=color:#a6e22e>getAsyncResult</span>(<span style=color:#e6db74>&#39;b&#39;</span>)
  ])
}
</code></pre></div><p>蛤！<code>Promise.all</code> 又出現了！使用 async function 不就是為了拋棄 promise 嗎？很抱歉，在有更清楚的語言特性出現前，只能選擇這種方式，畢竟 async funciton 整個 tech stack 就是建立於 promise 之上。</p>
<p>如果是多個 promise，也可以利用 <code>Array#map</code> 建立新的 context（function scope）來實作 parallel operation，這種方式看起來也稍微 hack，不過仍是本著 async function 的概念。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 利用 `Array#map` 實作 parallel operations
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fetchInParallel</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> <span style=color:#a6e22e>urls</span> =&gt; {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>jsonPromises</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>urls</span>.<span style=color:#a6e22e>map</span>(<span style=color:#66d9ef>async</span> <span style=color:#a6e22e>url</span> =&gt; { <span style=color:#75715e>// 建立新的 async function context
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>res</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>rul</span>) <span style=color:#75715e>// await 只會在這個 context 內等待
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>()
  })
  <span style=color:#75715e>// 我們可以按順序地印出結果
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>jsonPromise</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>jsonPromises</span>) {
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#66d9ef>await</span> <span style=color:#a6e22e>jsonPromise</span>) <span style=color:#75715e>// 等待個別 promise resolution
</span><span style=color:#75715e></span>  }
}
</code></pre></div><h3 id=promiserace>Promise.race<a hidden class=anchor aria-hidden=true href=#promiserace>#</a></h3>
<p>想模擬 <code>Promise.race</code>，該如何實作？就直接用 <code>Promise.race</code> 吧。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>getFirstResolutionInParallel</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> <span style=color:#a6e22e>urls</span> =&gt; {
  <span style=color:#75715e>// 利用 Promise.race 取得第一個 resolution (either reject or fulfill) 的 promise
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> Promise.<span style=color:#a6e22e>race</span>(<span style=color:#a6e22e>urls</span>.<span style=color:#a6e22e>map</span>(<span style=color:#66d9ef>async</span> <span style=color:#a6e22e>url</span> =&gt; {
    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>res</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>url</span>)
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>()
  }))
}
</code></pre></div><h3 id=first-fulfillment>First Fulfillment<a hidden class=anchor aria-hidden=true href=#first-fulfillment>#</a></h3>
<p>在前一篇 Promise 文章中，我們 invert <code>onRejected</code> <code>onFulfilled</code> 兩個 callback，取得首個 fullfillment result。那在 async function 該如何實作呢？</p>
<p>當然，我們可以直接拿 Promise 做一樣的事，不過時代在走，人要進步，讓我們嘗試使用 <code>try-catch</code> 吧！</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// from Stackoverflow https://stackoverflow.com/a/39941616
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>invert</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>p</span> =&gt; <span style=color:#66d9ef>new</span> Promise((<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>rej</span>) =&gt; <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>rej</span>, <span style=color:#a6e22e>res</span>))

<span style=color:#75715e>// 利用 try catch 實作 get first fullfillment（但仍須借助 Promise 的 API）
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>firstFulfillmentInParallel</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> <span style=color:#a6e22e>urls</span> =&gt; {
  <span style=color:#66d9ef>try</span> {
    <span style=color:#66d9ef>await</span> Promise.<span style=color:#a6e22e>all</span>(
      <span style=color:#a6e22e>urls</span>.<span style=color:#a6e22e>map</span>(<span style=color:#66d9ef>async</span> <span style=color:#a6e22e>url</span> =&gt; {
        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>res</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>url</span>)
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>json</span>()
      }).<span style=color:#a6e22e>map</span>(<span style=color:#a6e22e>invert</span>)
    )
  } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>e</span>) {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>e</span> <span style=color:#75715e>// 直接返回 inversion 的 fulfillment
</span><span style=color:#75715e></span>  }
}
</code></pre></div><p>雖然有達到目的，但 fulfillment 卻是從 <code>catch</code> block 返回，實作漸漸不直觀了。</p>
<h2 id=async-interation>Async Interation<a hidden class=anchor aria-hidden=true href=#async-interation>#</a></h2>
<p>我們知道，async function 原理上是 generator 的 syntax sugar，利用 iterator 與 <code>yield</code> 轉換控制權，達成 asynchronous operation 效果，但是 <code>iterator.next</code> 這個 method 卻只有 synchronous 版本，有些場景（例如 streaming）需要非同步的 iterator 來取得 streaming data，這時候就該 <strong>async interator</strong> 出場了。</p>
<p><a href=https://github.com/tc39/proposal-async-iteration>這個提議</a>目前已在 Stage 3 了，即將納入標準，可以開始瞭解它了。</p>
<p>話不多說，附上提議的範例程式碼，感受一下吧！</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// for-await-of loop
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> <span style=color:#66d9ef>await</span> (<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>line</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>readLines</span>(<span style=color:#a6e22e>filePath</span>)) {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>line</span>);
}

<span style=color:#75715e>// Async generator functions
</span><span style=color:#75715e></span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>readLines</span>(<span style=color:#a6e22e>path</span>) {
  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>file</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>fileOpen</span>(<span style=color:#a6e22e>path</span>);

  <span style=color:#66d9ef>try</span> {
    <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>EOF</span>) {
      <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>readLine</span>();
    }
  } <span style=color:#66d9ef>finally</span> {
    <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>close</span>();
  }
}
</code></pre></div><h2 id=further-reading>Further Reading<a hidden class=anchor aria-hidden=true href=#further-reading>#</a></h2>
<p>比起 promises，async functions 相對沒這麼多文獻供參考，想要入門，依然推薦阮大大的 <a href=http://es6.ruanyifeng.com/#docs/async>ECMAScript 6 入门：async 函数</a>，真的是非常豐富的 ES6 大全。當然，<a href=https://developers.google.com/web/fundamentals/getting-started/primers/async-functions>Google Web Fundamentals</a> 也值得一看，但沒有 Promise 篇含金量這麼高就是了。</p>
<p>Medium 上也有許多作者在評論 async functions，<a href=https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9>Hacker Noon 這篇推坑文</a>比較了 promise 與 async function 的優劣，算是蠻清楚的入門文，看看 async function 是否符合妳的期待。另外，也有人寫了不少篇<del>批判</del>反思 async function 的文章，<a href=https://medium.com/@bluepnume/learn-about-promises-before-you-start-using-async-await-eb148164a9c8>這篇告訴你還是需要理解 promise</a> 才能以正確的姿勢使用 async／await，另一篇則告訴你，<a href=https://medium.com/@bluepnume/even-with-async-await-you-probably-still-need-promises-9b259854c161>promise 還是比較厲害</a>的啦。</p>
<p>當然，沒有任何 unit tests，就算程式碼可讀性再高，仍然非常脆弱，所以，別花太多時間看這些新技術，乖乖地補上缺漏的 tests 比較實在 XD。</p>
<h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2>
<ul>
<li><a href=https://developer.mozilla.org/>Mozilla Developer Network</a></li>
<li><a href=https://developers.google.com/web/fundamentals/getting-started/primers/async-functions>Google Web Fundamentals: Async functions - making promises friendly</a></li>
<li><a href=http://es6.ruanyifeng.com/#docs/generator-async>ECMAScript 6 入门：Generator 函数的异步应用</a></li>
<li><a href=http://es6.ruanyifeng.com/#docs/async>ECMAScript 6 入门：async 函数</a></li>
<li><a href=https://medium.com/@bluepnume/learn-about-promises-before-you-start-using-async-await-eb148164a9c8>Daniel Brain: Understand promises before you start using async/await</a></li>
<li><a href=https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9>Haker Noon: 6 Reasons Why JavaScript’s Async/Await Blows Promises Away</a></li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://weihanglo.tw/tags/javascript/>JavaScript</a></li>
<li><a href=https://weihanglo.tw/tags/concurrency/>Concurrency</a></li>
<li><a href=https://weihanglo.tw/tags/async-function/>Async Function</a></li>
<li><a href=https://weihanglo.tw/tags/generator/>Generator</a></li>
<li><a href=https://weihanglo.tw/tags/front-end/>Front-end</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://weihanglo.tw/posts/2017/days-with-internet-explorer/>
<span class=title>« Prev</span>
<br>
<span>與 IE 相處的日子</span>
</a>
<a class=next href=https://weihanglo.tw/posts/2017/javascript-concurrency-promise/>
<span class=title>Next »</span>
<br>
<span>現代化的 JavaScript 併發 - Promises</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>CC BY-NC-SA 4.0</span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>