<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>大前端時代的工具箱 | Weihang Lo</title>
<meta name=keywords content="Node.js,JavaScript,Front-end">
<meta name=description content="在大前端的時代，開發 Web app 不再像以前使用一個 jQuery 的 CDN 這麼容易，從 html 模板的抉擇，css 預處理器的挑選，Javascript 模組化的方法，自動化工具">
<meta name=author content>
<link rel=canonical href=https://weihanglo.tw/posts/2017/fed-toolchain/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://weihanglo.tw/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://weihanglo.tw/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://weihanglo.tw/favicon-32x32.png>
<link rel=apple-touch-icon href=https://weihanglo.tw/apple-touch-icon.png>
<link rel=mask-icon href=https://weihanglo.tw/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:!0},{left:'$',right:'$',display:!1},{left:'\\(',right:'\\)',display:!1},{left:'\\[',right:'\\]',display:!0}],throwOnError:!1})})</script>
<meta property="og:title" content="大前端時代的工具箱">
<meta property="og:description" content="在大前端的時代，開發 Web app 不再像以前使用一個 jQuery 的 CDN 這麼容易，從 html 模板的抉擇，css 預處理器的挑選，Javascript 模組化的方法，自動化工具">
<meta property="og:type" content="article">
<meta property="og:url" content="https://weihanglo.tw/posts/2017/fed-toolchain/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2017-03-10T15:36:46+08:00">
<meta property="article:modified_time" content="2017-03-10T15:36:46+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="大前端時代的工具箱">
<meta name=twitter:description content="在大前端的時代，開發 Web app 不再像以前使用一個 jQuery 的 CDN 這麼容易，從 html 模板的抉擇，css 預處理器的挑選，Javascript 模組化的方法，自動化工具">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://weihanglo.tw/posts/"},{"@type":"ListItem","position":3,"name":"大前端時代的工具箱","item":"https://weihanglo.tw/posts/2017/fed-toolchain/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"大前端時代的工具箱","name":"大前端時代的工具箱","description":"在大前端的時代，開發 Web app 不再像以前使用一個 jQuery 的 CDN 這麼容易，從 html 模板的抉擇，css 預處理器的挑選，Javascript 模組化的方法，自動化工具","keywords":["Node.js","JavaScript","Front-end"],"articleBody":"在大前端的時代，開發 Web app 不再像以前使用一個 jQuery 的 CDN 這麼容易，從 html 模板的抉擇，css 預處理器的挑選，Javascript 模組化的方法，自動化工具的使用等等，都是一門學問。本文將從建置基本的前端開發環境起頭，簡單介紹個人愛用現代常用的前端開發工具。\n（撰於 2017-03-10）\nContents  Node.js  安裝 Node.js Node.js 內建模組與變數 Node.js 版本管理工具   NPM 套件模組管理工具  package.json NPM 常用指令   預處理器／轉譯器  CSS 預處理器 CSS 後處理器 ES6+／Babel   自動化工具／打包工具  Gulp Webpack   程式碼品質  測試 靜態程式語法檢查   小結 Reference  （以下環境皆以 macOS 為例）\nNode.js Node.js 是一個 Javascript 的運行環境，基於 Google V8 Engine。在 Node.js 尚未出現前，Javascript 只能運行在瀏覽器客戶端，功能受限於瀏覽器沙盒（sandbox）與廠商實作。Node.js 推出後，Javascript 程式碼可以在伺服器端運行，模組（module）和套件（package）的觀念和生態圈也隨之建立。程式碼的交流／複用更為便利。\n安裝 Node.js 在 macOS 安裝 Node.js 非常簡單，在終端環境輸入指令來安裝最新版的 Node.js：\n# The latest version of Node.js brew install node # 檢查是否安裝成功（成功則顯示最新版本版號） node -v ### v7.7.1 同時 Node.js 也附帶如同 python、irb 的直譯式互動環境（REPL）可快速測試／開發一些功能。\n# 進入 REPL 環境 node # -- REPL 環境 --  1 + 2 ### 3  'cat,mouse,dog'.split(/,/) ### [ 'cat', 'mouse', 'dog' ] Node.js 內建模組與變數 Node.js 提供豐富的原生模組，可以操作 filesystem、socket、os 等系統層的 API，讓 Javascript 躋身至與 Python、Ruby 之流同樣地位，成為流行的腳本語言（scripting language）。這裡列出前端開發者較常使用的幾個模組：\n os：作業系統相關的操作與資訊 fs：檔案系統的操作（移動／刪除／新增／檔案監控） path: 路徑相關工具模組（path resolve/join/pase/normalize） assert：斷言模組，通常與其他測試框架配合 child_process：產生子行程（進程）的模組，開發較複雜的自動化工具才會用到。  另外，Node.js 同時提供許多重要的全域（Global）物件與函式，在全域下（Global Scope）皆可取得。\n global：node 運行環境最上層的物件，類似瀏覽器端 window 的存在。 process：記錄當前 node 運行環境的所有資訊。一般配合設置 NODE_ENV 環境變數來區別不同的開發階段。 __dirname：模組所在目錄的名稱。實際上非全域物件，而是各模組皆有的變數。 __filename：模組的檔案名，Node.js 世界，一個檔案為一個模組。實際上非全域物件，而是各模組皆有的變數。 require()：用來引入（import）其他模組的函式。實際上非全域物件，而是各模組皆有的 method。 module：Node.js 遵循 CommonJS 定義的「模組」模組，最常用到 module.exports 變數，這個變數會指向欲 export 的物件。   Node.js 模組 import／export 稍微複雜，可以參考用法教學、深入講解 require，或是直接閱讀官方文件。\n  模組化的實作規範在 Javascript 界可謂群魔亂舞，所以 ECMA 2015 (ES6) 提出新的模組化 API（imports／exports），未來甚至可在瀏覽器端使用。目前可透過 Babel 轉譯器的外掛搶先體驗。\n Node.js 版本管理工具 蓬勃社群使得 Node.js 不斷精進，但也帶來軟體工程最痛苦的「版本相容」問題。許多時候，我們需要在最新的 Node 版本中測試新功能，但仍需要維護依賴舊版的專案。在不同 Node 版本環境間切換成本不低，幸虧有牛人寫了易用的版本管理工具 nvm 與 n，讓版本切換變得輕鬆愉快。\n以下主要介紹 nvm 的特色、安裝與簡易用法。nvm 的特色如下：\n 使用 shell script 寫成，無其他相依模組／環境。 每個不同版本的 node 有自己的 global modules 環境，不互相影響。 更新至新版時，一行指令就可以重新安裝相同的 global packages。  總之，先開啟你的終端機吧！\n# 透過 homebrew 安裝 nvm（macOS） brew install nvm # 在使用者家目錄下，新增一個 .nvm 的工作目錄 mkdir ~/.nvm # 使用預設編輯器開啟 ~/.bash_profile $EDITOR ~/.bash_profile 在你預設（或者你最喜愛）的編輯器裡，將下列兩行設定加入 .bash_profile 中：\n# 將下列設定加在 .bash_profile 中，讓 shell 讀取 nvm 設定 export NVM_DIR=\"$HOME/.nvm\" . \"/usr/local/opt/nvm/nvm.sh\" 離開編輯器，回到終端機畫面。\n# 檢查設定是否正確 echo $NVM_DIR ### /Users/weihanglo/.nvm # 重新讀取 .bash_profile，讓剛剛的設定生效 source ~/.bash_profile 現在可以開始安裝不同版本的 node 了！\n# 安裝最新版的 Node.js nvm install node # 安裝／移除特定版本 nvm install v6.9.0 nvm install v7.6.0 nvm uninstall node # 設定預設使用的版本 nvm alias default v7.6.0 # 切換至其他版本 nvm use v7.6.0 # or nvm use default # 列出 local 已經安裝的版本 nvm ls ### v6.9.0 ### - v7.6.0 ### default - v7.6.0 # 安裝新版 Node.js，並從其他版本安裝相同的 packages／modules nvm install v7.7.1 --reinstall-packages-from=v7.4.0  使用 nvm 至今，個人唯一詬病的是 script 體積較大，拖慢 shell startup time，社群有人發現此問題，並提出解法。我稍作修改，去蕪存菁，只讀取 default version 的 binary，略提升 startup 時間（畢竟敝人的 .bashrc 已不瘦了），這段 script 提供大家參考。\n NPM 套件模組管理工具 常言道，成功的程式語言背後，有個支持它的生態圈。Python／R 透過科學與統計的模組生態，在資料科學界中獨霸一方；Docker 把 Go 語言從鬼門關前救回，Go 因此成為 Container 界的王者；Node.js／Javascript 則是藉由方便易用的 npm，讓才華洋溢的宅男工程師們盡情交流，創造出成千上萬個模組。\n以下列出 npm 的特色：\n 為 Node.js 預設的套件管理工具，安裝 Node.js 會一併安裝 npm。 npm, Inc 提供套件伺服器 npm Registry 供開發者上傳／下載套件。（截止 2017.3.9 有 43 萬餘套件）。 提供 package.json 供使用者管理專案的相依模組／套件。 根據 package.json 的設定，進行更複雜的任務，如 test runner、build tool、watch file changes。  package.json package.json 是一個 Node.js 模組最重要的檔案，記錄與此模組相關的設定，部分第三方套件的配置文件也可以寫在 package.json 裡，減少 project 設定檔過多的問題（例如：babel、browserslist）。\n合法的 package.json 除了要是一個 JSON 格式檔案之外，還必須包含下列兩個重要的 fields：\n name：模組名稱，也是import 模組時的名稱。在 npm Registry 通常是以相同或近似的名稱註冊，命名慣例以-（hyphen）取代 camelCase。 version：模組目前的版號，npm 遵循語意化版號的標準，減少套件更新異動造成的問題。  其他重要且建議填寫的 fields 有：\n main：程式進入點，也是模組進入點（該檔案的 module.exports），慣例為 index.js 或 main.js。 devepdencies：該模組直接相依的第三方模組。規範採用語意化版號標準。 devDependencies： 該模組開發時會使用到相依模組，例如測試模組、打包模組。規範採語意化版號標準。 scripts：自定義的 shell 腳本。可透過 npm run  執行。 license：模組的授權條款，建議填寫。 bin：若模組有提供指令列程式，需在此配置指令名稱與對應檔案。  在此概述常用的版號語法：\n 1.2.3：指定使用版號 1.2.3 1.2.3：接受版號大於 1.2.3 =1.2.3：接受版號大於等於 1.2.3 ~1.2.3：接受 patch version，同義於 =1.2.3  ^1.2.3：只接受 minor version 或 non-breaking changes，同義於 =1.2.0  *：接受任何版號。   ~（tilde）與 ^（caret）, 在版號寫法不同時，有不同結果，請參考 node-semver 官方文件。\n 一個合法的 package.json 範例：\n{ \"name\": \"electron-react-demo\", // 模組名稱，以 hyphen 取代 camelCase  \"version\": \"0.0.1\", // 當前版號  \"description\": \"A Electron Demo with React\", // 模組簡介  \"main\": \"main.js\", // 程式進入點／模組進入點  \"scripts\": { // 自定義腳本  \"start\": \"electron .\" // 輸入 `npm run start` 或 `npm start` 時會執行的腳本  }, \"author\": \"Weihang Lo\", // 作者欄位  \"license\": \"MIT\", // 授權／版權條款  \"dependencies\": { // 直接相依的模組  \"react\": \"~15.4.1\", // 使用 patch version 的 react  \"react-dom\": \"~15.4.1\" }, \"devDependencies\": { // 開發用的模組  \"babel-preset-es2015\": \"^6.18.0\", // 版號 = 6.18.0 但小於  \"babel-preset-react\": \"^6.16.0\", \"electron\": \"1.4.12\", // 使用指定版號的 electron  \"mocha\": \"*\", // 使用最新／任意版本。  \"chai\": \"*\" } } 還有許多沒介紹到的 package.json 設定，在 npm 官方文件 裡應有盡有！\nNPM 常用指令 npm 的指令列程式提供許多功能，其中最重要的兩類即是模組和執行腳本相關的指令。\n安裝／移除／更新／列出 相依模組\n npm install [--global] [--save] [--save-dev] npm uninstall [--global] [--save] [--save-dev] npm ls [--global] [--depth=] npm update [--global]  開始介紹前，先了解 npm 安裝模組的模式，分為 全域模式（globally） 與 本地模式（locally）\n 全域模式 --global：安裝的模組通常是常用的指令列程式，例如 npm 本身。 本地模式：用來安裝與 project 相依的模組，會在 project 根目錄產生一個 node_modules 存放相依模組。  # 創建一個 npm 模組環境（互動式產生 package.json） npm init # 尋找同目錄下的 `package.json`，安裝該檔案內記錄的相依套件 npm install # 安裝 axios 套件，不儲存相依關係。 npm install axios # 安裝 bluebird 套件，並將相依版號寫入 `package.json` 的 `dependencies` field 中 npm install bluebird --save # 安裝 mocha、chai 套件，並將相依版號寫入 `package.json` 的 `devDependencies` field 中（開發用套件） npm install mocha chai --save-dev # 安裝 Globally 的套件，在任何目錄都可直接使用該模組的指令列程式 npm install --global yarn # 移除 bluebird 套件，並從 `package.json` 中移除相依關係 npm uninstall bluebird --save # 列出 locally（project-wide） 的套件到第一階層（專案的相依套件的相依套件） npm ls --depth=2 # 列出全域安裝的套件（只列出 user 直接安裝的套件） npm ls --global --depth=0 # 更新 bluebird 套件至 package.json 內的指定版號 npm update bluebird # 更新 package.json 記錄的套件至指定版號 npm update # 更新所有全員安裝的套件 npm update --global  Facebook、Google 幾個大頭在 2016 年 10 月 開源了新一代的 Node.js 套件管理工具 Yarn，在速度、體驗、介面上皆略勝 npm 一籌。Yarn 也會自動產生 yarn.lock 檔案，精確記錄相依模組的版號，在套件管理上更安全安心，有興趣的童鞋可嘗試看看。\n 執行自定義腳本\n npm run  [-- ...]  用來執行 package.json 的 scripts field 中的自定義腳本。在執行開始前，npm run 會在既有的 PATH 環境變數加上 node_modules/.bin，許多套件提供的 binary 執行檔可以直接執行，不需要再加上 ./node_modules/.bin/a-command 等冗長的相對路徑。因此，npm run 常作為 task/test runner、build tools 的入口。\n# 在 `package.json` 裡 { \"scripts\": { \"start\": \"echo 'Start my node.js app'\", \"fail\": \"echo \\\"Oops! Failed on $1\\\"\", \"serve\": \"serve\" } } # 回到終端環境，先安裝相依套件 npm install serve # 等同於執行 `./node_modules/.bin/serve`，開啟一個 local http server npm run serve ### Serving! # `--` 可傳入參數等，同執行 `echo 'Oops! Failed $1` npm run fail -- Example ### Oops! Failed on Example # `start`、`test`、`restart` 等 script 可不透過 `run`，直接使用簡寫執行 npm run start ### Start my node.js app npm start ### Start my node.js app 除了上述 npm 還有許多功能，族繁不及備載，詳情請參考 npm - Cli Commands。有關 npm run-script，也可以瞧瞧這篇教學。\n預處理器／轉譯器 雖然 Node.js／npm 為 Javascript 生態圈帶來前所未有的繁榮盛況，但前端的世界還是處處充滿危機，不同瀏覽器廠商的實作參差不齊，開發者常搞不清楚可以用哪些 CSS 與 Javascript 的 features，開源社群為了消弭這些惱人的問題，開發出許多協助開發者的預處理器／轉譯器（transpiler）。\n 預處理器／轉譯器屬於 source-to-source compiler，雖然可以加速開發，但也需要引入 build tools 協助轉換語法，有關 build tools／task runner，會在自動化工具／打包工具與各位分享。\n CSS 預處理器 CSS 對程序猿來說，沒有繼承，沒有函式，沒有變數，全部的設定都在 global scope，完全符合設計不良的語言特性。有志青年打造了許多類似 CSS 的語言，提供變數、函式、mixin，再 compile 成 vanilla CSS，讓寫 CSS 能夠更輕鬆，更能專注商業邏輯。這些方便的工具我們通稱 CSS Preprocessor。\n目前主流的 CSS Preprocessor 有 Less、Sass，以及 Stylus 等，每一套都有各自的擁護者，在此簡單比較 Sass 與 vanilla CSS，給客倌看看。\nVanilla CSS（同一個 nav 下的元素要分為三個 block 撰寫，且相同的 padding 要寫兩次）\nnav ul { margin: 0; padding: 0; list-style: none; } nav li { padding: 6px 12px display: inline-block; } nav a { display: block; padding: 6px 12px; text-decoration: none; } Sass（SCSS syntax）支援 variable 與 nested element selector\n$my-vertical-padding: 6px; $my-horizontal-padding: 12px; nav { ul { margin: 0; padding: 0; list-style: none; } li { display: inline-block; padding: $my-vertical-padding $my-horizontal-padding; } a { display: block; padding: $my-vertical-padding $my-horizontal-padding; text-decoration: none; } }  Sass 是 Ruby 社群發展出來的 CSS 預處理器，在 Javascript 界通常使用 node-sass 做 CSS transform。Sass 是個人非常喜愛的 CSS 預處理器。\n CSS 後處理器 對前端開發者來說，最痛苦的莫過於在 Chrome 切好 layout，卻在 Safari 跑版。在 Firefox 做 css animation，卻在 Safari 動彈不得。這些問題來自於各瀏覽器實作不同，添加的 vendor prefix 也不一樣，我們可以透過 Sass 的 mixin 來解決 prefix 問題，但這不夠 fancy，CSS 後處理器概念營運而生，最有名的莫過於 postcss 的 Plugin autoprefixer，在 CSS 預處理器 compile 完成之後，需要的 property 加上 vendor prefix，完全不需要再寫一丁點 mixin。\n 順水推舟，postcss 是個生態豐富的 css transforming plugin system，許多瀏覽器未實作的 feature，透過 plugin 轉換，就可以使用各種 feature了。\n ES6+／Babel Javascript 從出生到現在，一直是個被人嫌棄的語言，弱型別，隱式轉換，缺乏真正物件導向概念（只有 prototype oriented），變數可重複宣告，this 的語意更讓人摸不著頭緒。近年來，ECMAScript 的標準不斷往前走，加入了 作用域變數 scope variable（let）、常數宣告 constant declaration（const），自動綁定 this 的 arrow function，甚至原生的 class 等語言新特性。徹底改造整個 Javascript 的生態圈。\n可惜又面臨同個問題，目前的瀏覽器／Node.js 環境不一定支援。社群又跳出來，寫了名為 Babel（借用巴別塔的典故）的 transpiler，將最新的 Javascript 語法，轉換成當前瀏覽器相容的語法。透過 Babel，我們可歡樂地使用 ES6 的 class，不必擔心 IE 會 crash 了！\n以下介紹 Babel 的簡易設定：\n# 在你的專案目錄底下安裝 babel 套件 npm install --save-dev babel-cli babel-preset-env # 使用預設編輯器開啟 .babelrc（Babel 設定檔） $EDITOR ~/.bash_profile 在你預設（或者你最喜愛）的編輯器裡，將下列設定加入 .babelrc（Babel 設定檔） 中：\n# 在 .babelrc 中加入下列設定 { \"presets\": [\"env\"] } 接下來利用你喜愛的 task runner，把你的 code compile 成瀏覽器相容的 javascript 吧！\n Babel 提供許多不同的預處理器（presets），例如 es2015、es2017，env 是目前 Babel 官方推薦的 presets，可以透過設定 browserslist，依據不同生產環境決定哪些語法需要轉換，autoprefixer 與 eslint 同樣也支援 browserslist。\n  另一個有名且有前景的轉譯器是微軟出品的 TypeScript，支援繼承、抽象介面、裝飾器、型別檢查等 features，現代語言該有的應有盡有。由於是 Javascript 的 superset，在 TypeScript 裡寫 Javascript 完全合法，且 Google 的 Angular Framework，以及有名的 Reactive Programing Libary RxJS 也都採用 TypeScript。值得一試！\n 自動化工具／打包工具 使用這麼多預處理器／轉譯器／自定義腳本，如果每次都需要自己 npm run compile、babel script.js 豈不麻煩？為了減少重複性的任務（task），Javascript 生態圈發展出數套實用的 build tool／system，老牌的 Grunt 與較年輕的 Gulp，這裡選擇使用 Gulp。\n另外，當我們想使用 npm 上的各種模組，卻很難直接在瀏覽器端引入這些 dependencies。打包工具如 Browserify 與 Webpack 提供我們將這些散落各處的 .js、.css、.html 打包起來的方法，便於 import 到瀏覽器客戶端。這裡主要介紹 Webpack。\nGulp Gulp 是一個直觀易懂的 build system，其概念是利用 Node.js 的 stream API，有如 pipeline 般將檔案傳遞到每個 plugin／transformer 中做對應的任務。而 Gulp 也有豐富的 plugin 生態系，提供許多主流預處理器的 plugin，讓結果如同 stream 一樣容易產出。\n以下簡單示範 gulp 安裝與用法：\n# 1. 首先先安裝 Global gulp command-line tool npm install --global gulp-cli # 2. 接著在 project 將 gulp 安裝為 devDependencies npm install --save-dev gulp 在 project root 新增 gulpfile.js，並寫入這些設定：\n// 3. gulpfile.js at project root var gulp = require('gulp'); gulp.task('default', function() { // 你的預設 task }); 回到終端環境：\n# 4. 輸入 `gulp`，執行預設的 task： gulp ### [14:20:30] Using gulpfile ~/Documents/gulp-demo/gulpfile.js ### [14:20:30] Starting 'default'... ### [14:20:30] Finished 'default' after 361 μs Gulp 本身的 API 不多，語法也很簡單，這邊舉例並說明 gulpfile.js 實例：\n// 確認有先安裝相依的 babel 套件 與 del 套件 // `npm install --save-dev gulp-babel babel-preset-env del`  var gulp = require('gulp'); // import gulp 套件（必須） var babel = require('gulp-babel'); // import gulp-babel 插件 var del = require('del'); // import del 套件（用來 cleanup output）  gulp.task('babel', function () { // 建立一個叫做 babel 的任務  gulp.src('src/**/*.js') // `gulp.src` 會讀取給定路徑（src 下所有 js 檔）的檔案  .pipe(babel({ presets: ['env'] })) // 將上一步的檔案 pipe 給 babel plugin 處理  .pipe(gulp.dest('dist')); // 將上一步的檔案透過 `gulp.dest` 輸出到給定路徑（dist） }); gulp.task('clean', function () { // 建立一個叫做 clean 的任務  del(['dist']); // 使用 `del` 套件，刪除輸出的目錄 (dist) }); gulp.task('default', ['clean'], function () { // 建立預設任務，並設 clean 為相依任務（在該任務執行前執行）  gulp.watch('src/**/*.js', ['babel']); // 使用 `gulp.watch` 監視檔案異動，有異動就執行 babel 任務 }); 在終端環境下，我們這樣做：\n# 先寫一個假的 ES6 js file mkdir src echo \" (() = console.log('Hello, world!'))() \"  src/demo.js # 執行 babel 任務 gulp babel ### [14:42:23] Using gulpfile ~/Documents/gulp-babel-demo/gulpfile.js ### [14:42:23] Starting 'babel'... ### [14:42:23] Finished 'babel' after 9.31 ms # 測試是否正確 compile 成功 node src/demo.js ### Hello, world! # 清除輸出檔案 gulp clean ### [14:56:18] Using gulpfile ~/Documents/gulp-babel-demo/gulpfile.js ### [14:56:18] Starting 'clean'... ### [14:56:18] Finished 'clean' after 4.34 ms # 測試是否正確清除 `dist` 目錄 ls ### gulpfile.js node_modules package.json src # 執行 `gulp`，會先執行 clean（相依任務），再執行 default（預設任務） gulp ### [14:48:30] Using gulpfile ~/Documents/gulp-babel-demo/gulpfile.js ### [14:48:30] Starting 'clean'... ### [14:48:30] Finished 'clean' after 12 ms ### [14:48:30] Starting 'default'... ### [14:48:30] Finished 'default' after 9.36 ms 欲了解其他 Plugin／用法，可直接 Gulp 官網，或直接搜尋 gulp + ，神人都幫你做好了。\nWebpack Webpack 是近幾年來最熱門的打包工具，透過解析模組之間的相依關係，可以\n 把專案中 js、css、和其他靜態 assets 打包到同一個檔案中 將不同頁面／模組的程式碼分離（code splitting） 透過 loader system，轉換／編譯 Sass、Babel、TypeScript 甚至圖片等不同檔案 （多數情況下能取代 Gulp、Grunt 等工具） 運用不同的 Plugins，組合出適合自己的 Webpack 流程與設定。  Webpack 最簡單的設定，就是在 project root 新增一個 webpack.config.js 檔案，以下範例取自 Webpack 的核心觀念（使用 Webpack 2）：\n// in `webpack.config.js`  const webpack = require('webpack'); //to access built-in plugins const path = require('path'); module.exports = { entry: './path/to/my/entry/file.js', // 1. 程式進入點設定  output: { // 2. 打包輸出設定  path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' }, module: { // 3. loaders（轉換檔案 - Javascript）  rules: [ { test: /\\.jsx?$/, use: 'babel-loader' } ] }, plugins: [ // 4. 其他有用的 plugins  new webpack.optimize.UglifyJsPlugin(), ] }; Webpack 的簡易運作流程如下：\n找到 entry file - 解析相依模組 - 符合 test rules 的模組由 loaders 轉換處理 - 將所有處理完成的檔案打包成 output 的 js 檔 其中，在 webpack.config.js 設定檔中，最核心四個概念如下：\nentry\n程式進入點，webpack 會從這個（些）檔案開始解析所有相依（require／import）的模組、CSS、圖片（沒錯，Webpack 可以 import 圖片，將圖片視為模組）。一個可以有多個 entries。\noutput\n打包完成的 .js 輸出的路徑設定，可根據多個 entries 輸出對應的 output。也可以利用內建的 CommonsChunkPlugin 來分離不同區塊／模組／套件的 output js 檔案。\nloaders\n任何使用 import／require 等關鍵字的 dependencies 都會被 webpack 解析，但 webpack 只認得 Javascript，所以需要許多 loaders 協助轉換，例如 sass-loader、css-loader、babel-loader 等。 每條 rules 利用 Regex 的 test 來區分哪些檔案使用哪些 loaders 處理，use field 則是指定對應的 loader，可以串連多個 loaders。\nplugins\n使用其他 plugins 來客製化 webpack 的打包結果，例如範例中內建的 UglifyJsPlugin 則是壓縮混淆最終輸出的 bundle.js，也有類似 extract-text-webpack-plugin ，將 CSS 檔從 bundle.js 中分離等實用的 plugins。\nWebpack 近幾年風生水起，生態系也應運而生。礙於篇幅，不少非常實用設定，以及 loaders 與 plugins 例如 style-loader、url-loader、HtmlWebpackPlugin 等，在此無法一一贅述，有興趣可以參考這個教學，也別忘了 Webpack 2 最新的官網。\n程式碼品質 一份好的程式碼，除了可以正確無誤的執行，更要讓人易讀易維護，本節將介紹\n 如何使用現代化的 JS 測試框架，讓你不再害怕自己寫的程式碼。 選擇一個好用的靜態語法檢查器，提高可讀性，減少人為失誤。  測試 所有工程師都知道測試的好處，也了解測試的必要性，但卻很少人主動寫測試。傳統 TDD（Trump-driven Test-driven development）的先寫測試，再寫程式的流程較不直觀，且易淪為為測試而測試，脫離現實。隨後崛起的 BDD（Behavior-driven development）則漸趨主流，強調測試只應在「程式行為不符預期時失敗」，是測「程式做了什麼」，而不是「程式如何做這些事」。\n一些 BDD 的測試框架與 BDD 斷言庫也順勢產生，透過語意化的 API，讓測試員更能了解程式到底「幹了啥事」，增添寫測試的樂趣。這裡主要介紹 Mocha 測試框架，配合 Chai 斷言庫，達成「快樂寫測試，寫測試快樂」的最高境界。\nmocha 與 chai 安裝與使用方法如下：\n# 安裝 mocha、chai 兩個套件 npm install --save-dev mocha chai # 建立一個 test 目錄 mkdir test # 使用預設編輯器開啟 test/test.js（第一個測試檔案） $EDITOR test/test.js 在你預設（或者你最喜愛）的編輯器裡，將下列測試加入 test/test.js\nconst chai = require('chai'); // 引入 `chai`（提供 asset／expect／should 風格斷言）  chai.should(); // 使用 should 前，需先執行 `chai.should()`，將 should 加到每個 Object  describe('Array', function() { // Test Suite  describe('#indexOf()', function() { // mocha 可嵌套 Test Suite，讓意圖更清晰  it('should include 2', function() { // 實際的 Test Case  const array = [1,2,5]; array.should.include(2); // 使用 should 風格進行斷言  }); }); }); 回到終端環境，執行以下指令：\n# 使用 mocha 模組的 command-line tool，進行測試 ./node_modules/.bin/mocha test/test.js ### Array ### #indexOf() ### ✓ should include 2 ### ### 1 passing (10ms)  若希望直接執行 mocha 來測試，不想每次都加上模組路徑，可以\n  在全域安裝 mocha 套件 npm install --global mocha 在 package.json 加入一個 run-script javascript \"scripts\": { // ... \"test\": \"mocha path/to/your/test/dir/\" }   如果想建立 TDD 式的 setUp、tearDown hooks，可以如下設計：\ndescribe('hooks', function () { before(function() { // 在這個 block 內所有 test case 之前執行  }); after(function () { // 在這個 block 內所有 test case 之後執行  }); beforeEach(function () { // 在這個 block 內每個 test case 之前執行  }); afterEach(function () { // 在這個 block 內每個 test case 之後執行  }); }); 有需要非同步（異步）的測試，請\n 在 test case 的 function params 加入 done 參數。 成功則調用 done()。 失敗則調用 done(err)，並加入 error 作為引數（argument）。  這裡以 Promise 為例：\ndescribe('Async Tests', function () { it('should complete in the furture', function (done) { // 加入 done 參數  someAsyncPromiseTest() // 一個異步的 Promise  .then((result) = { assert.ok(result); // 測試斷言  done(); // 調用 done，通知 test runner 成功執行 async task  }) .catch(err, (err) = { done(err); // 調用 done 並傳入 error，通知 test runner 執行異常  }) }); }); // 由於 `done` 是一個函式，上式也可簡寫成 describe('Async Tests', function () { it('should complete in the furture', function (done) { someAsyncPromiseTest() .then((result) = { result.should.equal('well done'); done(); }) .catch(done); // 直接傳入 done！  }); });  如果需要非同步的 hooks，同樣加入 done 參數，並調用 done。\n 其他相關 mocha 語法 API，mocha 網站寫得非常清楚。有關斷言的寫法，也可直接參考 chai 官網。\n靜態程式語法檢查 使用整合開發環境（IDE）的童鞋，想必對靜態語法檢查有深刻體會。使用靜態語法檢查，會對程式碼撰寫的風格有所限制，但同時可以可防止許多 bad code smell，例如：\n 一定要處理 error 避免修改以 const 宣告的變數 不要用 ( / . , 等符號當開頭（不寫分號唯一會遇到的問題！）  Javascript 的 linter 有非常多套，這裡選用目前最流行、客製化程度最高的 ESLint 作範例。\n# 安裝 eslint npm install --save-dev eslint # 互動式建置 `.eslint.js` 配置文件 ./node_modules/.bin/eslint --init # 之後就可以直接用 eslint 來檢查你的程式碼了 ./node_modules/.bin/eslint path/to/your/file.js  同樣地，可以在 package.json 加入一個 run-script，方便隨時 lint\n \"scripts\": { // ...  \"lint\": \"eslint .; exit 0;\" // 有錯誤的話 eslint exit code 是 1， 我們手動 exit 0 以避免 npm 報錯。 }  有些檔案不需要 linter 檢查（例如 test spec、其他套件的 config），可在 project root 加入 .eslintignore 忽略這些檔案（寫法同 .gitignore）。\n 通常我們會用一些大廠的設定，簡化我們的 Linter config，例如使用 Airbnb Javascript style，如果需要客製化 linter 可以參考 ESLint 如何配置。\n許多文字編輯器有整合的 eslint 的 plugin（如 Atom、Visual Studio Code），可即時查看 lint 結果，讓開發者更容易檢查語法錯誤。\n小結 本想簡單介紹如何建置一個前端開發環境，無奈前端之龐大，初出茅廬的我，完全無法收斂文章內容。本文已盡量點到為止，在重要之處皆留下關鍵連結，給有興趣的人們挖了些坑，希望看倌透過這篇文章，能對前端工程紛擾的世界有所了解，也不吝指教交流！\nReference  Node.js API Documentation NVM - Node Version Manager NPM - Node Package manager NPM Cli Commands NPM package.json spec Mozilla Developer Network Gulp - The streaming build system Webpack - A bundler for javascript and friends Mocha - Feature-rich Test Framework Chai - BDD/TDD Assertion Library ESLint - Pluggable JavaScript Linter  ","wordCount":"9255","inLanguage":"en","datePublished":"2017-03-10T15:36:46+08:00","dateModified":"2017-03-10T15:36:46+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://weihanglo.tw/posts/2017/fed-toolchain/"},"publisher":{"@type":"Organization","name":"Weihang Lo","logo":{"@type":"ImageObject","url":"https://weihanglo.tw/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://weihanglo.tw accesskey=h title="Weihang Lo (Alt + H)">Weihang Lo</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://weihanglo.tw/ title=Home>
<span>Home</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/posts/ title=Posts>
<span>Posts</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
大前端時代的工具箱
</h1>
<div class=post-meta><span title="2017-03-10 15:36:46 +0800 +0800">March 10, 2017</span>&nbsp;·&nbsp;19 min
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#contents aria-label=Contents>Contents</a></li>
<li>
<a href=#nodejs aria-label=Node.js>Node.js</a><ul>
<li>
<a href=#%e5%ae%89%e8%a3%9d-nodejs aria-label="安裝 Node.js">安裝 Node.js</a></li>
<li>
<a href=#nodejs-%e5%85%a7%e5%bb%ba%e6%a8%a1%e7%b5%84%e8%88%87%e8%ae%8a%e6%95%b8 aria-label="Node.js 內建模組與變數">Node.js 內建模組與變數</a></li>
<li>
<a href=#nodejs-%e7%89%88%e6%9c%ac%e7%ae%a1%e7%90%86%e5%b7%a5%e5%85%b7 aria-label="Node.js 版本管理工具">Node.js 版本管理工具</a></li></ul>
</li>
<li>
<a href=#npm-%e5%a5%97%e4%bb%b6%e6%a8%a1%e7%b5%84%e7%ae%a1%e7%90%86%e5%b7%a5%e5%85%b7 aria-label="NPM 套件模組管理工具">NPM 套件模組管理工具</a><ul>
<li>
<a href=#packagejson aria-label=package.json>package.json</a></li>
<li>
<a href=#npm-%e5%b8%b8%e7%94%a8%e6%8c%87%e4%bb%a4 aria-label="NPM 常用指令">NPM 常用指令</a></li></ul>
</li>
<li>
<a href=#%e9%a0%90%e8%99%95%e7%90%86%e5%99%a8%e8%bd%89%e8%ad%af%e5%99%a8 aria-label=預處理器／轉譯器>預處理器／轉譯器</a><ul>
<li>
<a href=#css-%e9%a0%90%e8%99%95%e7%90%86%e5%99%a8 aria-label="CSS 預處理器">CSS 預處理器</a></li>
<li>
<a href=#css-%e5%be%8c%e8%99%95%e7%90%86%e5%99%a8 aria-label="CSS 後處理器">CSS 後處理器</a></li>
<li>
<a href=#es6babel aria-label=ES6+／Babel>ES6+／Babel</a></li></ul>
</li>
<li>
<a href=#%e8%87%aa%e5%8b%95%e5%8c%96%e5%b7%a5%e5%85%b7%e6%89%93%e5%8c%85%e5%b7%a5%e5%85%b7 aria-label=自動化工具／打包工具>自動化工具／打包工具</a><ul>
<li>
<a href=#gulp aria-label=Gulp>Gulp</a></li>
<li>
<a href=#webpack aria-label=Webpack>Webpack</a></li></ul>
</li>
<li>
<a href=#%e7%a8%8b%e5%bc%8f%e7%a2%bc%e5%93%81%e8%b3%aa aria-label=程式碼品質>程式碼品質</a><ul>
<li>
<a href=#%e6%b8%ac%e8%a9%a6 aria-label=測試>測試</a></li>
<li>
<a href=#%e9%9d%9c%e6%85%8b%e7%a8%8b%e5%bc%8f%e8%aa%9e%e6%b3%95%e6%aa%a2%e6%9f%a5 aria-label=靜態程式語法檢查>靜態程式語法檢查</a></li></ul>
</li>
<li>
<a href=#%e5%b0%8f%e7%b5%90 aria-label=小結>小結</a></li>
<li>
<a href=#reference aria-label=Reference>Reference</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p><img loading=lazy src=https://leanpub.com/site_images/reactspeedcoding/tech-stack-w820.jpg alt="React Tech Stack">
</p>
<p>在大前端的時代，開發 Web app 不再像以前使用一個 jQuery 的 CDN 這麼容易，從 html 模板的抉擇，css 預處理器的挑選，Javascript 模組化的方法，自動化工具的使用等等，都是一門學問。本文將從建置基本的前端開發環境起頭，簡單介紹<del>個人愛用</del>現代常用的前端開發工具。</p>
<p><em>（撰於 2017-03-10）</em></p>
<h2 id=contents>Contents<a hidden class=anchor aria-hidden=true href=#contents>#</a></h2>
<ul>
<li><a href=#node-js>Node.js</a>
<ul>
<li><a href=#%E5%AE%89%E8%A3%9D-node-js>安裝 Node.js</a></li>
<li><a href=#node-js-%E5%85%A7%E5%BB%BA%E6%A8%A1%E7%B5%84-%E8%AE%8A%E6%95%B8>Node.js 內建模組與變數</a></li>
<li><a href=#node-js-%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7>Node.js 版本管理工具</a></li>
</ul>
</li>
<li><a href=#npm-%E5%A5%97%E4%BB%B6%E6%A8%A1%E7%B5%84%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7>NPM 套件模組管理工具</a>
<ul>
<li><a href=#package-json>package.json</a></li>
<li><a href=#npm-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4>NPM 常用指令</a></li>
</ul>
</li>
<li><a href=#%E9%A0%90%E8%99%95%E7%90%86%E5%99%A8%EF%BC%8F%E8%BD%89%E8%AD%AF%E5%99%A8>預處理器／轉譯器</a>
<ul>
<li><a href=#css-%E9%A0%90%E8%99%95%E7%90%86%E5%99%A8>CSS 預處理器</a></li>
<li><a href=#css-%E5%BE%8C%E8%99%95%E7%90%86%E5%99%A8>CSS 後處理器</a></li>
<li><a href=#es6-babel>ES6+／Babel</a></li>
</ul>
</li>
<li><a href=#%E8%87%AA%E5%8B%95%E5%8C%96%E5%B7%A5%E5%85%B7-%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7>自動化工具／打包工具</a>
<ul>
<li><a href=#gulp>Gulp</a></li>
<li><a href=#webpack>Webpack</a></li>
</ul>
</li>
<li><a href=#%E7%A8%8B%E5%BC%8F%E7%A2%BC%E5%93%81%E8%B3%AA>程式碼品質</a>
<ul>
<li><a href=#%E6%B8%AC%E8%A9%A6>測試</a></li>
<li><a href=#%E9%9D%9C%E6%85%8B%E7%A8%8B%E5%BC%8F%E8%AA%9E%E6%B3%95%E6%AA%A2%E6%9F%A5>靜態程式語法檢查</a></li>
</ul>
</li>
<li><a href=#%E5%B0%8F%E7%B5%90>小結</a></li>
<li><a href=#reference>Reference</a></li>
</ul>
<p>（以下環境皆以 macOS 為例）</p>
<h2 id=nodejs>Node.js<a hidden class=anchor aria-hidden=true href=#nodejs>#</a></h2>
<p><a href=https://nodejs.org/>Node.js</a> 是一個 Javascript 的運行環境，基於 Google V8 Engine。在 Node.js 尚未出現前，Javascript 只能運行在瀏覽器客戶端，功能受限於瀏覽器沙盒（sandbox）與廠商實作。Node.js 推出後，Javascript 程式碼可以在伺服器端運行，模組（module）和套件（package）的觀念和生態圈也隨之建立。程式碼的交流／複用更為便利。</p>
<h3 id=安裝-nodejs>安裝 Node.js<a hidden class=anchor aria-hidden=true href=#安裝-nodejs>#</a></h3>
<p>在 macOS 安裝 Node.js 非常簡單，在終端環境輸入指令來安裝最新版的 <a href=https://nodejs.org/>Node.js</a>：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># The latest version of Node.js</span>
brew install node

<span style=color:#75715e># 檢查是否安裝成功（成功則顯示最新版本版號）</span>
node -v
<span style=color:#75715e>### v7.7.1</span>

</code></pre></div><p>同時 Node.js 也附帶如同 <strong>python</strong>、<strong>irb</strong> 的直譯式互動環境（<a href=https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop>REPL</a>）可快速測試／開發一些功能。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 進入 REPL 環境</span>
node

<span style=color:#75715e># -- REPL 環境 --</span>
&gt; <span style=color:#ae81ff>1</span> + <span style=color:#ae81ff>2</span>
<span style=color:#75715e>### 3</span>
&gt; <span style=color:#e6db74>&#39;cat,mouse,dog&#39;</span>.split<span style=color:#f92672>(</span>/,/<span style=color:#f92672>)</span>
<span style=color:#75715e>### [ &#39;cat&#39;, &#39;mouse&#39;, &#39;dog&#39; ]</span>
</code></pre></div><h3 id=nodejs-內建模組與變數>Node.js 內建模組與變數<a hidden class=anchor aria-hidden=true href=#nodejs-內建模組與變數>#</a></h3>
<p>Node.js 提供豐富的原生模組，可以操作 filesystem、socket、os 等系統層的 API，讓 Javascript 躋身至與 Python、Ruby 之流同樣地位，成為流行的腳本語言（<a href=https://en.wikipedia.org/wiki/Scripting_language>scripting language</a>）。這裡列出前端開發者較常使用的幾個模組：</p>
<ul>
<li><code>os</code>：作業系統相關的操作與資訊</li>
<li><code>fs</code>：檔案系統的操作（移動／刪除／新增／檔案監控）</li>
<li><code>path</code>: 路徑相關工具模組（path resolve/join/pase/normalize）</li>
<li><code>assert</code>：斷言模組，通常與其他測試框架配合</li>
<li><code>child_process</code>：產生<a href=https://en.wikipedia.org/wiki/Child_process>子行程（進程）</a>的模組，開發較複雜的自動化工具才會用到。</li>
</ul>
<p>另外，Node.js 同時提供許多重要的全域（Global）物件與函式，在全域下（Global Scope）皆可取得。</p>
<ul>
<li><code>global</code>：node 運行環境最上層的物件，類似瀏覽器端 <code>window</code> 的存在。</li>
<li><code>process</code>：記錄當前 node 運行環境的所有資訊。一般配合設置 <code>NODE_ENV</code> 環境變數來區別不同的開發階段。</li>
<li><code>__dirname</code>：模組所在目錄的名稱。實際上非全域物件，而是各模組皆有的變數。</li>
<li><code>__filename</code>：模組的檔案名，Node.js 世界，<strong>一個檔案為一個模組</strong>。實際上非全域物件，而是各模組皆有的變數。</li>
<li><code>require()</code>：用來引入（import）其他模組的函式。實際上非全域物件，而是各模組皆有的 method。</li>
<li><code>module</code>：Node.js 遵循 <a href=https://en.wikipedia.org/wiki/CommonJS>CommonJS</a> 定義的「模組」模組，最常用到 <code>module.exports</code> 變數，這個變數會指向欲 export 的物件。</li>
</ul>
<blockquote>
<p>Node.js 模組 import／export 稍微複雜，可以參考<a href=https://www.sitepoint.com/understanding-module-exports-exports-node-js/>用法教學</a>、<a href=http://www.ruanyifeng.com/blog/2015/05/require.html>深入講解 require</a>，或是直接閱讀<a href=https://nodejs.org/api/modules.html>官方文件</a>。</p>
</blockquote>
<blockquote>
<p>模組化的實作規範在 Javascript 界可謂群魔亂舞，所以 ECMA 2015 (ES6) 提出新的模組化 API（<a href=https://www.ecma-international.org/ecma-262/6.0/#sec-imports>imports</a>／<a href=https://www.ecma-international.org/ecma-262/6.0/#sec-exports>exports</a>），未來甚至可在瀏覽器端使用。目前可透過 Babel 轉譯器的<a href=https://www.npmjs.com/package/babel-plugin-transform-es2015-modules-commonjs>外掛</a>搶先體驗。</p>
</blockquote>
<h3 id=nodejs-版本管理工具>Node.js 版本管理工具<a hidden class=anchor aria-hidden=true href=#nodejs-版本管理工具>#</a></h3>
<p>蓬勃社群使得 Node.js 不斷精進，但也帶來軟體工程最痛苦的「版本相容」問題。許多時候，我們需要在最新的 Node 版本中測試新功能，但仍需要維護依賴舊版的專案。在不同 Node 版本環境間切換成本不低，幸虧有牛人寫了易用的版本管理工具 <a href=https://github.com/creationix/nvm><code>nvm</code></a> 與 <a href=https://github.com/tj/n><code>n</code></a>，讓版本切換變得輕鬆愉快。</p>
<p>以下主要介紹 <code>nvm</code> 的特色、安裝與簡易用法。<code>nvm</code> 的特色如下：</p>
<ul>
<li>使用 shell script 寫成，無其他相依模組／環境。</li>
<li>每個不同版本的 node 有自己的 global modules 環境，不互相影響。</li>
<li>更新至新版時，一行指令就可以重新安裝相同的 global packages。</li>
</ul>
<p><strong>總之，先開啟你的終端機吧！</strong></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 透過 homebrew 安裝 nvm（macOS）</span>
brew install nvm

<span style=color:#75715e># 在使用者家目錄下，新增一個 .nvm 的工作目錄</span>
mkdir ~/.nvm

<span style=color:#75715e># 使用預設編輯器開啟 ~/.bash_profile</span>
$EDITOR ~/.bash_profile
</code></pre></div><p>在你預設（或者你最喜愛）的編輯器裡，將下列兩行設定加入 .bash_profile 中：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 將下列設定加在 .bash_profile 中，讓 shell 讀取 nvm 設定</span>
export NVM_DIR<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$HOME<span style=color:#e6db74>/.nvm&#34;</span>
. <span style=color:#e6db74>&#34;/usr/local/opt/nvm/nvm.sh&#34;</span>
</code></pre></div><p>離開編輯器，回到終端機畫面。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 檢查設定是否正確</span>
echo $NVM_DIR
<span style=color:#75715e>### /Users/weihanglo/.nvm</span>

<span style=color:#75715e># 重新讀取 .bash_profile，讓剛剛的設定生效</span>
source ~/.bash_profile
</code></pre></div><p>現在可以開始安裝不同版本的 node 了！</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 安裝最新版的 Node.js</span>
nvm install node

<span style=color:#75715e># 安裝／移除特定版本</span>
nvm install v6.9.0
nvm install v7.6.0
nvm uninstall node

<span style=color:#75715e># 設定預設使用的版本</span>
nvm alias default v7.6.0

<span style=color:#75715e># 切換至其他版本</span>
nvm use v7.6.0
<span style=color:#75715e># or</span>
nvm use default

<span style=color:#75715e># 列出 local 已經安裝的版本</span>
nvm ls
<span style=color:#75715e>###         v6.9.0</span>
<span style=color:#75715e>### -&gt;      v7.6.0</span>
<span style=color:#75715e>### default -&gt; v7.6.0</span>

<span style=color:#75715e># 安裝新版 Node.js，並從其他版本安裝相同的 packages／modules</span>
nvm install v7.7.1 --reinstall-packages-from<span style=color:#f92672>=</span>v7.4.0
</code></pre></div><blockquote>
<p>使用 <strong>nvm</strong> 至今，個人唯一詬病的是 script 體積較大，拖慢 shell startup time，社群有人發現此問題，並提出<a href=https://www.reddit.com/r/node/comments/4tg5jg/lazy_load_nvm_for_faster_shell_start/d5ib9fs/>解法</a>。我稍作修改，去蕪存菁，只讀取 default version 的 binary，略提升 startup 時間（畢竟敝人的 <code>.bashrc</code> 已不瘦了），<a href=https://github.com/weihanglo/dotfiles/blob/master/.bashrc#L97-L122>這段 script 提供大家參考</a>。</p>
</blockquote>
<h2 id=npm-套件模組管理工具>NPM 套件模組管理工具<a hidden class=anchor aria-hidden=true href=#npm-套件模組管理工具>#</a></h2>
<p>常言道，成功的程式語言背後，有個支持它的生態圈。Python／R 透過科學與統計的模組生態，在資料科學界中獨霸一方；Docker 把 Go 語言從鬼門關前救回，Go 因此成為 Container 界的王者；Node.js／Javascript 則是藉由方便易用的 <a href=https://www.npmjs.com/><code>npm</code></a>，讓才華洋溢的<del>宅男</del>工程師們盡情交流，創造出成千上萬個模組。</p>
<p>以下列出 npm 的特色：</p>
<ul>
<li>為 Node.js 預設的套件管理工具，安裝 Node.js 會一併安裝 npm。</li>
<li><strong>npm, Inc</strong> 提供套件伺服器 <a href=https://docs.npmjs.com/misc/registry>npm Registry</a> 供開發者上傳／下載套件。（截止 2017.3.9 有 43 萬餘套件）。</li>
<li>提供 <code>package.json</code> 供使用者管理專案的相依模組／套件。</li>
<li>根據 <code>package.json</code> 的設定，進行更複雜的任務，如 test runner、build tool、watch file changes。</li>
</ul>
<h3 id=packagejson>package.json<a hidden class=anchor aria-hidden=true href=#packagejson>#</a></h3>
<p><code>package.json</code> 是一個 Node.js 模組最重要的檔案，記錄與此模組相關的設定，部分第三方套件的配置文件也可以寫在 <code>package.json</code> 裡，減少 project 設定檔過多的問題（例如：babel、browserslist）。</p>
<p>合法的 <code>package.json</code> 除了要是一個 <a href=https://www.json.org/>JSON</a> 格式檔案之外，還<strong>必須包含</strong>下列兩個重要的 fields：</p>
<ul>
<li><code>name</code>：模組名稱，也是import 模組時的名稱。在 npm Registry 通常是以相同或近似的名稱註冊，命名慣例以<code>-</code>（hyphen）取代 camelCase。</li>
<li><code>version</code>：模組目前的版號，npm 遵循<a href=https://semver.org/>語意化版號</a>的標準，減少套件更新異動造成的問題。</li>
</ul>
<p>其他重要且建議填寫的 fields 有：</p>
<ul>
<li><code>main</code>：程式進入點，也是模組進入點（該檔案的 <code>module.exports</code>），慣例為 <code>index.js</code> 或 <code>main.js</code>。</li>
<li><code>devepdencies</code>：該模組直接相依的第三方模組。規範採用<a href=https://semver.org/>語意化版號</a>標準。</li>
<li><code>devDependencies</code>： 該模組開發時會使用到相依模組，例如<strong>測試模組、打包模組</strong>。規範採<a href=https://semver.org/>語意化版號</a>標準。</li>
<li><code>scripts</code>：自定義的 shell 腳本。可透過 <code>npm run &lt;command></code> 執行。</li>
<li><code>license</code>：模組的授權條款，建議填寫。</li>
<li><code>bin</code>：若模組有提供指令列程式，需在此配置指令名稱與對應檔案。</li>
</ul>
<p>在此概述常用的版號語法：</p>
<ul>
<li><code>1.2.3</code>：指定使用版號 1.2.3</li>
<li><code>>1.2.3</code>：接受版號大於 1.2.3</li>
<li><code>>=1.2.3</code>：接受版號大於等於 1.2.3</li>
<li><code>~1.2.3</code>：接受 patch version，同義於 <code>>=1.2.3 &lt;1.3.0</code></li>
<li><code>^1.2.3</code>：只接受 minor version 或 non-breaking changes，同義於 <code>>=1.2.0 &lt;2.0.0</code></li>
<li><code>*</code>：接受任何版號。</li>
</ul>
<blockquote>
<p><code>~</code>（tilde）與 <code>^</code>（caret）, 在版號寫法不同時，有不同結果，請參考 <a href=https://docs.npmjs.com/misc/semver#tilde-ranges-123-12-1>node-semver 官方文件</a>。</p>
</blockquote>
<p>一個合法的 <code>package.json</code> 範例：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript>{
  <span style=color:#e6db74>&#34;name&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;electron-react-demo&#34;</span>, <span style=color:#75715e>// 模組名稱，以 hyphen 取代 camelCase
</span><span style=color:#75715e></span>  <span style=color:#e6db74>&#34;version&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;0.0.1&#34;</span>, <span style=color:#75715e>// 當前版號
</span><span style=color:#75715e></span>  <span style=color:#e6db74>&#34;description&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;A Electron Demo with React&#34;</span>, <span style=color:#75715e>// 模組簡介
</span><span style=color:#75715e></span>  <span style=color:#e6db74>&#34;main&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;main.js&#34;</span>, <span style=color:#75715e>// 程式進入點／模組進入點
</span><span style=color:#75715e></span>  <span style=color:#e6db74>&#34;scripts&#34;</span><span style=color:#f92672>:</span> { <span style=color:#75715e>// 自定義腳本
</span><span style=color:#75715e></span>    <span style=color:#e6db74>&#34;start&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;electron .&#34;</span> <span style=color:#75715e>// 輸入 `npm run start` 或 `npm start` 時會執行的腳本
</span><span style=color:#75715e></span>  },
  <span style=color:#e6db74>&#34;author&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Weihang Lo&#34;</span>, <span style=color:#75715e>// 作者欄位
</span><span style=color:#75715e></span>  <span style=color:#e6db74>&#34;license&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;MIT&#34;</span>, <span style=color:#75715e>// 授權／版權條款
</span><span style=color:#75715e></span>  <span style=color:#e6db74>&#34;dependencies&#34;</span><span style=color:#f92672>:</span> { <span style=color:#75715e>// 直接相依的模組
</span><span style=color:#75715e></span>    <span style=color:#e6db74>&#34;react&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;~15.4.1&#34;</span>, <span style=color:#75715e>// 使用 patch version 的 react
</span><span style=color:#75715e></span>    <span style=color:#e6db74>&#34;react-dom&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;~15.4.1&#34;</span>
  },
  <span style=color:#e6db74>&#34;devDependencies&#34;</span><span style=color:#f92672>:</span> { <span style=color:#75715e>// 開發用的模組
</span><span style=color:#75715e></span>    <span style=color:#e6db74>&#34;babel-preset-es2015&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;^6.18.0&#34;</span>, <span style=color:#75715e>// 版號 &gt;= 6.18.0 但小於 &lt; 7.0.0
</span><span style=color:#75715e></span>    <span style=color:#e6db74>&#34;babel-preset-react&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;^6.16.0&#34;</span>,
    <span style=color:#e6db74>&#34;electron&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;1.4.12&#34;</span>, <span style=color:#75715e>// 使用指定版號的 electron
</span><span style=color:#75715e></span>    <span style=color:#e6db74>&#34;mocha&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;*&#34;</span>, <span style=color:#75715e>// 使用最新／任意版本。
</span><span style=color:#75715e></span>    <span style=color:#e6db74>&#34;chai&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;*&#34;</span>
  }
}
</code></pre></div><p>還有許多沒介紹到的 <code>package.json</code> 設定，在 <a href=https://docs.npmjs.com/files/package.json>npm 官方文件</a> 裡應有盡有！</p>
<h3 id=npm-常用指令>NPM 常用指令<a hidden class=anchor aria-hidden=true href=#npm-常用指令>#</a></h3>
<p>npm 的指令列程式提供許多功能，其中最重要的兩類即是<strong>模組</strong>和<strong>執行腳本</strong>相關的指令。</p>
<p><strong>安裝／移除／更新／列出 相依模組</strong></p>
<ul>
<li><code>npm install [--global] [--save] [--save-dev]</code></li>
<li><code>npm uninstall [--global] [--save] [--save-dev]</code></li>
<li><code>npm ls [--global] [--depth=&lt;number>]</code></li>
<li><code>npm update [--global]</code></li>
</ul>
<p>開始介紹前，先了解 npm 安裝模組的模式，分為 <strong>全域模式（globally）</strong> 與 <strong>本地模式（locally）</strong></p>
<ul>
<li>全域模式 <code>--global</code>：安裝的模組通常是常用的指令列程式，例如 npm 本身。</li>
<li>本地模式：用來安裝與 project 相依的模組，會在 project 根目錄產生一個 <code>node_modules</code> 存放相依模組。</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 創建一個 npm 模組環境（互動式產生 package.json）</span>
npm init

<span style=color:#75715e># 尋找同目錄下的 `package.json`，安裝該檔案內記錄的相依套件</span>
npm install

<span style=color:#75715e># 安裝 axios 套件，不儲存相依關係。</span>
npm install axios

<span style=color:#75715e># 安裝 bluebird 套件，並將相依版號寫入 `package.json` 的 `dependencies` field 中</span>
npm install bluebird --save

<span style=color:#75715e># 安裝 mocha、chai 套件，並將相依版號寫入 `package.json` 的 `devDependencies` field 中（開發用套件）</span>
npm install mocha chai --save-dev

<span style=color:#75715e># 安裝 Globally 的套件，在任何目錄都可直接使用該模組的指令列程式</span>
npm install --global yarn

<span style=color:#75715e># 移除 bluebird 套件，並從 `package.json` 中移除相依關係</span>
npm uninstall bluebird --save

<span style=color:#75715e># 列出 locally（project-wide） 的套件到第一階層（專案的相依套件的相依套件）</span>
npm ls --depth<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>

<span style=color:#75715e># 列出全域安裝的套件（只列出 user 直接安裝的套件）</span>
npm ls --global --depth<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>

<span style=color:#75715e># 更新 bluebird 套件至 package.json 內的指定版號</span>
npm update bluebird

<span style=color:#75715e># 更新 package.json 記錄的套件至指定版號</span>
npm update

<span style=color:#75715e># 更新所有全員安裝的套件</span>
npm update --global
</code></pre></div><blockquote>
<p>Facebook、Google 幾個大頭在 2016 年 10 月 開源了新一代的 Node.js 套件管理工具 <a href=https://yarnpkg.com/>Yarn</a>，在速度、體驗、介面上皆略勝 npm 一籌。Yarn 也會自動產生 <code>yarn.lock</code> 檔案，精確記錄相依模組的版號，在套件管理上更安全安心，有興趣的童鞋可嘗試看看。</p>
</blockquote>
<p><strong>執行自定義腳本</strong></p>
<ul>
<li><code>npm run &lt;command> [-- &lt;args>...]</code></li>
</ul>
<p>用來執行 <code>package.json</code> 的 <code>scripts</code> field 中的自定義腳本。在執行開始前，<code>npm run</code> 會在既有的 <a href=https://en.wikipedia.org/wiki/PATH_(variable)>PATH</a> 環境變數加上 <code>node_modules/.bin</code>，許多套件提供的 binary 執行檔可以直接執行，不需要再加上 <code>./node_modules/.bin/a-command</code> 等冗長的相對路徑。因此，<code>npm run</code> 常作為 task/test runner、build tools 的入口。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 在 `package.json` 裡</span>
<span style=color:#f92672>{</span>
  <span style=color:#e6db74>&#34;scripts&#34;</span>: <span style=color:#f92672>{</span>
    <span style=color:#e6db74>&#34;start&#34;</span>: <span style=color:#e6db74>&#34;echo &#39;Start my node.js app&#39;&#34;</span>,
    <span style=color:#e6db74>&#34;fail&#34;</span>: <span style=color:#e6db74>&#34;echo \&#34;Oops! Failed on </span>$1<span style=color:#e6db74>\&#34;&#34;</span>,
    <span style=color:#e6db74>&#34;serve&#34;</span>: <span style=color:#e6db74>&#34;serve&#34;</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>

<span style=color:#75715e># 回到終端環境，先安裝相依套件</span>
npm install serve

<span style=color:#75715e># 等同於執行 `./node_modules/.bin/serve`，開啟一個 local http server</span>
npm run serve
<span style=color:#75715e>### Serving!</span>

<span style=color:#75715e># `--` 可傳入參數等，同執行 `echo &#39;Oops! Failed $1`</span>
npm run fail -- Example
<span style=color:#75715e>### Oops! Failed on Example</span>

<span style=color:#75715e># `start`、`test`、`restart` 等 script 可不透過 `run`，直接使用簡寫執行</span>
npm run start
<span style=color:#75715e>### Start my node.js app</span>

npm start
<span style=color:#75715e>### Start my node.js app</span>
</code></pre></div><p>除了上述 npm 還有許多功能，族繁不及備載，詳情請參考 <a href=https://docs.npmjs.com/getting-started#cli>npm - Cli Commands</a>。有關 <code>npm run-script</code>，也可以瞧瞧<a href=http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html>這篇教學</a>。</p>
<h2 id=預處理器轉譯器>預處理器／轉譯器<a hidden class=anchor aria-hidden=true href=#預處理器轉譯器>#</a></h2>
<p>雖然 Node.js／npm 為 Javascript 生態圈帶來前所未有的繁榮盛況，但前端的世界還是處處充滿危機，不同瀏覽器廠商的實作參差不齊，開發者常搞不清楚<a href=https://caniuse.com/>可以用哪些 CSS 與 Javascript 的 features</a>，開源社群為了消弭這些惱人的問題，開發出許多協助開發者的<a href=https://github.com/showcases/css-preprocessors>預處理器</a>／<a href=https://en.wikipedia.org/wiki/Source-to-source_compiler>轉譯器（transpiler）</a>。</p>
<blockquote>
<p>預處理器／轉譯器屬於 <a href=https://en.wikipedia.org/wiki/Source-to-source_compiler>source-to-source compiler</a>，雖然可以加速開發，但也需要引入 build tools 協助轉換語法，有關 build tools／task runner，會在<a href=#%E8%87%AA%E5%8B%95%E5%8C%96%E5%B7%A5%E5%85%B7%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7>自動化工具／打包工具</a>與各位分享。</p>
</blockquote>
<h3 id=css-預處理器>CSS 預處理器<a hidden class=anchor aria-hidden=true href=#css-預處理器>#</a></h3>
<p>CSS 對程序猿來說，沒有繼承，沒有函式，沒有變數，全部的設定都在 global scope，完全符合設計不良的語言特性。有志青年打造了許多<a href=https://github.com/showcases/css-preprocessors>類似 CSS 的語言</a>，提供變數、函式、<a href=https://en.wikipedia.org/wiki/Mixin>mixin</a>，再 compile 成 vanilla CSS，讓寫 CSS 能夠更輕鬆，更能專注商業邏輯。這些方便的工具我們通稱 <strong>CSS Preprocessor</strong>。</p>
<p>目前主流的 <strong>CSS Preprocessor</strong> 有 <a href=http://lesscss.org/>Less</a>、<a href=http://sass-lang.com/>Sass</a>，以及 <a href=http://stylus-lang.com/>Stylus</a> 等，每一套都有各自的擁護者，在此簡單比較 <strong>Sass</strong> 與 vanilla CSS，給客倌看看。</p>
<p><strong>Vanilla CSS（同一個 nav 下的元素要分為三個 block 撰寫，且相同的 padding 要寫兩次）</strong></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css>
<span style=color:#f92672>nav</span> <span style=color:#f92672>ul</span> {
  <span style=color:#66d9ef>margin</span>: <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>padding</span>: <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>list-style</span>: <span style=color:#66d9ef>none</span>;
}

<span style=color:#f92672>nav</span> <span style=color:#f92672>li</span> {
  <span style=color:#66d9ef>padding</span>: <span style=color:#ae81ff>6</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>12</span><span style=color:#66d9ef>px</span>
  <span style=color:#66d9ef>display</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>inline-block</span>;
}

<span style=color:#f92672>nav</span> <span style=color:#f92672>a</span> {
  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>block</span>;
  <span style=color:#66d9ef>padding</span>: <span style=color:#ae81ff>6</span><span style=color:#66d9ef>px</span> <span style=color:#ae81ff>12</span><span style=color:#66d9ef>px</span>;
  <span style=color:#66d9ef>text-decoration</span>: <span style=color:#66d9ef>none</span>;
}
</code></pre></div><p><strong>Sass（SCSS syntax）支援 <a href=http://sass-lang.com/documentation/file.SASS_REFERENCE.html#variables_>variable</a> 與 <a href=http://sass-lang.com/documentation/file.SASS_REFERENCE.html#nested_rules>nested element selector</a></strong></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scss data-lang=scss>$my-vertical-padding<span style=color:#f92672>:</span> <span style=color:#ae81ff>6</span><span style=color:#66d9ef>px</span>;
$my-horizontal-padding<span style=color:#f92672>:</span> <span style=color:#ae81ff>12</span><span style=color:#66d9ef>px</span>;

<span style=color:#f92672>nav</span> {
  <span style=color:#f92672>ul</span> {
    <span style=color:#a6e22e>margin</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#a6e22e>padding</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#a6e22e>list-style</span><span style=color:#f92672>:</span> none;
  }

  <span style=color:#f92672>li</span> {
    <span style=color:#a6e22e>display</span><span style=color:#f92672>:</span> inline-block;
    <span style=color:#a6e22e>padding</span><span style=color:#f92672>:</span> $my-vertical-padding $my-horizontal-padding;
  }

  <span style=color:#f92672>a</span> {
    <span style=color:#a6e22e>display</span><span style=color:#f92672>:</span> block;
    <span style=color:#a6e22e>padding</span><span style=color:#f92672>:</span> $my-vertical-padding $my-horizontal-padding;
    <span style=color:#a6e22e>text-decoration</span><span style=color:#f92672>:</span> none;
  }
}
</code></pre></div><blockquote>
<p>Sass 是 Ruby 社群發展出來的 CSS 預處理器，在 Javascript 界通常使用 <a href=https://github.com/sass/node-sass>node-sass</a> 做 CSS transform。Sass 是個人非常喜愛的 CSS 預處理器。</p>
</blockquote>
<h3 id=css-後處理器>CSS 後處理器<a hidden class=anchor aria-hidden=true href=#css-後處理器>#</a></h3>
<p>對前端開發者來說，最痛苦的莫過於在 Chrome 切好 layout，卻在 Safari 跑版。在 Firefox 做 css animation，卻在 Safari 動彈不得。這些問題來自於各瀏覽器實作不同，添加的 <a href=https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix>vendor prefix</a> 也不一樣，我們可以透過 <a href=https://www.sitepoint.com/sass-mixins-kickstart-project/>Sass 的 mixin 來解決 prefix 問題</a>，但這不夠 fancy，CSS 後處理器概念營運而生，最有名的莫過於 <a href=http://postcss.org/>postcss</a> 的 Plugin <a href=https://github.com/postcss/autoprefixer>autoprefixer</a>，在 CSS 預處理器 compile 完成之後，需要的 property 加上 vendor prefix，完全不需要再寫一丁點 mixin。</p>
<blockquote>
<p>順水推舟，<a href=http://postcss.org/>postcss</a> 是個生態豐富的 css transforming plugin system，許多瀏覽器未實作的 feature，透過 plugin 轉換，就可以使用各種 feature了。</p>
</blockquote>
<h3 id=es6babel>ES6+／Babel<a hidden class=anchor aria-hidden=true href=#es6babel>#</a></h3>
<p>Javascript 從出生到現在，一直是個被人嫌棄的語言，弱型別，隱式轉換，缺乏真正物件導向概念（只有 prototype oriented），變數可重複宣告，<a href=https://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work><code>this</code> 的語意</a>更讓人摸不著頭緒。近年來，ECMAScript 的標準不斷往前走，加入了 <a href=https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let>作用域變數 scope variable（<code>let</code>）</a>、<a href=https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/const>常數宣告 constant declaration（<code>const</code>）</a>，自動綁定 <code>this</code> 的 <a href=https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions>arrow function</a>，甚至原生的 <a href=https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes>class</a> 等語言新特性。徹底改造整個 Javascript 的生態圈。</p>
<p>可惜又面臨同個問題，目前的瀏覽器／Node.js 環境不一定支援。社群又跳出來，寫了名為 <a href=https://babeljs.io/><code>Babel</code></a>（借用巴別塔的典故）的 transpiler，將最新的 Javascript 語法，轉換成當前瀏覽器相容的語法。透過 <a href=https://babeljs.io/>Babel</a>，我們可歡樂地使用 ES6 的 class，不必擔心 IE 會 crash 了！</p>
<p>以下介紹 Babel 的簡易設定：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 在你的專案目錄底下安裝 babel 套件</span>
npm install --save-dev babel-cli babel-preset-env

<span style=color:#75715e># 使用預設編輯器開啟 .babelrc（Babel 設定檔）</span>
$EDITOR ~/.bash_profile
</code></pre></div><p>在你預設（或者你最喜愛）的編輯器裡，將下列設定加入 <code>.babelrc</code>（Babel 設定檔） 中：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 在 .babelrc 中加入下列設定</span>
<span style=color:#f92672>{</span>
  <span style=color:#e6db74>&#34;presets&#34;</span>: <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;env&#34;</span><span style=color:#f92672>]</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>接下來利用你喜愛的 task runner，把你的 code compile 成瀏覽器相容的 javascript 吧！</p>
<blockquote>
<p>Babel 提供許多不同的預處理器（presets），例如 es2015、es2017，<code>env</code> 是目前 Babel 官方推薦的 presets，可以透過設定 <a href=https://github.com/ai/browserslist><code>browserslist</code></a>，依據不同生產環境決定哪些語法需要轉換，<strong>autoprefixer</strong> 與 <strong>eslint</strong> 同樣也支援 <code>browserslist</code>。</p>
</blockquote>
<blockquote>
<p>另一個有名且有前景的轉譯器是微軟出品的 <a href=https://www.typescriptlang.org/>TypeScript</a>，支援繼承、抽象介面、裝飾器、型別檢查等 features，現代語言該有的應有盡有。由於是 Javascript 的 superset，在 TypeScript 裡寫 Javascript 完全合法，且 Google 的 <a href=https://angular.io/>Angular</a> Framework，以及有名的 Reactive Programing Libary <a href=https://github.com/ReactiveX/rxjs>RxJS</a> 也都採用 TypeScript。值得一試！</p>
</blockquote>
<h2 id=自動化工具打包工具>自動化工具／打包工具<a hidden class=anchor aria-hidden=true href=#自動化工具打包工具>#</a></h2>
<p>使用這麼多預處理器／轉譯器／自定義腳本，如果每次都需要自己 <code>npm run compile</code>、<code>babel script.js</code> 豈不麻煩？為了減少重複性的任務（task），Javascript 生態圈發展出數套實用的 build tool／system，老牌的 <a href=https://gruntjs.com/>Grunt</a> 與較年輕的 <a href=https://gulpjs.com/>Gulp</a>，這裡選擇使用 <a href=https://gulpjs.com/>Gulp</a>。</p>
<p>另外，當我們想使用 npm 上的各種模組，卻很難直接在瀏覽器端引入這些 dependencies。打包工具如 <a href=http://browserify.org/><code>Browserify</code></a> 與 <a href=https://webpack.js.org/>Webpack</a> 提供我們將這些散落各處的 .js、.css、.html 打包起來的方法，便於 import 到瀏覽器客戶端。這裡主要介紹 <a href=https://webpack.js.org/>Webpack</a>。</p>
<h3 id=gulp>Gulp<a hidden class=anchor aria-hidden=true href=#gulp>#</a></h3>
<p><a href=https://gulpjs.com/>Gulp</a> 是一個直觀易懂的 build system，其概念是利用 Node.js 的 <a href=https://nodejs.org/api/stream.html>stream</a> API，有如 <a href=https://en.wikipedia.org/wiki/Pipeline_(Unix)>pipeline</a> 般將檔案傳遞到每個 plugin／transformer 中做對應的任務。而 Gulp 也有豐富的 plugin 生態系，提供許多主流預處理器的 plugin，讓結果如同 stream 一樣容易產出。</p>
<p>以下簡單示範 gulp 安裝與用法：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 1. 首先先安裝 Global gulp command-line tool</span>
npm install --global gulp-cli

<span style=color:#75715e># 2. 接著在 project 將 gulp 安裝為 devDependencies</span>
npm install --save-dev gulp

</code></pre></div><p>在 project root 新增 gulpfile.js，並寫入這些設定：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 3. gulpfile.js at project root
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>gulp</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;gulp&#39;</span>);

<span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>task</span>(<span style=color:#e6db74>&#39;default&#39;</span>, <span style=color:#66d9ef>function</span>() {
  <span style=color:#75715e>// 你的預設 task
</span><span style=color:#75715e></span>});
</code></pre></div><p>回到終端環境：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 4. 輸入 `gulp`，執行預設的 task：</span>
gulp
<span style=color:#75715e>### [14:20:30] Using gulpfile ~/Documents/gulp-demo/gulpfile.js</span>
<span style=color:#75715e>### [14:20:30] Starting &#39;default&#39;...</span>
<span style=color:#75715e>### [14:20:30] Finished &#39;default&#39; after 361 μs</span>
</code></pre></div><p>Gulp 本身的 <a href=https://github.com/gulpjs/gulp/blob/master/docs/API.md>API 不多</a>，語法也很簡單，這邊舉例並說明 <code>gulpfile.js</code> 實例：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 確認有先安裝相依的 babel 套件 與 del 套件
</span><span style=color:#75715e>// `npm install --save-dev gulp-babel babel-preset-env del`
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>gulp</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;gulp&#39;</span>);             <span style=color:#75715e>// import gulp 套件（必須）
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>babel</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;gulp-babel&#39;</span>);      <span style=color:#75715e>// import gulp-babel 插件
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>del</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;del&#39;</span>);               <span style=color:#75715e>// import del 套件（用來 cleanup output）
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>task</span>(<span style=color:#e6db74>&#39;babel&#39;</span>, <span style=color:#66d9ef>function</span> () {        <span style=color:#75715e>// 建立一個叫做 babel 的任務
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>src</span>(<span style=color:#e6db74>&#39;src/**/*.js&#39;</span>)               <span style=color:#75715e>// `gulp.src` 會讀取給定路徑（src 下所有 js 檔）的檔案
</span><span style=color:#75715e></span>    .<span style=color:#a6e22e>pipe</span>(<span style=color:#a6e22e>babel</span>({ <span style=color:#a6e22e>presets</span><span style=color:#f92672>:</span> [<span style=color:#e6db74>&#39;env&#39;</span>] }))  <span style=color:#75715e>// 將上一步的檔案 pipe 給 babel plugin 處理
</span><span style=color:#75715e></span>    .<span style=color:#a6e22e>pipe</span>(<span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>dest</span>(<span style=color:#e6db74>&#39;dist&#39;</span>));           <span style=color:#75715e>// 將上一步的檔案透過 `gulp.dest` 輸出到給定路徑（dist）
</span><span style=color:#75715e></span>});

<span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>task</span>(<span style=color:#e6db74>&#39;clean&#39;</span>, <span style=color:#66d9ef>function</span> () {        <span style=color:#75715e>// 建立一個叫做 clean 的任務
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>del</span>([<span style=color:#e6db74>&#39;dist&#39;</span>]);                      <span style=color:#75715e>// 使用 `del` 套件，刪除輸出的目錄 (dist)
</span><span style=color:#75715e></span>});

<span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>task</span>(<span style=color:#e6db74>&#39;default&#39;</span>, [<span style=color:#e6db74>&#39;clean&#39;</span>], <span style=color:#66d9ef>function</span> () { <span style=color:#75715e>// 建立預設任務，並設 clean 為相依任務（在該任務執行前執行）
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>watch</span>(<span style=color:#e6db74>&#39;src/**/*.js&#39;</span>, [<span style=color:#e6db74>&#39;babel&#39;</span>]); <span style=color:#75715e>// 使用 `gulp.watch` 監視檔案異動，有異動就執行 babel 任務
</span><span style=color:#75715e></span>});
</code></pre></div><p>在終端環境下，我們這樣做：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 先寫一個假的 ES6 js file</span>
mkdir src
echo <span style=color:#e6db74>&#34; (() =&gt; console.log(&#39;Hello, world!&#39;))() &#34;</span> &gt; src/demo.js

<span style=color:#75715e># 執行 babel 任務</span>
gulp babel
<span style=color:#75715e>### [14:42:23] Using gulpfile ~/Documents/gulp-babel-demo/gulpfile.js</span>
<span style=color:#75715e>### [14:42:23] Starting &#39;babel&#39;...</span>
<span style=color:#75715e>### [14:42:23] Finished &#39;babel&#39; after 9.31 ms</span>

<span style=color:#75715e># 測試是否正確 compile 成功</span>
node src/demo.js
<span style=color:#75715e>### Hello, world!</span>

<span style=color:#75715e># 清除輸出檔案</span>
gulp clean
<span style=color:#75715e>### [14:56:18] Using gulpfile ~/Documents/gulp-babel-demo/gulpfile.js</span>
<span style=color:#75715e>### [14:56:18] Starting &#39;clean&#39;...</span>
<span style=color:#75715e>### [14:56:18] Finished &#39;clean&#39; after 4.34 ms</span>

<span style=color:#75715e># 測試是否正確清除 `dist` 目錄</span>
ls
<span style=color:#75715e>### gulpfile.js  node_modules package.json src</span>

<span style=color:#75715e># 執行 `gulp`，會先執行 clean（相依任務），再執行 default（預設任務）</span>
gulp
<span style=color:#75715e>### [14:48:30] Using gulpfile ~/Documents/gulp-babel-demo/gulpfile.js</span>
<span style=color:#75715e>### [14:48:30] Starting &#39;clean&#39;...</span>
<span style=color:#75715e>### [14:48:30] Finished &#39;clean&#39; after 12 ms</span>
<span style=color:#75715e>### [14:48:30] Starting &#39;default&#39;...</span>
<span style=color:#75715e>### [14:48:30] Finished &#39;default&#39; after 9.36 ms</span>
</code></pre></div><p>欲了解其他 Plugin／用法，可直接 <a href=https://gulpjs.com/>Gulp 官網</a>，或直接搜尋 <code>gulp + &lt;something></code>，神人都幫你做好了。</p>
<h3 id=webpack>Webpack<a hidden class=anchor aria-hidden=true href=#webpack>#</a></h3>
<p><a href=https://webpack.js.org/>Webpack</a> 是近幾年來最熱門的打包工具，透過解析模組之間的相依關係，可以</p>
<ul>
<li>把專案中 js、css、和其他靜態 assets 打包到同一個檔案中</li>
<li>將不同頁面／模組的<a href=https://webpack.js.org/guides/code-splitting/>程式碼分離（code splitting）</a></li>
<li>透過 <a href=https://webpack.js.org/concepts/loaders/>loader system</a>，轉換／編譯 Sass、Babel、TypeScript 甚至圖片等不同檔案 （多數情況下能取代 Gulp、Grunt 等工具）</li>
<li>運用不同的 Plugins，組合出適合自己的 Webpack 流程與設定。</li>
</ul>
<p>Webpack 最簡單的設定，就是在 project root 新增一個 <code>webpack.config.js</code> 檔案，以下範例取自 <a href=https://webpack.js.org/concepts/>Webpack 的核心觀念</a>（使用 Webpack 2）：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// in `webpack.config.js`
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>webpack</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;webpack&#39;</span>); <span style=color:#75715e>//to access built-in plugins
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>path</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;path&#39;</span>);

<span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>entry</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;./path/to/my/entry/file.js&#39;</span>,      <span style=color:#75715e>// 1. 程式進入點設定
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>output</span><span style=color:#f92672>:</span> {                                 <span style=color:#75715e>// 2. 打包輸出設定
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>path</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>path</span>.<span style=color:#a6e22e>resolve</span>(<span style=color:#a6e22e>__dirname</span>, <span style=color:#e6db74>&#39;dist&#39;</span>),
    <span style=color:#a6e22e>filename</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;bundle.js&#39;</span>
  },
  <span style=color:#a6e22e>module</span><span style=color:#f92672>:</span> {                                 <span style=color:#75715e>// 3. loaders（轉換檔案 -&gt; Javascript）
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>rules</span><span style=color:#f92672>:</span> [
      { <span style=color:#a6e22e>test</span><span style=color:#f92672>:</span> <span style=color:#e6db74>/\.jsx?$/</span>, <span style=color:#a6e22e>use</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;babel-loader&#39;</span> }
    ]
  },
  <span style=color:#a6e22e>plugins</span><span style=color:#f92672>:</span> [                                <span style=color:#75715e>// 4. 其他有用的 plugins
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>webpack</span>.<span style=color:#a6e22e>optimize</span>.<span style=color:#a6e22e>UglifyJsPlugin</span>(),
  ]
};
</code></pre></div><p>Webpack 的簡易運作流程如下：</p>
<pre tabindex=0><code>找到 entry file
-&gt; 解析相依模組
-&gt; 符合 test rules 的模組由 loaders 轉換處理
-&gt; 將所有處理完成的檔案打包成 output 的 js 檔
</code></pre><p>其中，在 <code>webpack.config.js</code> 設定檔中，最核心四個概念如下：</p>
<p><strong><code>entry</code></strong></p>
<p>程式進入點，webpack 會從這個（些）檔案開始解析所有相依（require／import）的模組、CSS、圖片（沒錯，Webpack 可以 import 圖片，將圖片視為模組）。一個可以有多個 entries。</p>
<p><strong><code>output</code></strong></p>
<p>打包完成的 <code>.js</code> 輸出的路徑設定，可根據多個 entries 輸出對應的 output。也可以利用內建的 <code>CommonsChunkPlugin</code> 來分離不同區塊／模組／套件的 output js 檔案。</p>
<p><strong><code>loaders</code></strong></p>
<p>任何使用 import／require 等關鍵字的 dependencies 都會被 webpack 解析，但 webpack 只認得 Javascript，所以需要許多 loaders 協助轉換，例如 <code>sass-loader</code>、<code>css-loader</code>、<code>babel-loader</code> 等。 每條 <code>rules</code> 利用 Regex 的 <code>test</code> 來區分哪些檔案使用哪些 loaders 處理，<code>use</code> field 則是指定對應的 loader，可以串連多個 loaders。</p>
<p><strong><code>plugins</code></strong></p>
<p>使用其他 plugins 來客製化 webpack 的打包結果，例如範例中內建的 <code>UglifyJsPlugin</code> 則是壓縮混淆最終輸出的 bundle.js，也有類似 <a href=https://github.com/webpack-contrib/extract-text-webpack-plugin/blob/master/README.md><code>extract-text-webpack-plugin</code></a> ，將 CSS 檔從 bundle.js 中分離等實用的 plugins。</p>
<p>Webpack 近幾年風生水起，生態系也應運而生。礙於篇幅，不少非常實用設定，以及 loaders 與 plugins 例如 <code>style-loader</code>、<code>url-loader</code>、<code>HtmlWebpackPlugin</code> 等，在此無法一一贅述，有興趣可以參考<a href=https://github.com/ruanyf/webpack-demos>這個教學</a>，也別忘了 <a href=https://webpack.js.org/>Webpack 2 最新的官網</a>。</p>
<h2 id=程式碼品質>程式碼品質<a hidden class=anchor aria-hidden=true href=#程式碼品質>#</a></h2>
<p>一份好的程式碼，除了可以正確無誤的執行，更要讓人易讀易維護，本節將介紹</p>
<ul>
<li>如何使用現代化的 JS 測試框架，讓你不再害怕自己寫的程式碼。</li>
<li>選擇一個好用的靜態語法檢查器，提高可讀性，減少人為失誤。</li>
</ul>
<h3 id=測試>測試<a hidden class=anchor aria-hidden=true href=#測試>#</a></h3>
<p>所有工程師都知道測試的好處，也了解測試的必要性，但卻很少人主動寫測試。傳統 <a href=https://en.wikipedia.org/wiki/Test-driven_development>TDD（<del>Trump-driven</del> Test-driven development）</a>的先寫測試，再寫程式的流程較不直觀，且易淪為為測試而測試，脫離現實。隨後崛起的 <a href=https://en.wikipedia.org/wiki/Behavior-driven_development>BDD（Behavior-driven development）</a>則漸趨主流，強調測試只應在「程式行為不符預期時失敗」，是測「程式做了什麼」，而不是「程式如何做這些事」。</p>
<p>一些 BDD 的測試框架與 BDD 斷言庫也順勢產生，透過語意化的 API，讓測試員更能了解程式到底「幹了啥事」，增添寫測試的樂趣。這裡主要介紹 <a href=https://mochajs.org/>Mocha</a> 測試框架，配合 <a href=http://chaijs.com/>Chai</a> 斷言庫，達成「快樂寫測試，寫測試快樂」的最高境界。</p>
<p><a href=https://mochajs.org/><code>mocha</code></a> 與 <a href=http://chaijs.com/><code>chai</code></a> 安裝與使用方法如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 安裝 mocha、chai 兩個套件</span>
npm install --save-dev mocha chai

<span style=color:#75715e># 建立一個 test 目錄</span>
mkdir test

<span style=color:#75715e># 使用預設編輯器開啟 test/test.js（第一個測試檔案）</span>
$EDITOR test/test.js
</code></pre></div><p>在你預設（或者你最喜愛）的編輯器裡，將下列測試加入 test/test.js</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>chai</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;chai&#39;</span>); <span style=color:#75715e>// 引入 `chai`（提供 asset／expect／should 風格斷言）
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>chai</span>.<span style=color:#a6e22e>should</span>(); <span style=color:#75715e>// 使用 should 前，需先執行 `chai.should()`，將 should 加到每個 Object
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>describe</span>(<span style=color:#e6db74>&#39;Array&#39;</span>, <span style=color:#66d9ef>function</span>() {          <span style=color:#75715e>// Test Suite
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>describe</span>(<span style=color:#e6db74>&#39;#indexOf()&#39;</span>, <span style=color:#66d9ef>function</span>() {   <span style=color:#75715e>// mocha 可嵌套 Test Suite，讓意圖更清晰
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>it</span>(<span style=color:#e6db74>&#39;should include 2&#39;</span>, <span style=color:#66d9ef>function</span>() { <span style=color:#75715e>// 實際的 Test Case
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>array</span> <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>5</span>];
      <span style=color:#a6e22e>array</span>.<span style=color:#a6e22e>should</span>.<span style=color:#a6e22e>include</span>(<span style=color:#ae81ff>2</span>);          <span style=color:#75715e>// 使用 should 風格進行斷言
</span><span style=color:#75715e></span>    });
  });
});
</code></pre></div><p>回到終端環境，執行以下指令：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 使用 mocha 模組的 command-line tool，進行測試</span>
./node_modules/.bin/mocha test/test.js
<span style=color:#75715e>###  Array</span>
<span style=color:#75715e>###    #indexOf()</span>
<span style=color:#75715e>###      ✓ should include 2</span>
<span style=color:#75715e>###</span>
<span style=color:#75715e>###  1 passing (10ms)</span>
</code></pre></div><blockquote>
<p>若希望直接執行 <code>mocha</code> 來測試，不想每次都加上模組路徑，可以</p>
</blockquote>
<ol>
<li>在全域安裝 <code>mocha</code> 套件 <code>npm install --global mocha</code></li>
<li>在 <code>package.json</code> 加入一個 run-script
<code>javascript "scripts": { // ... "test": "mocha path/to/your/test/dir/" } </code></li>
</ol>
<p>如果想建立 TDD 式的 <code>setUp</code>、<code>tearDown</code> hooks，可以如下設計：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>describe</span>(<span style=color:#e6db74>&#39;hooks&#39;</span>, <span style=color:#66d9ef>function</span> () {
  <span style=color:#a6e22e>before</span>(<span style=color:#66d9ef>function</span>() {
    <span style=color:#75715e>// 在這個 block 內所有 test case 之前執行
</span><span style=color:#75715e></span>  });
  <span style=color:#a6e22e>after</span>(<span style=color:#66d9ef>function</span> () {
    <span style=color:#75715e>// 在這個 block 內所有 test case 之後執行
</span><span style=color:#75715e></span>  });
  <span style=color:#a6e22e>beforeEach</span>(<span style=color:#66d9ef>function</span> () {
    <span style=color:#75715e>// 在這個 block 內每個 test case 之前執行
</span><span style=color:#75715e></span>  });
  <span style=color:#a6e22e>afterEach</span>(<span style=color:#66d9ef>function</span> () {
    <span style=color:#75715e>// 在這個 block 內每個 test case 之後執行
</span><span style=color:#75715e></span>  });
});
</code></pre></div><p>有需要非同步（異步）的測試，請</p>
<ol>
<li>在 test case 的 function params 加入 <code>done</code> 參數。</li>
<li>成功則調用 <code>done()</code>。</li>
<li>失敗則調用 <code>done(err)</code>，並加入 error 作為引數（argument）。</li>
</ol>
<p>這裡以 <code>Promise</code> 為例：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>describe</span>(<span style=color:#e6db74>&#39;Async Tests&#39;</span>, <span style=color:#66d9ef>function</span> () {
  <span style=color:#a6e22e>it</span>(<span style=color:#e6db74>&#39;should complete in the furture&#39;</span>, <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>done</span>) { <span style=color:#75715e>// 加入 done 參數
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>someAsyncPromiseTest</span>()  <span style=color:#75715e>// 一個異步的 Promise
</span><span style=color:#75715e></span>    .<span style=color:#a6e22e>then</span>((<span style=color:#a6e22e>result</span>) =&gt; {
      <span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>ok</span>(<span style=color:#a6e22e>result</span>);    <span style=color:#75715e>// 測試斷言
</span><span style=color:#75715e></span>      <span style=color:#a6e22e>done</span>();               <span style=color:#75715e>// 調用 done，通知 test runner 成功執行 async task
</span><span style=color:#75715e></span>    })
    .<span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>err</span>, (<span style=color:#a6e22e>err</span>) =&gt; {
      <span style=color:#a6e22e>done</span>(<span style=color:#a6e22e>err</span>);            <span style=color:#75715e>// 調用 done 並傳入 error，通知 test runner 執行異常
</span><span style=color:#75715e></span>    })
  });  
});

<span style=color:#75715e>// 由於 `done` 是一個函式，上式也可簡寫成
</span><span style=color:#75715e></span><span style=color:#a6e22e>describe</span>(<span style=color:#e6db74>&#39;Async Tests&#39;</span>, <span style=color:#66d9ef>function</span> () {
  <span style=color:#a6e22e>it</span>(<span style=color:#e6db74>&#39;should complete in the furture&#39;</span>, <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>done</span>) {
    <span style=color:#a6e22e>someAsyncPromiseTest</span>()
    .<span style=color:#a6e22e>then</span>((<span style=color:#a6e22e>result</span>) =&gt; {
      <span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>should</span>.<span style=color:#a6e22e>equal</span>(<span style=color:#e6db74>&#39;well done&#39;</span>);
      <span style=color:#a6e22e>done</span>();          
    })
    .<span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>done</span>); <span style=color:#75715e>// 直接傳入 done！
</span><span style=color:#75715e></span>  });  
});
</code></pre></div><blockquote>
<p>如果需要非同步的 hooks，同樣加入 <code>done</code> 參數，並調用 done。</p>
</blockquote>
<p>其他相關 mocha 語法 API，<a href=https://mochajs.org/>mocha 網站</a>寫得非常清楚。有關斷言的寫法，也可直接參考 <a href=http://chaijs.com/>chai 官網</a>。</p>
<h3 id=靜態程式語法檢查>靜態程式語法檢查<a hidden class=anchor aria-hidden=true href=#靜態程式語法檢查>#</a></h3>
<p>使用<a href=https://en.wikipedia.org/wiki/Integrated_development_environment>整合開發環境（IDE）</a>的童鞋，想必對<a href=https://en.wikipedia.org/wiki/Lint_(software)>靜態語法檢查</a>有深刻體會。使用靜態語法檢查，會對程式碼撰寫的風格有所限制，但同時可以可防止許多 <a href=https://en.wikipedia.org/wiki/Code_smell>bad code smell</a>，例如：</p>
<ul>
<li><a href=https://eslint.org/docs/rules/handle-callback-err>一定要處理 error</a></li>
<li><a href=https://eslint.org/docs/rules/no-const-assign>避免修改以 const 宣告的變數</a></li>
<li><a href=https://eslint.org/docs/rules/no-unexpected-multiline>不要用 <code>(</code> <code>/</code> <code>.</code> <code>,</code> 等符號當開頭</a>（不寫分號唯一會遇到的問題！）</li>
</ul>
<p>Javascript 的 linter 有非常多套，這裡選用目前最流行、客製化程度最高的 <a href=https://eslint.org/>ESLint</a> 作範例。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># 安裝 eslint</span>
npm install --save-dev eslint

<span style=color:#75715e># 互動式建置 `.eslint.js` 配置文件</span>
./node_modules/.bin/eslint --init

<span style=color:#75715e># 之後就可以直接用 eslint 來檢查你的程式碼了</span>
./node_modules/.bin/eslint path/to/your/file.js
</code></pre></div><blockquote>
<p>同樣地，可以在 <code>package.json</code> 加入一個 run-script，方便隨時 lint</p>
</blockquote>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#e6db74>&#34;scripts&#34;</span><span style=color:#f92672>:</span> {
  <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>  <span style=color:#e6db74>&#34;lint&#34;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;eslint .; exit 0;&#34;</span> <span style=color:#75715e>// 有錯誤的話 eslint exit code 是 1， 我們手動 exit 0 以避免 npm 報錯。
</span><span style=color:#75715e></span>}
</code></pre></div>
<blockquote>
<p>有些檔案不需要 linter 檢查（例如 test spec、其他套件的 config），可在 project root 加入 <code>.eslintignore</code> 忽略這些檔案（<a href=https://git-scm.com/docs/gitignore#_examples>寫法同 <code>.gitignore</code></a>）。</p>
</blockquote>
<p>通常我們會用一些大廠的設定，簡化我們的 Linter config，例如使用 <a href=https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb>Airbnb Javascript style</a>，如果需要客製化 linter 可以參考 <a href=https://eslint.org/docs/user-guide/configuring>ESLint 如何配置</a>。</p>
<p>許多文字編輯器有整合的 eslint 的 plugin（如 <a href=https://atom.io/packages/linter-eslint>Atom</a>、<a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">Visual Studio Code</a>），可即時查看 lint 結果，讓開發者更容易檢查語法錯誤。</p>
<h2 id=小結>小結<a hidden class=anchor aria-hidden=true href=#小結>#</a></h2>
<p>本想簡單介紹如何建置一個前端開發環境，無奈前端之龐大，初出茅廬的我，完全無法收斂文章內容。本文已盡量點到為止，在重要之處皆留下關鍵連結，給有興趣的人們挖了些坑，希望看倌透過這篇文章，能對前端工程紛擾的世界有所了解，也不吝指教交流！</p>
<h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2>
<ul>
<li><a href=https://nodejs.org/api/>Node.js API Documentation</a></li>
<li><a href=https://github.com/creationix/nvm>NVM - Node Version Manager</a></li>
<li><a href=https://www.npmjs.com/>NPM - Node Package manager</a></li>
<li><a href=https://docs.npmjs.com/getting-started#cli>NPM Cli Commands</a></li>
<li><a href=https://docs.npmjs.com/files/package.json>NPM package.json spec</a></li>
<li><a href=https://developer.mozilla.org/>Mozilla Developer Network</a></li>
<li><a href=https://gulpjs.com/>Gulp - The streaming build system</a></li>
<li><a href=https://webpack.js.org/>Webpack - A bundler for javascript and friends</a></li>
<li><a href=https://mochajs.org/>Mocha - Feature-rich Test Framework</a></li>
<li><a href=http://chaijs.com/>Chai - BDD/TDD Assertion Library</a></li>
<li><a href=https://eslint.org/>ESLint - Pluggable JavaScript Linter</a></li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://weihanglo.tw/tags/node.js/>Node.js</a></li>
<li><a href=https://weihanglo.tw/tags/javascript/>JavaScript</a></li>
<li><a href=https://weihanglo.tw/tags/front-end/>Front-end</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://weihanglo.tw/posts/2017/swift-error-handling/>
<span class=title>« Prev Page</span>
<br>
<span>理解 Swift 的 Error Handling</span>
</a>
<a class=next href=https://weihanglo.tw/posts/2017/carthage-intro/>
<span class=title>Next Page »</span>
<br>
<span>Carthage 套件管理工具</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>CC BY-NC-SA 4.0</span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>