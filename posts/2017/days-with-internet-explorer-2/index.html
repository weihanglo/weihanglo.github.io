<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>與 IE 相處的日子二：淺談網頁相容性 | Weihang Lo</title>
<meta name=keywords content="Internet Explorer,Front-end,JavaScript,Web Compatibility,Web Access Right">
<meta name=description content="還記得之前整理的 IE 相容性 一文嗎？筆者最近參與公司新版 Web App 架構規劃與開發，又遇到許多相容性的問題，連新版瀏覽器也無法倖免。就讓我們再次探討瀏覽">
<meta name=author content>
<link rel=canonical href=https://weihanglo.tw/posts/2017/days-with-internet-explorer-2/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://weihanglo.tw/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://weihanglo.tw/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://weihanglo.tw/favicon-32x32.png>
<link rel=apple-touch-icon href=https://weihanglo.tw/apple-touch-icon.png>
<link rel=mask-icon href=https://weihanglo.tw/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:!0},{left:'$',right:'$',display:!1},{left:'\\(',right:'\\)',display:!1},{left:'\\[',right:'\\]',display:!0}],throwOnError:!1})})</script>
<meta property="og:title" content="與 IE 相處的日子二：淺談網頁相容性">
<meta property="og:description" content="還記得之前整理的 IE 相容性 一文嗎？筆者最近參與公司新版 Web App 架構規劃與開發，又遇到許多相容性的問題，連新版瀏覽器也無法倖免。就讓我們再次探討瀏覽">
<meta property="og:type" content="article">
<meta property="og:url" content="https://weihanglo.tw/posts/2017/days-with-internet-explorer-2/">
<meta property="og:image" content="https://weihanglo.tw/build-websites-for-web.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2017-12-09T18:48:48+08:00">
<meta property="article:modified_time" content="2017-12-09T18:48:48+08:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://weihanglo.tw/build-websites-for-web.png">
<meta name=twitter:title content="與 IE 相處的日子二：淺談網頁相容性">
<meta name=twitter:description content="還記得之前整理的 IE 相容性 一文嗎？筆者最近參與公司新版 Web App 架構規劃與開發，又遇到許多相容性的問題，連新版瀏覽器也無法倖免。就讓我們再次探討瀏覽">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://weihanglo.tw/posts/"},{"@type":"ListItem","position":3,"name":"與 IE 相處的日子二：淺談網頁相容性","item":"https://weihanglo.tw/posts/2017/days-with-internet-explorer-2/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"與 IE 相處的日子二：淺談網頁相容性","name":"與 IE 相處的日子二：淺談網頁相容性","description":"還記得之前整理的 IE 相容性 一文嗎？筆者最近參與公司新版 Web App 架構規劃與開發，又遇到許多相容性的問題，連新版瀏覽器也無法倖免。就讓我們再次探討瀏覽","keywords":["Internet Explorer","Front-end","JavaScript","Web Compatibility","Web Access Right"],"articleBody":"還記得之前整理的 IE 相容性 一文嗎？筆者最近參與公司新版 Web App 架構規劃與開發，又遇到許多相容性的問題，連新版瀏覽器也無法倖免。就讓我們再次探討瀏覽器相容性吧！\n（撰於 2017-12-09，基於各種莫名其妙的狀況)\n 對相容性問題細節沒興趣的朋友，可直接跳到「我能為網頁相容性做什麼」這個章節。\n 目錄  相容性問題一覽 我能為網頁相容性做什麼  如果你是網頁使用者 如果你是網頁開發者   結語  相容性問題一覽 這邊列出這段紀錄的相容性問題：\n 語意化 HTML5 標籤 不支援 const 宣告 沒有 append 和 prepend convenience methods XHR 不支援 JSON CustomEvent 沒有建構函式 flex-grow 需要 absolute height  上的 text-align 沒作用 Element 連結到 DOM 前 getComputedStyle 沒有預設值 style Computed Style 行為不一致 iframe 不支援 Data URI iframe 不支援 width 與 height style SCRIPT70: Permission denied TypedArray 少了些高階函式 不支援 custom namespace attribute selector scrollWidth 與 scrollHeight 搞反了 Multi-column layout 需給定 absolute column-width 過時的 writing-mode 標準 不穩定的 scrollWidth 與 scrollHeight  語意化 HTML5 標籤  Issue：不支援語意化 tag 就算了，部分 tag 如 、 還會變成 inline elements Platform：IE 11  先來個簡單的 issue。 這個 bug 默默記在心上就好，在 IE 仍苟延殘喘的年代，如要使用 semantic element，記得加上 display: block 吧！\n不支援 const 宣告  Issue：iOS 9 不支援 const 宣告變數 Platform：iOS 9 Safari  實際上來說，這不是 bug，也跟開發的 source code 無關，而是 Webpack Dev Server 的 Caveats，Webpack Dev Server 2.8.0 以上只支援瀏覽器支持 const 的環境，如果你升級 Dev Server 後遇到麻煩，請把版號固定在 2.7.1 吧！\n沒有 append 和 prepend convenience methods  Issue：不提供 append／prepend 這些類似 jQuery 的 DOM 操作方法 Platform：IE 11  2006 年釋出的 jQuery，現在仍被廣泛使用，其 API 設計規範如 event delegation、on/off，和其他 DOM manipulation 深深影響近代 JavaScript Library 的設計流。\n以下這幾個 DOM manipulation convenience methods 很明顯看出影響甚鉅：\n ChildNode.before ChildNode.after ChildNode.replaceWith ParentNode.prepend ParentNode.append  講這麼多都沒用，這些 method 在 IE 11 完全不支援！當然，肯定有 polyfill，這裡也示範一下怎麼利用 DOM3 的 API 達到 ParentNode.prepend 的效果。\n// Add  tag for dynamic base URL modification const base = document.createElement('base') base.setAttribute('href', baseURL) const head = doc.documentElement.querySelector('head') head.insertBefore(base, head.firstElementChild) // IE has no `prepend` method.  在導入 polyfill 之前，記得先想清楚專案的環境，別導入一整包卻只用到一兩個 method。\n XHR 不支援 JSON  Issue：IE 不支援 XMLHttpRequest v2 使用 JSON 作為 responseType Platform：IE 11  Ajax 技術中最有代表性的概念就是 XHR（XMLHttpRequest），非同步的技術讓 web content 可以動態更新，這可算是 Microsoft 對 web 貢獻之一（雖然最後是 Mozilla Gecko 引擎先在 browser 實作了）。我們很感謝 IE 不辭辛勞付出，但不代表能不遵從 web standard。IE 至今（2017/11）仍未完全實作 XHR v2 的 spec（請參考 XHR Living Standard，沒辦法支援 JSON as returning value。\n就算未來 client request 會逐漸被 fecth API 取代，我們仍該好好處理瀏覽器向下相容性，畢竟 fetch API 目前只能透過 AbortController 取消 request，而且只有 Firefox 57 和 Edge 16 有實作，這時候就凸顯出 xhr.abort 的重要性。\n如果想要 XHR 支援 IE 11 又要回傳 JSON，解法就是全部都用 response 再從 responseType 判斷需不需要 parse JSON。簡單作法如下：\nfunction request ({ method = 'GET', responseType = 'arraybuffer', uri, body, }) { const xhr = new XMLHttpRequest() xhr.open(method, uri) // IE 11 does not support `json` as `responseType`.  // We must parse json text manually.  const asJson = responseType === 'json' xhr.responseType = asJson ? 'text' : responseType xhr.onload = function (ev) { const body = asJson ? JSON.parse(this.response) : this.response console.log(body) } body ? xhr.send(body) : xhr.send() } CustomEvent 沒有建構函式  Issue： CustomEvent 沒有 constructor Platform：IE 11  IE 11 上不能透過 new CustomEvent 建構新的 CustomEvent，只能從透過 document.createEvent，再從 event.initCustomEvent 建構。MDN 上簡單的 constructor polyfill 可以解決這個小問題。\n// CustomEvent Polyfill for IE (function () { if (typeof window.CustomEvent === 'function') { return } function CustomEvent (event, params) { params = params || { bubbles: false, cancelable: false, detail: undefined } var evt = document.createEvent('CustomEvent') evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail) return evt } CustomEvent.prototype = window.Event.prototype window.CustomEvent = CustomEvent })() flex-grow 需要 absolute height  Issue：flex item 沒設定 absolute height，chilNode 長不出來 Platform：IE 11／Safari 11  某些情況，我們並不知道 flex container 有幾個的 flex item，會希望 item 寬高自動增減。但當 flex-direction 設置為 column 時，若 flex item 內的 childNode 需要佔滿 parent 100% 的高度，此時會找不到 parent（flex item）可參考的 height，因此渲染出 height: auto 的樣式。\n這個 stackoverflow 詳細解釋上述的情況。這邊總結它提供的幾種解法：\n1. 將所有 parent element 都設置絕對高度 （absolute height）\n這應該不用解釋了，完全正確，幾乎沒什麼相容性問題。\n2. parent element 設置為相對位置；child 設為絕對位置佔滿 parent 的空間\n parent ➡ position: relative child ➡ top: 0; left: 0; right: 0; bottom: 0  3. 移除多餘的 HTML container 👍\n有時候 layout 會錯，就是因為嵌套太多層不必要的 ，其實只要適時移除部分 container，重新組織，通常都能輕鬆解決問題。\n4. 直接使用多層 flex container 👍\n將沒有 absolute height 的 flex item 設置為 display: flex，align-items 會自動設為 stretch，child node 自己就會擴張到 100% height 了。\n 上的 text-align 沒作用  Issue： 不吃 text-align CSS Platform：iOS 11 Safari  這應該是一個 bug，快速的解法就是給他一個 container。\nHTML\ndiv button class=\"not-centered\"Not Centeredbutton button class=\"centered\" spanCenteredspan button div CSS\n.not-centered { text-align: center; } .centered  span { display: inline-block; text-align: center; } Element 連結到 DOM 前 getComputedStyle 沒有預設值 style  Issue：在 Element connect（append） 到 DOM 之前，使用 getComputedStyle 取得的 style 只會是空字串。 Platform： Webkit-based browsers  這是一個蠻有趣的小差異，Webkit-based browsers（Chrome、Safari）在 element append 到 DOM 之前，computedstyle 的每一個 property 都是空字串；而 Gecko 和 Trident／EdgeHTML 這些 engine 都會有 default value。\n筆者並沒有深入研究哪一家的實作比較符合符合 CSSOM 的規範，這個差異可以謹記在心就好。實務上最好「避免在 element append 到 DOM 之前存取 computed style」。\nComputed Style 行為不一致  Issue： getComputedStyle 回傳的 CSSStyleDeclaration 行為不一致。 Platform：IE 11／Edge 15  IE／Edge 對 CSSStyleDelclaration 下每一個 style 的處理方法似乎不盡相同，尤其是使用 JavaScript 操作 shorthand style 最容易出問題。例如：getComputedStyle(el).backgroundPositionX 這種直接存取 style 的方法不穩定，使用 getComputedStyle(el).getPropertyValue('background-position-x') 比較能取得有效的值。但是 getComputedStyle(el).getPropertyValue('border-width') 或是 getComputedStyle(el).borderWidth 只能取到空字串。WTF。\n除此之外，假設我們現在有一個 element，要取得 background position 就算畫面已經渲染了，只要你使用 keyword value 賦值，IE 還是取到前一個設定值，這實在是蠻神奇的，情境如下：\n// 使用 keyword value 設定 div.style.backgroundPosition = 'bottom 20px left' getComputedStyle(div).backgroundPosition // Other: \"0% calc(-20px + 100%) // IE: \"0% 0%\" 總之，在 IE／Edge 的世界裡，別太相信 getComputedStyle 會自動更新這種鬼話。\niframe 不支援 Data URI  Issue：iframe.src 不支援 data URI 作為參數 Platform：IE 11／Edge 15／Chrome on iOS  根據 MSDN 文件指出，微軟出品的瀏覽器的 Data URI 只支援下列 elements 與 attributes：\n  (images only)   type=image  會用到 URL 的 CSS style，例如 background、backgroundImage  由於某些需求，筆者需要在 HTML document 傳入 iframe 前做些處理，再利用 BlobURL 的方式傳入 iframe.src，但顯然 iframe 根本不在上列中。實力堅強的讀者也許會說：「不能用 src 那就用 srcdoc 傳參吧！」可惜的是 srcdoc 連 Edge 17 都不支援。\n如果你同樣要處理 HTML document，推薦一個相容 IE 的作法「使用 document.write」。\n// ❌ Original implmentation const blob = new Blob( [doc.documentElement.outerHTML], { type: 'text/html' } ) const src = URL.createObjectURL(blob) iframe.src = src // 👌 Compatible implementation iframe.contentDocument.open() iframe.contentDocument.write(doc.documentElement.outerHTML) iframe.contentDocument.close() 就是這麼噁心。\n Chrome on iOS 實際上應該有支援 blob URL。筆者在開發時發現 iOS 11 下 Chrome 62 無法支援 blob URL，不過 iOS 11 的 Mobile Safari 可行。因此猜測是，與 Chrome 使用 WKWebView 一些 config 相牴觸，觸發 CSP 或 CORS 等等設定錯誤。\n iframe 不支援 width 與 height style   Issue： iOS Safari 上 iframe 不支援 percentage width/height style。\n  Platform：iOS Safari\n  事實上，iOS Safari 支援 min-height，min-width 使用百分比寬高。我們暫時的解法就是先給 iframe 一個絕對的長度，再利用最小寬高達成目的。\n/* 給 1px，再設置 min-width 讓 iframe 長到 100% */ iframe { width: 1px; min-width: 100%; } 真是謝了 Safari。\nSCRIPT70: Permission denied  Issue：IE／Edge 無法注入部分 script 到 iframe。 Platform：IE 11／Edge 15  Stackoverflow 上都說這是 IE 最惡名昭彰的嚴格規定，會產生 SCRIPT70 的原因不少，最常見的是：ifame 與 main frame 不同 Domain，但注入 iframe 的 script 試圖修改 main frame 的資料。\n筆者遇到 Script70 的情境是把 iframe.contentDocument 丟進 react-redux 的 container component 中，剛好 ifame.src 又是一個 Blob URL，不知道 IE 底層怎麼判斷的，反正這個 blob URL 被當作 cross domain，甚至修改 document.domain 也沒有作用。 其他直接 query/append/modify iframe DOM 都沒有遇到上述的問題。\nWorkaround 就是檢查每一個 iframe 是否為 same origin，如果有其他更好的方法，歡迎大家提供。\nTypedArray 少了些高階函式  Issue：不支援 TypedArray 高階函式，例如 map、reduce、filter Platform：IE 11／Edge 15  基本上，導入 Babel 轉譯應該可以順利解決，但某些 context 下我們並不會導入 Babel 轉譯，如 web worker thread 或是 iframe content。尤其是 web worker 很容易被拿來操作 binary data，更要將這個缺失牢記在心。\n簡單的 polyfill 如下：\n// IE does not support TypedArray#map. Do it ourself. // We polyfilled for only Uint8Array#map here. if (Array.prototype.hasOwnProperty('map') \u0026\u0026 !Uint8Array.prototype.hasOwnProperty('map')) { Uint8Array.prototype.map = function (f) { return new Uint8Array([].map.call(this, f)) } } 不支援 custom namespace attribute selector  Issue：不支援 Custom namespace attribute selector（常見於 XML 操作） Platform：IE 11／Edge 15  我們都知道 XML 可以說是「嚴格版」的 HTML，XML 有許多 HTML 沒有的特點，例如現在要介紹的 custom namespace attribute。\n在 Document 中，要取得含有特定 attribute 的 element，我們會使用 CSS attribute selector。\n// Fetch  element document.querySelector('a[href]') 當這個 document 是 XMLDocument 時，element 或 attribute 可以有 namespace，如\n epub:type=\"toc\" id=\"toc\"` 我們會很直覺地把 epub:type 當作 attribute name 去 query，但這樣是行不通的，需要 escape :，但試了幾次之後發現，下列四種方法都沒有完整的相容性，。\n// ❌ Not work document.querySelector('nav[epub:type=\"toc\"]') // ❌ Not work document.querySelector('nav[epub|type=\"toc\"]') // ❌ Not work in IE and Edge (glob namespace selector ) document.querySelector('nav[*|type=\"toc\"]') // ❌ Not work in IE and Edge (escaping) document.querySelector('nav[epub\\\\:type=\"toc\"]') 最後的解法就是把所有 element 取出來，再判斷有沒有對應的 attribute。\n以下程式碼可能引發胸悶、頭暈、血壓驟升，呼吸困難，有程式碼潔癖者請斟酌觀賞。\nlet toc = document.querySelector(`nav[epub\\\\:type=\"toc\"]`) // Fallback to use manual assignment for browsers not supporing custom // namespace attribute selector. (IE and Edge. LOL) if (!toc) { const tocs = this._dom.querySelectorAll('nav') const pattern = /toc/i for (let i = 0; i  tocs.length; i++) { if (pattern.test(tocs[i].getAttribute('epub:type'))) { toc = tocs[i] break } } } scrollWidth 與 scrollHeight 搞反了  Issue：在 writing-mode 為 vertical-lr 或 vertical-rl 下，Edge 把 scrollWidth 和 scrollHeight 搞反了。 Platform：Edge 15  ⬅⬅ 閱讀方向 ⬅⬅\n其實這個 scrollWidth scrollHeight 互相調換很符合邏輯，預設橫式書寫的 content flow 是上下，一行寫滿，content 會繼續往下長，所以 scrollWidth 會不斷增加；而直式書寫正好相反，是往左右增長，所以 scrollHeight 會持續成長。\n然而，Edge 15 卻在直式書寫時忘記將 scrollWidth 與 scrollHeight 角色互換。解法就是自己判斷 User Agent 再換回來。\nconst verticalPattern = /vertical|^tb-|-lr$|^bt-/i const writingMode = window.getComputedStyle(el).writingMode const scrollWidth = detectEdge() \u0026\u0026 verticalPattern.test(writingMode) ? el.scrollHeight : el.scrollWidth Multi-column layout 需給定 absolute column-width  Issue：一定要給定 absolute column-width，CSS multi-column 才有作用 Platform：Safari 11／iOS 11 Safari  這是一個很神奇的 issue，根據 CSS Multi-column layout 的標準定義，當 column-width: auto 是，欄數會由其他屬性如 column-count 決定。但實際上在 Webkit 上給 column-count 一個整數欄數是沒有效果的。\n幸好，column-count 除了可以決定欄數，當 column-width 也是一個非 auto 的長度值時，column-count 代表最大欄數。我們可以利用這個特性 work around。解法就是加一個 1px 的 column-width。\n.multi-column { column-width: 1px; column-count: 2; } 這樣就可以正確分頁分欄了！\n過時的 writing-mode 標準  Issue：仍只支持舊版的 writing-mode 標準 Platform：IE 11／Edge 15  writing-mode 這種冷僻的 CSS property，除了開發電子書（或閱讀器），以及特殊的設計需求，一般開發者大概一輩子都不會碰到。好巧不巧筆者的工作就是前者。\nwriting-mode 會改變 block level content flow direction，意思就是 block element 會朝不同的方向堆疊（預設是 top-down），而 block container 內的 inline-level content 也會以這個方向排列。CSS 3 總共定義 3 個 keyword value，語意非常直白。\n horizontal-tb：inline content 以水平方向排列，block content 由上而下流動。 vertical-rl：inline content 以垂直方向排列，block content 由右至左流動。 vertical-lr：inline content 以垂直方向排列，block content 由左至右流動。  可惜的是， IE 和 Edge 兩個活寶對新的標準支援有限，只能繼續使用 lr lr-tb rl tb tb-rl 這些舊 spec。相容的寫法就是新舊兩種都寫進去吧！\n.vertical-content { -ms-writing-mode: tb-rl; writing-mode: tb-rl; -webkit-writing-mode: vertical-rl; writing-mode: vertical-rl; } 其實 writing mode 蠻有趣的，現在 Firefox 甚至實作 CSS 4 最新的 sideways 標準，大家可以玩玩看！\n不穩定的 scrollWidth 與 scrollHeight  Issue：不穩定的 scrollWidth／scrollHeight，會因 position 變動而改變 Platform：Safari 11／iOS 11 Safari  一個 element 的 scrollWidth 與 scrollHeight，依照 CSSOM 中的 scrolling area 定義，以 element 的 padding edges 或是 descendant（child node）的 border edges 為依據計算。當 element 本身與其 children 的 edges 不變，理論上改變座標位置移動 element，scrolling area 並不會變動。\n很可惜的是 Safari 的實作出了包。當你變動一個 positioned element 的 left、top 這些 positioning properties 時，scrollWidth 與 scrollHeight 是會變動的。\n如果你需要在 position 變動之後對 scrolling area 做些計算，可以「先移動回初始位置」，再存取 scrollWidth 或 scrollHeight，這是使 scrolling area 資料正確最保險的作法。\n Safari 11 能有這種 issue 真的很厲害！\n 我能為網頁相容性做什麼 網頁相容性是什麼 我們可能會很好奇，為什麼手機 App 需要針對 iOS、Android 分別開發，而且開發流程、工具大相逕庭，而網頁卻不需要針對每個瀏覽器重頭開發？這是因為在網際網路後面，有許多人致力於訂定各種網路標準，例如 W3C 與 IETF 等組織。而各大網路瀏覽器廠商就針對這些標準開發自家的產品，讓人們可以無痛地使用各式各樣的瀏覽器暢遊網路。\n但標準何其多？各家廠商挑選對自己有利的標準來實作。對標準實作程度不一，就產生了相容性的問題，A 網站用 Chrome 可以正確顯示，但可能在 Firefox 排版歪了一邊。而許多網頁開發商為了節省成本，決定「西瓜偎大邊」，只針對某些特定的瀏覽器最佳化，犧牲小眾瀏覽器使用者的使用權。例如這些只針對 Google Chrome 最佳化的事件，連 Chrome 的開發者自己都看不下去了。而這些事件累積起來，消費者只會看見某些瀏覽器的好像相容性不好，有些網頁開不了，而強勢瀏覽器就強者越強。\n完全錯了！網路的初衷不該是這樣，使用網路就像基本人權一樣，沒有人應該被限制只能用特定的方式瀏覽特定的網頁，沒有人應該被剝奪網路使用權。而這正是為什麼我們需要致力於消弭各瀏覽器間的差異，提高網頁相容性的原因。\n能幫助提升網頁相容性的方法很多，以下簡單分享一些方法。\n如果你是網頁使用者 你可以到一個網站 Webcompat.com 回報網頁錯誤。Webcompat.com 是一個志願者開發的網站，致力於搜集所有網站，所有使用者，所有瀏覽器的網頁相容性問題。Webcompat.com 搜集到問題之後，會先診斷問題的源頭，再根據診斷結果找到對應的開發商（可能是瀏覽器開發商或是網頁開發商）。你可以直接到 Webcompat.com 按下 Report Bug 回報你遇到的問題，也可以在各主流瀏覽器的 addons 市集找到相對應的附加元件，更快速地回報臭蟲。\n如果說你對特定網站情有獨鍾，你可以自行聯絡該網站開發商，請他們檢查並修正你發現的網頁臭蟲，這個方法其實就是 Webcompat.com 的第三個步驟「Site Outreach」。\n另外，你還可以選擇相對小眾的瀏覽器，減低部分廠商獨佔市場的現象，這就像人們開始會採購小農的生鮮蔬果和農產品一樣自然，讓市場更多元，更有生命力。這種方法的技術門檻相對較低，很適合關心網頁相容性以及瀏覽器獨佔問題，但不懂技術的民眾。\n最後，請記得升級瀏覽器，確保自己用的瀏覽器正確實作網頁標準，讓每個舊版過時的產品能夠安全退場。這不僅是為了確保網頁相容性，也可以降低網路資安事件的發生，更能解放開發者的生產力，把產能專注在改善人類生活，而不是對舊式的瀏覽器修修補補。（拜託不要再用 IE 了！）\n如果你是網頁開發者 身為一個住在自由地區的網頁開發者，要有一種使命感：\n A person should be able to use the Web with any devices and browsers. — Mozilla Wiki\n 對筆者來說，這句話就是網路相容性的終極目標。在開發網頁時，需時時刻刻測試網頁在主流的瀏覽器的體驗是否一致，在行動載具或筆電上是否皆能正確執行。這不是為了觸及更多使用者賺更多錢（雖然老闆應該是這樣想），是為了讓不同族群能夠無礙的使用網頁。如果把網頁視為人類的知識累積，那這些珍貴的知識就不應該只讓少數人把持。\n大多開發者想像中的網頁相容性可能是 CSS 相容啊，有沒有支援 ES6 語法啊，需不需要裝 Promise polyfill 等等。但很多人不知道，Accessbility 也是網頁相容性的一環。對身心不方便的朋友，我們更需要照顧到他們的需求，讓這些朋友能夠跟無畏的使用網路。Wendell Liu 這一篇 A11y 的文章 寫得非常清楚，不妨花時間讀一讀，肯定會收穫滿滿！。\n最後，同樣是 Accessiblity，偏鄉網路存取權也是常被漠視的一環。在政府大力推行 E 化政策之下，透過網路學習或辦公對年輕一代已是稀鬆平常的事情，但對某些沒有網路或是網路訊號不好的地區，在網路上傳或下載資料都是一件很痛苦的事情，開發商應該好好評估網路頻寬，減少不必要的封包傳輸，提升網站的效能。並在必要時提供訊號不佳的地區一個替代方案（例如 Facebook Lite 這種作法）。Mozilla 的 IRL Podcast 就有一期在介紹網路存取權，大家都知道網路存取權在這個時代可謂基本人權，那「迅速有效的網路存取，是奢侈品，還是百姓的權利呢？」我認為這個議題非常值得思考。\n 題外話：IRL 這個 podcast 在探討網路與生活間交互作用，主軸就是 Our online life is real life，內容有趣又不失深度，對英文廣播有興趣的朋友可以參考。\n 結語 網頁相容性對前端開發來說非常重要，但也相對繁雜，許多人避之唯恐不及。筆者經手開發的軟體之受眾剛好是圖書館，而圖書館又是許多缺乏網路存取管道的朋友接觸網路的一個窗口，網路存取權與相容性更顯重要。雖然支援舊版瀏覽器真的很惱人（看那精美的 issue list），但仍要不斷提醒自己：\n這就是身為前端工程師的使命。\n","wordCount":"6885","inLanguage":"en","image":"https://weihanglo.tw/build-websites-for-web.png","datePublished":"2017-12-09T18:48:48+08:00","dateModified":"2017-12-09T18:48:48+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://weihanglo.tw/posts/2017/days-with-internet-explorer-2/"},"publisher":{"@type":"Organization","name":"Weihang Lo","logo":{"@type":"ImageObject","url":"https://weihanglo.tw/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://weihanglo.tw accesskey=h title="Weihang Lo (Alt + H)">Weihang Lo</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://weihanglo.tw/ title=Home>
<span>Home</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/posts/ title=Posts>
<span>Posts</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
與 IE 相處的日子二：淺談網頁相容性
</h1>
<div class=post-meta><span title="2017-12-09 18:48:48 +0800 +0800">December 9, 2017</span>&nbsp;·&nbsp;14 min
</div>
</header>
<figure class=entry-cover><img loading=lazy src=https://weihanglo.tw/build-websites-for-web.png alt="Modified from Webcompat.com">
<p>Modified from Webcompat.com</p>
</figure><div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e7%9b%ae%e9%8c%84 aria-label=目錄>目錄</a></li>
<li>
<a href=#%e7%9b%b8%e5%ae%b9%e6%80%a7%e5%95%8f%e9%a1%8c%e4%b8%80%e8%a6%bd aria-label=相容性問題一覽>相容性問題一覽</a><ul>
<li>
<a href=#%e8%aa%9e%e6%84%8f%e5%8c%96-html5-%e6%a8%99%e7%b1%a4 aria-label="語意化 HTML5 標籤">語意化 HTML5 標籤</a></li>
<li>
<a href=#%e4%b8%8d%e6%94%af%e6%8f%b4-const-%e5%ae%a3%e5%91%8a aria-label="不支援 const 宣告">不支援 <code>const</code> 宣告</a></li>
<li>
<a href=#%e6%b2%92%e6%9c%89-append-%e5%92%8c-prepend-convenience-methods aria-label="沒有 append 和 prepend convenience methods">沒有 <code>append</code> 和 <code>prepend</code> convenience methods</a></li>
<li>
<a href=#xhr-%e4%b8%8d%e6%94%af%e6%8f%b4-json aria-label="XHR 不支援 JSON">XHR 不支援 JSON</a></li>
<li>
<a href=#customevent-%e6%b2%92%e6%9c%89%e5%bb%ba%e6%a7%8b%e5%87%bd%e5%bc%8f aria-label="CustomEvent 沒有建構函式">CustomEvent 沒有建構函式</a></li>
<li>
<a href=#flex-grow-%e9%9c%80%e8%a6%81-absolute-height aria-label="flex-grow 需要 absolute height">flex-grow 需要 absolute height</a></li>
<li>
<a href=#button-%e4%b8%8a%e7%9a%84-text-align-%e6%b2%92%e4%bd%9c%e7%94%a8 aria-label="&amp;lt;button&amp;gt; 上的 text-align 沒作用"><code>&lt;button></code> 上的 <code>text-align</code> 沒作用</a></li>
<li>
<a href=#element-%e9%80%a3%e7%b5%90%e5%88%b0-dom-%e5%89%8d-getcomputedstyle-%e6%b2%92%e6%9c%89%e9%a0%90%e8%a8%ad%e5%80%bc-style aria-label="Element 連結到 DOM 前 getComputedStyle 沒有預設值 style">Element 連結到 DOM 前 getComputedStyle 沒有預設值 style</a></li>
<li>
<a href=#computed-style-%e8%a1%8c%e7%82%ba%e4%b8%8d%e4%b8%80%e8%87%b4 aria-label="Computed Style 行為不一致">Computed Style 行為不一致</a></li>
<li>
<a href=#iframe-%e4%b8%8d%e6%94%af%e6%8f%b4-data-uri aria-label="iframe 不支援 Data URI">iframe 不支援 Data URI</a></li>
<li>
<a href=#iframe-%e4%b8%8d%e6%94%af%e6%8f%b4-width-%e8%88%87-height-style aria-label="iframe 不支援 width 與 height style">iframe 不支援 width 與 height style</a></li>
<li>
<a href=#script70-permission-denied aria-label="SCRIPT70: Permission denied">SCRIPT70: Permission denied</a></li>
<li>
<a href=#typedarray-%e5%b0%91%e4%ba%86%e4%ba%9b%e9%ab%98%e9%9a%8e%e5%87%bd%e5%bc%8f aria-label="TypedArray 少了些高階函式">TypedArray 少了些高階函式</a></li>
<li>
<a href=#%e4%b8%8d%e6%94%af%e6%8f%b4-custom-namespace-attribute-selector aria-label="不支援 custom namespace attribute selector">不支援 custom namespace attribute selector</a></li>
<li>
<a href=#scrollwidth-%e8%88%87-scrollheight-%e6%90%9e%e5%8f%8d%e4%ba%86 aria-label="scrollWidth 與 scrollHeight 搞反了"><code>scrollWidth</code> 與 <code>scrollHeight</code> 搞反了</a></li>
<li>
<a href=#multi-column-layout-%e9%9c%80%e7%b5%a6%e5%ae%9a-absolute-column-width aria-label="Multi-column layout 需給定 absolute column-width">Multi-column layout 需給定 absolute <code>column-width</code></a></li>
<li>
<a href=#%e9%81%8e%e6%99%82%e7%9a%84-writing-mode-%e6%a8%99%e6%ba%96 aria-label="過時的 writing-mode 標準">過時的 <code>writing-mode</code> 標準</a></li>
<li>
<a href=#%e4%b8%8d%e7%a9%a9%e5%ae%9a%e7%9a%84-scrollwidth-%e8%88%87-scrollheight aria-label="不穩定的 scrollWidth 與 scrollHeight">不穩定的 scrollWidth 與 scrollHeight</a></li></ul>
</li>
<li>
<a href=#%e6%88%91%e8%83%bd%e7%82%ba%e7%b6%b2%e9%a0%81%e7%9b%b8%e5%ae%b9%e6%80%a7%e5%81%9a%e4%bb%80%e9%ba%bc aria-label=我能為網頁相容性做什麼>我能為網頁相容性做什麼</a><ul>
<li>
<a href=#%e7%b6%b2%e9%a0%81%e7%9b%b8%e5%ae%b9%e6%80%a7%e6%98%af%e4%bb%80%e9%ba%bc aria-label=網頁相容性是什麼>網頁相容性是什麼</a></li>
<li>
<a href=#%e5%a6%82%e6%9e%9c%e4%bd%a0%e6%98%af%e7%b6%b2%e9%a0%81%e4%bd%bf%e7%94%a8%e8%80%85 aria-label=如果你是網頁使用者>如果你是網頁使用者</a></li>
<li>
<a href=#%e5%a6%82%e6%9e%9c%e4%bd%a0%e6%98%af%e7%b6%b2%e9%a0%81%e9%96%8b%e7%99%bc%e8%80%85 aria-label=如果你是網頁開發者>如果你是網頁開發者</a></li></ul>
</li>
<li>
<a href=#%e7%b5%90%e8%aa%9e aria-label=結語>結語</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>還記得之前整理的 <a href=https://weihanglo.github.io/posts/2017/days-with-internet-explorer/>IE 相容性</a> 一文嗎？筆者最近參與公司新版 Web App 架構規劃與開發，又遇到許多相容性的問題，連新版瀏覽器也無法倖免。就讓我們再次探討瀏覽器相容性吧！</p>
<p><em>（撰於 2017-12-09，基於各種莫名其妙的狀況)</em></p>
<blockquote>
<p>對相容性問題細節沒興趣的朋友，可直接跳到「我能為網頁相容性做什麼」這個章節。</p>
</blockquote>
<h2 id=目錄>目錄<a hidden class=anchor aria-hidden=true href=#目錄>#</a></h2>
<ul>
<li><a href=#%E7%9B%B8%E5%AE%B9%E6%80%A7%E5%95%8F%E9%A1%8C%E4%B8%80%E8%A6%BD>相容性問題一覽</a></li>
<li><a href=#%E6%88%91%E8%83%BD%E7%82%BA%E7%B6%B2%E9%A0%81%E7%9B%B8%E5%AE%B9%E6%80%A7%E5%81%9A%E4%BB%80%E9%BA%BC>我能為網頁相容性做什麼</a>
<ul>
<li><a href=#%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%98%AF%E7%B6%B2%E9%A0%81%E4%BD%BF%E7%94%A8%E8%80%85>如果你是網頁使用者</a></li>
<li><a href=#%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%98%AF%E7%B6%B2%E9%A0%81%E9%96%8B%E7%99%BC%E8%80%85>如果你是網頁開發者</a></li>
</ul>
</li>
<li><a href=#%E7%B5%90%E8%AA%9E>結語</a></li>
</ul>
<h2 id=相容性問題一覽>相容性問題一覽<a hidden class=anchor aria-hidden=true href=#相容性問題一覽>#</a></h2>
<p>這邊列出這段紀錄的相容性問題：</p>
<ul>
<li><a href=#%E8%AA%9E%E6%84%8F%E5%8C%96-html5-%E6%A8%99%E7%B1%A4>語意化 HTML5 標籤</a></li>
<li><a href=#%E4%B8%8D%E6%94%AF%E6%8F%B4-const-%E5%AE%A3%E5%91%8A>不支援 <code>const</code> 宣告</a></li>
<li><a href=#%E6%B2%92%E6%9C%89-append-%E5%92%8C-prepend-convenience-methods>沒有 <code>append</code> 和 <code>prepend</code> convenience methods</a></li>
<li><a href=#xhr-%E4%B8%8D%E6%94%AF%E6%8F%B4-json>XHR 不支援 JSON</a></li>
<li><a href=#customevent-%E6%B2%92%E6%9C%89%E5%BB%BA%E6%A7%8B%E5%87%BD%E5%BC%8F>CustomEvent 沒有建構函式</a></li>
<li><a href=#flex-grow-%E9%9C%80%E8%A6%81-absolute-height>flex-grow 需要 absolute height</a></li>
<li><a href=#button-%E4%B8%8A%E7%9A%84-text-align-%E6%B2%92%E4%BD%9C%E7%94%A8><code>&lt;button></code> 上的 <code>text-align</code> 沒作用</a></li>
<li><a href=#element-%E9%80%A3%E7%B5%90%E5%88%B0-dom-%E5%89%8D-getcomputedstyle-%E6%B2%92%E6%9C%89%E9%A0%90%E8%A8%AD%E5%80%BC-style>Element 連結到 DOM 前 getComputedStyle 沒有預設值 style</a></li>
<li><a href=#computed-style-%E8%A1%8C%E7%82%BA%E4%B8%8D%E4%B8%80%E8%87%B4>Computed Style 行為不一致</a></li>
<li><a href=#iframe-%E4%B8%8D%E6%94%AF%E6%8F%B4-data-uri>iframe 不支援 Data URI</a></li>
<li><a href=#iframe-%E4%B8%8D%E6%94%AF%E6%8F%B4-width-%E8%88%87-height-style>iframe 不支援 width 與 height style</a></li>
<li><a href=#script70-permission-denied>SCRIPT70: Permission denied</a></li>
<li><a href=#typedarray-%E5%B0%91%E4%BA%86%E4%BA%9B%E9%AB%98%E9%9A%8E%E5%87%BD%E5%BC%8F>TypedArray 少了些高階函式</a></li>
<li><a href=#%E4%B8%8D%E6%94%AF%E6%8F%B4-custom-namespace-attribute-selector>不支援 custom namespace attribute selector</a></li>
<li><a href=#scrollwidth-%E8%88%87-scrollheight-%E6%90%9E%E5%8F%8D%E4%BA%86><code>scrollWidth</code> 與 <code>scrollHeight</code> 搞反了</a></li>
<li><a href=#multi-column-layout-%E9%9C%80%E7%B5%A6%E5%AE%9A-absolute-column-width>Multi-column layout 需給定 absolute <code>column-width</code></a></li>
<li><a href=#%E9%81%8E%E6%99%82%E7%9A%84-writing-mode-%E6%A8%99%E6%BA%96>過時的 <code>writing-mode</code> 標準</a></li>
<li><a href=#%E4%B8%8D%E7%A9%A9%E5%AE%9A%E7%9A%84-scrollWidth-%E8%88%87-scrollHeight>不穩定的 scrollWidth 與 scrollHeight</a></li>
</ul>
<h3 id=語意化-html5-標籤>語意化 HTML5 標籤<a hidden class=anchor aria-hidden=true href=#語意化-html5-標籤>#</a></h3>
<ul>
<li><strong>Issue</strong>：不支援語意化 tag 就算了，部分 tag 如 <code>&lt;main></code>、<code>&lt;article></code> 還會變成 inline elements</li>
<li><strong>Platform</strong>：IE 11</li>
</ul>
<p>先來個簡單的 issue。 這個 bug 默默記在心上就好，在 IE 仍苟延殘喘的年代，如要使用 semantic element，記得加上 <code>display: block</code> 吧！</p>
<h3 id=不支援-const-宣告>不支援 <code>const</code> 宣告<a hidden class=anchor aria-hidden=true href=#不支援-const-宣告>#</a></h3>
<ul>
<li><strong>Issue</strong>：iOS 9 不支援 <code>const</code> 宣告變數</li>
<li><strong>Platform</strong>：iOS 9 Safari</li>
</ul>
<p>實際上來說，這不是 bug，也跟開發的 source code 無關，而是 <a href=https://github.com/webpack/webpack-dev-server#caveats>Webpack Dev Server 的 Caveats</a>，Webpack Dev Server 2.8.0 以上只支援瀏覽器支持 <code>const</code> 的環境，如果你升級 Dev Server 後遇到麻煩，請把版號固定在 <strong>2.7.1</strong> 吧！</p>
<h3 id=沒有-append-和-prepend-convenience-methods>沒有 <code>append</code> 和 <code>prepend</code> convenience methods<a hidden class=anchor aria-hidden=true href=#沒有-append-和-prepend-convenience-methods>#</a></h3>
<ul>
<li><strong>Issue</strong>：不提供 <code>append</code>／<code>prepend</code> 這些類似 jQuery 的 DOM 操作方法</li>
<li><strong>Platform</strong>：IE 11</li>
</ul>
<p>2006 年釋出的 <a href=https://jquery.com/>jQuery</a>，現在仍被廣泛使用，其 API 設計規範如 event delegation、on/off，和其他 DOM manipulation 深深影響近代 JavaScript Library 的設計流。</p>
<p>以下這幾個 DOM manipulation convenience methods 很明顯看出影響甚鉅：</p>
<ul>
<li><code>ChildNode.before</code></li>
<li><code>ChildNode.after</code></li>
<li><code>ChildNode.replaceWith</code></li>
<li><code>ParentNode.prepend</code></li>
<li><code>ParentNode.append</code></li>
</ul>
<p>講這麼多都沒用，這些 method 在 IE 11 完全不支援！當然，肯定有 <a href=https://github.com/WebReflection/dom4>polyfill</a>，這裡也示範一下怎麼利用 DOM3 的 API 達到 <code>ParentNode.prepend</code> 的效果。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// Add &lt;base&gt; tag for dynamic base URL modification
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>base</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>createElement</span>(<span style=color:#e6db74>&#39;base&#39;</span>)
<span style=color:#a6e22e>base</span>.<span style=color:#a6e22e>setAttribute</span>(<span style=color:#e6db74>&#39;href&#39;</span>, <span style=color:#a6e22e>baseURL</span>)
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>head</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>doc</span>.<span style=color:#a6e22e>documentElement</span>.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;head&#39;</span>)
<span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>insertBefore</span>(<span style=color:#a6e22e>base</span>, <span style=color:#a6e22e>head</span>.<span style=color:#a6e22e>firstElementChild</span>) <span style=color:#75715e>// IE has no `prepend` method.
</span></code></pre></div><blockquote>
<p>在導入 polyfill 之前，記得先想清楚專案的環境，別導入一整包卻只用到一兩個 method。</p>
</blockquote>
<h3 id=xhr-不支援-json>XHR 不支援 JSON<a hidden class=anchor aria-hidden=true href=#xhr-不支援-json>#</a></h3>
<ul>
<li><strong>Issue</strong>：IE 不支援 <code>XMLHttpRequest</code> v2 使用 JSON 作為 <code>responseType</code></li>
<li><strong>Platform</strong>：IE 11</li>
</ul>
<p>Ajax 技術中最有代表性的概念就是 <strong>XHR</strong>（<code>XMLHttpRequest</code>），非同步的技術讓 web content 可以動態更新，這可算是 Microsoft 對 web 貢獻之一（雖然最後是 <a href=https://wikipedia.org/wiki/XMLHttpRequest#History>Mozilla Gecko 引擎先在 browser 實作</a>了）。我們很感謝 IE 不辭辛勞付出，但不代表能不遵從 web standard。IE 至今（2017/11）仍未完全實作 XHR v2 的 spec（請參考 <a href=https://xhr.spec.whatwg.org/>XHR Living Standard</a>，沒辦法支援 JSON as returning value。</p>
<p>就算未來 client request 會逐漸被 <a href=https://developer.mozilla.org/docs/Web/API/Fetch_API>fecth API</a> 取代，我們仍該好好處理瀏覽器向下相容性，畢竟 fetch API 目前只能透過 <a href=https://developer.mozilla.org/docs/Web/API/AbortController>AbortController</a> 取消 request，而且只有 Firefox 57 和 Edge 16 有實作，這時候就凸顯出 <code>xhr.abort</code> 的重要性。</p>
<p>如果想要 XHR 支援 IE 11 又要回傳 JSON，解法就是全部都用 <code>response</code> 再從 <code>responseType</code> 判斷需不需要 parse JSON。簡單作法如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>request</span> ({ <span style=color:#a6e22e>method</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;GET&#39;</span>, <span style=color:#a6e22e>responseType</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;arraybuffer&#39;</span>, <span style=color:#a6e22e>uri</span>, <span style=color:#a6e22e>body</span>, }) {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>xhr</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>XMLHttpRequest</span>()
  <span style=color:#a6e22e>xhr</span>.<span style=color:#a6e22e>open</span>(<span style=color:#a6e22e>method</span>, <span style=color:#a6e22e>uri</span>)
  <span style=color:#75715e>// IE 11 does not support `json` as `responseType`.
</span><span style=color:#75715e></span>  <span style=color:#75715e>// We must parse json text manually.
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>asJson</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>responseType</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;json&#39;</span>
  <span style=color:#a6e22e>xhr</span>.<span style=color:#a6e22e>responseType</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>asJson</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#39;text&#39;</span> <span style=color:#f92672>:</span> <span style=color:#a6e22e>responseType</span>
  <span style=color:#a6e22e>xhr</span>.<span style=color:#a6e22e>onload</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>ev</span>) {
    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>body</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>asJson</span> <span style=color:#f92672>?</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>response</span>) <span style=color:#f92672>:</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>response</span>
    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>body</span>)
  }
  <span style=color:#a6e22e>body</span>
    <span style=color:#f92672>?</span> <span style=color:#a6e22e>xhr</span>.<span style=color:#a6e22e>send</span>(<span style=color:#a6e22e>body</span>)
    <span style=color:#f92672>:</span> <span style=color:#a6e22e>xhr</span>.<span style=color:#a6e22e>send</span>()
}
</code></pre></div><h3 id=customevent-沒有建構函式>CustomEvent 沒有建構函式<a hidden class=anchor aria-hidden=true href=#customevent-沒有建構函式>#</a></h3>
<ul>
<li><strong>Issue</strong>： CustomEvent 沒有 constructor</li>
<li><strong>Platform</strong>：IE 11</li>
</ul>
<p>IE 11 上不能透過 <code>new CustomEvent</code> 建構新的 CustomEvent，只能從透過 <code>document.createEvent</code>，再從 <code>event.initCustomEvent</code> 建構。MDN 上簡單的 <a href=https://developer.mozilla.org/docs/Web/API/CustomEvent/CustomEvent>constructor polyfill</a> 可以解決這個小問題。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// CustomEvent Polyfill for IE
</span><span style=color:#75715e></span>(<span style=color:#66d9ef>function</span> () {
  <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>typeof</span> window.<span style=color:#a6e22e>CustomEvent</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;function&#39;</span>) {
    <span style=color:#66d9ef>return</span>
  }
  <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>CustomEvent</span> (<span style=color:#a6e22e>event</span>, <span style=color:#a6e22e>params</span>) {
    <span style=color:#a6e22e>params</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>params</span> <span style=color:#f92672>||</span> { <span style=color:#a6e22e>bubbles</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>cancelable</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>detail</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>undefined</span> }
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>evt</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>createEvent</span>(<span style=color:#e6db74>&#39;CustomEvent&#39;</span>)
    <span style=color:#a6e22e>evt</span>.<span style=color:#a6e22e>initCustomEvent</span>(<span style=color:#a6e22e>event</span>, <span style=color:#a6e22e>params</span>.<span style=color:#a6e22e>bubbles</span>, <span style=color:#a6e22e>params</span>.<span style=color:#a6e22e>cancelable</span>, <span style=color:#a6e22e>params</span>.<span style=color:#a6e22e>detail</span>)
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>evt</span>
  }
  <span style=color:#a6e22e>CustomEvent</span>.<span style=color:#a6e22e>prototype</span> <span style=color:#f92672>=</span> window.<span style=color:#a6e22e>Event</span>.<span style=color:#a6e22e>prototype</span>
  window.<span style=color:#a6e22e>CustomEvent</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>CustomEvent</span>
})()
</code></pre></div><h3 id=flex-grow-需要-absolute-height>flex-grow 需要 absolute height<a hidden class=anchor aria-hidden=true href=#flex-grow-需要-absolute-height>#</a></h3>
<ul>
<li><strong>Issue</strong>：flex item 沒設定 absolute height，chilNode 長不出來</li>
<li><strong>Platform</strong>：IE 11／Safari 11</li>
</ul>
<p>某些情況，我們並不知道 flex container 有幾個的 flex item，會希望 item 寬高自動增減。但當 <code>flex-direction</code> 設置為 <code>column</code> 時，若 flex item 內的 childNode 需要佔滿 parent 100% 的高度，此時會找不到 parent（flex item）可參考的 height，因此渲染出 <code>height: auto</code> 的樣式。</p>
<p><a href=https://stackoverflow.com/questions/33636796/>這個 stackoverflow 詳細解釋上述的情況</a>。這邊總結它提供的幾種解法：</p>
<p><strong>1. 將所有 parent element 都設置絕對高度 （absolute height）</strong></p>
<p>這應該不用解釋了，完全正確，幾乎沒什麼相容性問題。</p>
<p><strong>2. parent element 設置為相對位置；child 設為絕對位置佔滿 parent 的空間</strong></p>
<ul>
<li>parent ➡ <code>position: relative</code></li>
<li>child ➡ <code>top: 0; left: 0; right: 0; bottom: 0</code></li>
</ul>
<p><strong>3. 移除多餘的 HTML container</strong> 👍</p>
<p>有時候 layout 會錯，就是因為嵌套太多層不必要的 <code>&lt;div></code>，其實只要適時移除部分 container，重新組織，通常都能輕鬆解決問題。</p>
<p><strong>4. 直接使用多層 flex container</strong> 👍</p>
<p>將沒有 absolute height 的 flex item 設置為 <code>display: flex</code>，<code>align-items</code> 會自動設為 <code>stretch</code>，child node 自己就會擴張到 100% height 了。</p>
<h3 id=button-上的-text-align-沒作用><code>&lt;button></code> 上的 <code>text-align</code> 沒作用<a hidden class=anchor aria-hidden=true href=#button-上的-text-align-沒作用>#</a></h3>
<ul>
<li><strong>Issue</strong>：<code>&lt;button></code> 不吃 <code>text-align</code> CSS</li>
<li><strong>Platform</strong>：iOS 11 Safari</li>
</ul>
<p>這應該是一個 bug，快速的解法就是給他一個 container。</p>
<p><strong>HTML</strong></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>div</span>&gt;
  &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;not-centered&#34;</span>&gt;Not Centered&lt;/<span style=color:#f92672>button</span>&gt;
  &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;centered&#34;</span>&gt;
    &lt;<span style=color:#f92672>span</span>&gt;Centered&lt;/<span style=color:#f92672>span</span>&gt;
  &lt;/<span style=color:#f92672>button</span>&gt;
&lt;/<span style=color:#f92672>div</span>&gt;
</code></pre></div><p><strong>CSS</strong></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css>.<span style=color:#a6e22e>not-centered</span> {
  <span style=color:#66d9ef>text-align</span>: <span style=color:#66d9ef>center</span>;
}

.<span style=color:#a6e22e>centered</span> <span style=color:#f92672>&gt;</span> <span style=color:#f92672>span</span> {
  <span style=color:#66d9ef>display</span>: <span style=color:#66d9ef>inline-block</span>;
  <span style=color:#66d9ef>text-align</span>: <span style=color:#66d9ef>center</span>;
}
</code></pre></div><h3 id=element-連結到-dom-前-getcomputedstyle-沒有預設值-style>Element 連結到 DOM 前 getComputedStyle 沒有預設值 style<a hidden class=anchor aria-hidden=true href=#element-連結到-dom-前-getcomputedstyle-沒有預設值-style>#</a></h3>
<ul>
<li><strong>Issue</strong>：在 Element connect（append） 到 DOM 之前，使用 <code>getComputedStyle</code> 取得的 style 只會是空字串。</li>
<li><strong>Platform</strong>： Webkit-based browsers</li>
</ul>
<p>這是一個蠻有趣的小差異，Webkit-based browsers（Chrome、Safari）在 element append 到 DOM 之前，computedstyle 的每一個 property 都是空字串；而 Gecko 和 Trident／EdgeHTML 這些 engine 都會有 default value。</p>
<p>筆者並沒有深入研究哪一家的實作比較符合符合 CSSOM 的規範，這個差異可以謹記在心就好。實務上最好「<strong>避免在 element append 到 DOM 之前存取 computed style</strong>」。</p>
<h3 id=computed-style-行為不一致>Computed Style 行為不一致<a hidden class=anchor aria-hidden=true href=#computed-style-行為不一致>#</a></h3>
<ul>
<li><strong>Issue</strong>： <code>getComputedStyle</code> 回傳的 <code>CSSStyleDeclaration</code> 行為不一致。</li>
<li><strong>Platform</strong>：IE 11／Edge 15</li>
</ul>
<p>IE／Edge 對 CSSStyleDelclaration 下每一個 style 的處理方法似乎不盡相同，尤其是使用 JavaScript 操作 shorthand style 最容易出問題。例如：<code>getComputedStyle(el).backgroundPositionX</code> 這種直接存取 style 的方法不穩定，使用 <code>getComputedStyle(el).getPropertyValue('background-position-x')</code> 比較能取得有效的值。但是 <code>getComputedStyle(el).getPropertyValue('border-width')</code> 或是 <code>getComputedStyle(el).borderWidth</code> 只能取到空字串。WTF。</p>
<p>除此之外，假設我們現在有一個 element，要取得 background position 就算畫面已經渲染了，只要你<strong>使用 keyword value 賦值</strong>，IE 還是取到前一個設定值，這實在是蠻神奇的，情境如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// 使用 keyword value 設定
</span><span style=color:#75715e></span><span style=color:#a6e22e>div</span>.<span style=color:#a6e22e>style</span>.<span style=color:#a6e22e>backgroundPosition</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;bottom 20px left&#39;</span>
<span style=color:#a6e22e>getComputedStyle</span>(<span style=color:#a6e22e>div</span>).<span style=color:#a6e22e>backgroundPosition</span>
<span style=color:#75715e>// Other: &#34;0% calc(-20px + 100%)
</span><span style=color:#75715e>// IE: &#34;0% 0%&#34;
</span></code></pre></div><p>總之，在 IE／Edge 的世界裡，別太相信 <code>getComputedStyle</code> 會自動更新這種鬼話。</p>
<h3 id=iframe-不支援-data-uri>iframe 不支援 Data URI<a hidden class=anchor aria-hidden=true href=#iframe-不支援-data-uri>#</a></h3>
<ul>
<li><strong>Issue</strong>：<code>iframe.src</code> 不支援 data URI 作為參數</li>
<li><strong>Platform</strong>：IE 11／Edge 15／Chrome on iOS</li>
</ul>
<p>根據 <a href="https://msdn.microsoft.com/library/cc848897(v=VS.85).aspx">MSDN 文件</a>指出，微軟出品的瀏覽器的 Data URI 只支援下列 elements 與 attributes：</p>
<ul>
<li><code>&lt;object></code> (images only)</li>
<li><code>&lt;img></code></li>
<li><code>&lt;input></code> type=image</li>
<li><code>&lt;link></code></li>
<li>會用到 URL 的 CSS style，例如 <code>background</code>、<code>backgroundImage</code></li>
</ul>
<p>由於某些需求，筆者需要在 HTML document 傳入 iframe 前做些處理，再利用 <strong>BlobURL</strong> 的方式傳入 <code>iframe.src</code>，但顯然 iframe 根本不在上列中。實力堅強的讀者也許會說：「不能用 <code>src</code> 那就用 <code>srcdoc</code> 傳參吧！」可惜的是 <code>srcdoc</code> <a href="https://caniuse.com/#feat=iframe-srcdoc">連 Edge 17 都不支援</a>。</p>
<p>如果你同樣要處理 HTML document，推薦一個相容 IE 的作法「<strong>使用 <code>document.write</code></strong>」。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// ❌ Original implmentation
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>blob</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Blob</span>(
  [<span style=color:#a6e22e>doc</span>.<span style=color:#a6e22e>documentElement</span>.<span style=color:#a6e22e>outerHTML</span>],
  { <span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;text/html&#39;</span> }
)
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>src</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>createObjectURL</span>(<span style=color:#a6e22e>blob</span>)
<span style=color:#a6e22e>iframe</span>.<span style=color:#a6e22e>src</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>src</span>

<span style=color:#75715e>// 👌 Compatible implementation
</span><span style=color:#75715e></span><span style=color:#a6e22e>iframe</span>.<span style=color:#a6e22e>contentDocument</span>.<span style=color:#a6e22e>open</span>()
<span style=color:#a6e22e>iframe</span>.<span style=color:#a6e22e>contentDocument</span>.<span style=color:#a6e22e>write</span>(<span style=color:#a6e22e>doc</span>.<span style=color:#a6e22e>documentElement</span>.<span style=color:#a6e22e>outerHTML</span>)
<span style=color:#a6e22e>iframe</span>.<span style=color:#a6e22e>contentDocument</span>.<span style=color:#a6e22e>close</span>()
</code></pre></div><p>就是這麼噁心。</p>
<blockquote>
<p>Chrome on iOS 實際上應該有支援 blob URL。筆者在開發時發現 iOS 11 下 Chrome 62 無法支援 blob URL，不過 iOS 11 的 Mobile Safari 可行。因此猜測是，與 Chrome 使用 WKWebView 一些 config 相牴觸，觸發 CSP 或 CORS 等等設定錯誤。</p>
</blockquote>
<h3 id=iframe-不支援-width-與-height-style>iframe 不支援 width 與 height style<a hidden class=anchor aria-hidden=true href=#iframe-不支援-width-與-height-style>#</a></h3>
<ul>
<li>
<p><strong>Issue</strong>： iOS Safari 上 iframe 不支援 percentage width/height style。</p>
</li>
<li>
<p><strong>Platform</strong>：iOS Safari</p>
</li>
</ul>
<p>事實上，iOS Safari 支援 <code>min-height</code>，<code>min-width</code> 使用百分比寬高。我們暫時的解法就是先給 iframe 一個絕對的長度，再利用最小寬高達成目的。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css> <span style=color:#75715e>/* 給 1px，再設置 min-width 讓 iframe 長到 100% */</span>
<span style=color:#f92672>iframe</span> {
  <span style=color:#66d9ef>width</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>px</span>;
  <span style=color:#66d9ef>min-width</span>: <span style=color:#ae81ff>100</span><span style=color:#66d9ef>%</span>;
}
</code></pre></div><p>真是謝了 Safari。</p>
<h3 id=script70-permission-denied>SCRIPT70: Permission denied<a hidden class=anchor aria-hidden=true href=#script70-permission-denied>#</a></h3>
<ul>
<li><strong>Issue</strong>：IE／Edge 無法注入部分 script 到 iframe。</li>
<li><strong>Platform</strong>：IE 11／Edge 15</li>
</ul>
<p>Stackoverflow 上都說這是 IE 最惡名昭彰的嚴格規定，會產生 SCRIPT70 的原因不少，最常見的是：<strong>ifame 與 main frame 不同 Domain，但注入 iframe 的 script 試圖修改 main frame 的資料。</strong></p>
<p>筆者遇到 Script70 的情境是把 <code>iframe.contentDocument</code> 丟進 react-redux 的 container component 中，剛好 <code>ifame.src</code> 又是一個 Blob URL，不知道 IE 底層怎麼判斷的，反正這個 blob URL 被當作 cross domain，甚至<a href=https://stackoverflow.com/a/10471154/8851735>修改 <code>document.domain</code> 也沒有作用</a>。
其他直接 query/append/modify iframe DOM 都沒有遇到上述的問題。</p>
<p>Workaround 就是<strong>檢查每一個 iframe 是否為 same origin</strong>，如果有其他更好的方法，歡迎大家提供。</p>
<h3 id=typedarray-少了些高階函式>TypedArray 少了些高階函式<a hidden class=anchor aria-hidden=true href=#typedarray-少了些高階函式>#</a></h3>
<ul>
<li><strong>Issue</strong>：不支援 TypedArray 高階函式，例如 map、reduce、filter</li>
<li><strong>Platform</strong>：IE 11／Edge 15</li>
</ul>
<p>基本上，導入 Babel 轉譯應該可以順利解決，但某些 context 下我們並不會導入 Babel 轉譯，如 web worker thread 或是 iframe content。尤其是 web worker 很容易被拿來操作 binary data，更要將這個缺失牢記在心。</p>
<p>簡單的 polyfill 如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// IE does not support TypedArray#map. Do it ourself.
</span><span style=color:#75715e>// We polyfilled for only Uint8Array#map here.
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (Array.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>hasOwnProperty</span>(<span style=color:#e6db74>&#39;map&#39;</span>) <span style=color:#f92672>&amp;&amp;</span>
    <span style=color:#f92672>!</span><span style=color:#a6e22e>Uint8Array</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>hasOwnProperty</span>(<span style=color:#e6db74>&#39;map&#39;</span>)) {
  <span style=color:#a6e22e>Uint8Array</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>map</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>f</span>) {
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Uint8Array</span>([].<span style=color:#a6e22e>map</span>.<span style=color:#a6e22e>call</span>(<span style=color:#66d9ef>this</span>, <span style=color:#a6e22e>f</span>))
  }
}
</code></pre></div><h3 id=不支援-custom-namespace-attribute-selector>不支援 custom namespace attribute selector<a hidden class=anchor aria-hidden=true href=#不支援-custom-namespace-attribute-selector>#</a></h3>
<ul>
<li><strong>Issue</strong>：不支援 Custom namespace attribute selector（常見於 XML 操作）</li>
<li><strong>Platform</strong>：IE 11／Edge 15</li>
</ul>
<p>我們都知道 XML 可以說是「嚴格版」的 HTML，XML 有許多 HTML 沒有的特點，例如現在要介紹的 custom namespace attribute。</p>
<p>在 <code>Document</code> 中，要取得含有特定 attribute 的 element，我們會使用 <a href=https://developer.mozilla.org/docs/Web/CSS/Attribute_selectors>CSS attribute selector</a>。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// Fetch &lt;a href&gt;&lt;/a&gt; element
</span><span style=color:#75715e></span>document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;a[href]&#39;</span>)
</code></pre></div><p>當這個 document 是 <code>XMLDocument</code> 時，element 或 attribute 可以有 <a href=https://wikipedia.org/wiki/XML_namespace>namespace</a>，如</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=color:#f92672>&lt;nav</span> <span style=color:#a6e22e>epub:type=</span><span style=color:#e6db74>&#34;toc&#34;</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;toc&#34;</span><span style=color:#f92672>&gt;&lt;/nav&gt;</span>`
</code></pre></div><p>我們會很直覺地把 <code>epub:type</code> 當作 attribute name 去 query，但這樣是行不通的，需要 escape <code>:</code>，但試了幾次之後發現，下列四種方法都沒有完整的相容性，。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>// ❌ Not work
</span><span style=color:#75715e></span>document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;nav[epub:type=&#34;toc&#34;]&#39;</span>)
<span style=color:#75715e>// ❌ Not work
</span><span style=color:#75715e></span>document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;nav[epub|type=&#34;toc&#34;]&#39;</span>)
<span style=color:#75715e>// ❌ Not work in IE and Edge (glob namespace selector )
</span><span style=color:#75715e></span>document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;nav[*|type=&#34;toc&#34;]&#39;</span>)
<span style=color:#75715e>// ❌ Not work in IE and Edge (escaping)
</span><span style=color:#75715e></span>document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>&#39;nav[epub\\:type=&#34;toc&#34;]&#39;</span>)
</code></pre></div><p>最後的解法就是把所有 element 取出來，再判斷有沒有對應的 attribute。</p>
<p><strong>以下程式碼可能引發胸悶、頭暈、血壓驟升，呼吸困難，有程式碼潔癖者請斟酌觀賞。</strong></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>toc</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>querySelector</span>(<span style=color:#e6db74>`nav[epub\\:type=&#34;toc&#34;]`</span>)
<span style=color:#75715e>// Fallback to use manual assignment for browsers not supporing custom
</span><span style=color:#75715e>// namespace attribute selector. (IE and Edge. LOL)
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>toc</span>) {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>tocs</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_dom</span>.<span style=color:#a6e22e>querySelectorAll</span>(<span style=color:#e6db74>&#39;nav&#39;</span>)
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>pattern</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>/toc/i</span>
  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>tocs</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>pattern</span>.<span style=color:#a6e22e>test</span>(<span style=color:#a6e22e>tocs</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>getAttribute</span>(<span style=color:#e6db74>&#39;epub:type&#39;</span>))) {
      <span style=color:#a6e22e>toc</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tocs</span>[<span style=color:#a6e22e>i</span>]
      <span style=color:#66d9ef>break</span>
    }
  }
}
</code></pre></div><h3 id=scrollwidth-與-scrollheight-搞反了><code>scrollWidth</code> 與 <code>scrollHeight</code> 搞反了<a hidden class=anchor aria-hidden=true href=#scrollwidth-與-scrollheight-搞反了>#</a></h3>
<ul>
<li><strong>Issue</strong>：在 <code>writing-mode</code> 為 <code>vertical-lr</code> 或 <code>vertical-rl</code> 下，Edge 把 <code>scrollWidth</code> 和 <code>scrollHeight</code> 搞反了。</li>
<li><strong>Platform</strong>：Edge 15</li>
</ul>
<p><strong>⬅⬅ 閱讀方向 ⬅⬅</strong></p>
<p>其實這個 scrollWidth scrollHeight 互相調換很符合邏輯，預設橫式書寫的 content flow 是上下，一行寫滿，content 會繼續往下長，所以 <code>scrollWidth</code> 會不斷增加；而直式書寫正好相反，是往左右增長，所以 <code>scrollHeight</code> 會持續成長。</p>
<p>然而，Edge 15 卻在直式書寫時忘記將 <code>scrollWidth</code> 與 <code>scrollHeight</code> 角色互換。解法就是自己判斷 User Agent 再換回來。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>verticalPattern</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>/vertical|^tb-|-lr$|^bt-/i</span>
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>writingMode</span> <span style=color:#f92672>=</span> window.<span style=color:#a6e22e>getComputedStyle</span>(<span style=color:#a6e22e>el</span>).<span style=color:#a6e22e>writingMode</span>
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>scrollWidth</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>detectEdge</span>() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>verticalPattern</span>.<span style=color:#a6e22e>test</span>(<span style=color:#a6e22e>writingMode</span>)
  <span style=color:#f92672>?</span> <span style=color:#a6e22e>el</span>.<span style=color:#a6e22e>scrollHeight</span>
  <span style=color:#f92672>:</span> <span style=color:#a6e22e>el</span>.<span style=color:#a6e22e>scrollWidth</span>
</code></pre></div><h3 id=multi-column-layout-需給定-absolute-column-width>Multi-column layout 需給定 absolute <code>column-width</code><a hidden class=anchor aria-hidden=true href=#multi-column-layout-需給定-absolute-column-width>#</a></h3>
<ul>
<li><strong>Issue</strong>：一定要給定 absolute <code>column-width</code>，CSS multi-column 才有作用</li>
<li><strong>Platform</strong>：Safari 11／iOS 11 Safari</li>
</ul>
<p>這是一個很神奇的 issue，根據 <a href=https://drafts.csswg.org/css-multicol/>CSS Multi-column layout 的標準定義</a>，當 <code>column-width: auto</code> 是，欄數會由其他屬性如 <code>column-count</code> 決定。但實際上在 Webkit 上給 <code>column-count</code> 一個整數欄數是沒有效果的。</p>
<p>幸好，<code>column-count</code> 除了可以決定欄數，當 <code>column-width</code> 也是一個非 <code>auto</code> 的長度值時，<code>column-count</code> 代表最大欄數。我們可以利用這個特性 work around。解法就是加一個 1px 的 <code>column-width</code>。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css>.<span style=color:#a6e22e>multi-column</span> {
  <span style=color:#66d9ef>column-width</span>: <span style=color:#ae81ff>1</span><span style=color:#66d9ef>px</span>;
  <span style=color:#66d9ef>column-count</span>: <span style=color:#ae81ff>2</span>;
}
</code></pre></div><p>這樣就可以正確分頁分欄了！</p>
<h3 id=過時的-writing-mode-標準>過時的 <code>writing-mode</code> 標準<a hidden class=anchor aria-hidden=true href=#過時的-writing-mode-標準>#</a></h3>
<ul>
<li><strong>Issue</strong>：仍只支持舊版的 <code>writing-mode</code> 標準</li>
<li><strong>Platform</strong>：IE 11／Edge 15</li>
</ul>
<p><a href=https://developer.mozilla.org/docs/Web/CSS/writing-mode><code>writing-mode</code></a> 這種冷僻的 CSS property，除了開發電子書（或閱讀器），以及特殊的設計需求，一般開發者大概一輩子都不會碰到。好巧不巧筆者的工作就是前者。</p>
<p><code>writing-mode</code> 會改變 block level content flow direction，意思就是 block element 會朝不同的方向堆疊（預設是 top-down），而 block container 內的 inline-level content 也會以這個方向排列。CSS 3 總共定義 3 個 keyword value，語意非常直白。</p>
<ul>
<li><code>horizontal-tb</code>：inline content 以水平方向排列，block content 由上而下流動。</li>
<li><code>vertical-rl</code>：inline content 以垂直方向排列，block content 由右至左流動。</li>
<li><code>vertical-lr</code>：inline content 以垂直方向排列，block content 由左至右流動。</li>
</ul>
<p><img loading=lazy src=https://mdn.mozillademos.org/files/12201/writing-mode-actual-result.png alt>
</p>
<p>可惜的是， IE 和 Edge 兩個活寶對新的標準支援有限，只能繼續使用 <code>lr</code> <code>lr-tb</code> <code>rl</code> <code>tb</code> <code>tb-rl</code> 這些舊 spec。相容的寫法就是新舊兩種都寫進去吧！</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-css data-lang=css>.<span style=color:#a6e22e>vertical-content</span> {
  <span style=color:#66d9ef>-ms-</span><span style=color:#66d9ef>writing-mode</span>: tb-rl;
  <span style=color:#66d9ef>writing-mode</span>: tb-rl;
  <span style=color:#66d9ef>-webkit-</span><span style=color:#66d9ef>writing-mode</span>: <span style=color:#66d9ef>vertical</span><span style=color:#f92672>-</span>rl;
  <span style=color:#66d9ef>writing-mode</span>: <span style=color:#66d9ef>vertical</span><span style=color:#f92672>-</span>rl;
}
</code></pre></div><p>其實 writing mode 蠻有趣的，現在 Firefox 甚至實作 CSS 4 最新的 <code>sideways</code> 標準，大家可以玩玩看！</p>
<h3 id=不穩定的-scrollwidth-與-scrollheight>不穩定的 scrollWidth 與 scrollHeight<a hidden class=anchor aria-hidden=true href=#不穩定的-scrollwidth-與-scrollheight>#</a></h3>
<ul>
<li><strong>Issue</strong>：不穩定的 scrollWidth／scrollHeight，會因 position 變動而改變</li>
<li><strong>Platform</strong>：Safari 11／iOS 11 Safari</li>
</ul>
<p>一個 element 的 <code>scrollWidth</code> 與 <code>scrollHeight</code>，依照 CSSOM 中的 <a href=https://www.w3.org/TR/cssom-view-1/#scrolling-area>scrolling area</a> 定義，以 element 的 padding edges 或是 descendant（child node）的 border edges 為依據計算。當 element 本身與其 children 的 edges 不變，理論上改變座標位置移動 element，<strong>scrolling area</strong> 並不會變動。</p>
<p>很可惜的是 Safari 的實作出了包。當你變動一個 positioned element 的 <code>left</code>、<code>top</code> 這些 positioning properties 時，<code>scrollWidth</code> 與 <code>scrollHeight</code> 是會變動的。</p>
<p>如果你需要在 position 變動之後對 scrolling area 做些計算，可以「<strong>先移動回初始位置</strong>」，再存取 <code>scrollWidth</code> 或 <code>scrollHeight</code>，這是使 scrolling area 資料正確最保險的作法。</p>
<blockquote>
<p>Safari 11 能有這種 issue 真的很厲害！</p>
</blockquote>
<h2 id=我能為網頁相容性做什麼>我能為網頁相容性做什麼<a hidden class=anchor aria-hidden=true href=#我能為網頁相容性做什麼>#</a></h2>
<h3 id=網頁相容性是什麼>網頁相容性是什麼<a hidden class=anchor aria-hidden=true href=#網頁相容性是什麼>#</a></h3>
<p>我們可能會很好奇，為什麼手機 App 需要針對 iOS、Android 分別開發，而且開發流程、工具大相逕庭，而網頁卻不需要針對每個瀏覽器重頭開發？這是因為在網際網路後面，有許多人致力於訂定各種網路標準，例如 W3C 與 IETF 等組織。而各大網路瀏覽器廠商就針對這些標準開發自家的產品，讓人們可以無痛地使用各式各樣的瀏覽器暢遊網路。</p>
<p>但標準何其多？各家廠商挑選對自己有利的標準來實作。對標準實作程度不一，就產生了相容性的問題，A 網站用 Chrome 可以正確顯示，但可能在 Firefox 排版歪了一邊。而許多網頁開發商為了節省成本，決定「西瓜偎大邊」，只針對某些特定的瀏覽器最佳化，犧牲小眾瀏覽器使用者的使用權。例如這些<a href=https://thenextweb.com/dd/2017/11/28/please-build-websites-web-not-just-google-chrome/>只針對 Google Chrome 最佳化的事件</a>，連 Chrome 的開發者自己都看不下去了。而這些事件累積起來，消費者只會看見某些瀏覽器的好像相容性不好，有些網頁開不了，而強勢瀏覽器就強者越強。</p>
<p>完全錯了！網路的初衷不該是這樣，使用網路就像基本人權一樣，沒有人應該被限制只能用特定的方式瀏覽特定的網頁，沒有人應該被剝奪網路使用權。而這正是為什麼我們需要致力於消弭各瀏覽器間的差異，提高網頁相容性的原因。</p>
<p>能幫助提升網頁相容性的方法很多，以下簡單分享一些方法。</p>
<h3 id=如果你是網頁使用者>如果你是網頁使用者<a hidden class=anchor aria-hidden=true href=#如果你是網頁使用者>#</a></h3>
<p>你可以到一個網站 <a href=https://webcompat.com>Webcompat.com</a> 回報網頁錯誤。Webcompat.com 是一個志願者開發的網站，致力於搜集所有網站，所有使用者，所有瀏覽器的網頁相容性問題。Webcompat.com 搜集到問題之後，會先<strong>診斷問題的源頭</strong>，再根據診斷結果找到對應的開發商（可能是瀏覽器開發商或是網頁開發商）。你可以直接到 Webcompat.com 按下 <strong>Report Bug</strong> 回報你遇到的問題，也可以在各主流瀏覽器的 addons 市集找到相對應的附加元件，更快速地回報臭蟲。</p>
<p>如果說你對特定網站情有獨鍾，你可以自行聯絡該網站開發商，請他們檢查並修正你發現的網頁臭蟲，這個方法其實就是 Webcompat.com 的第三個步驟「<strong>Site Outreach</strong>」。</p>
<p>另外，你還可以選擇<a href=https://www.mozilla.org/firefox/>相對小眾的瀏覽器</a>，減低部分廠商獨佔市場的現象，這就像人們開始會採購小農的生鮮蔬果和農產品一樣自然，讓市場更多元，更有生命力。這種方法的技術門檻相對較低，很適合關心網頁相容性以及瀏覽器獨佔問題，但不懂技術的民眾。</p>
<p>最後，請記得升級瀏覽器，確保自己用的瀏覽器正確實作網頁標準，讓每個舊版過時的產品能夠安全退場。這不僅是為了確保網頁相容性，也可以降低網路資安事件的發生，更能解放開發者的生產力，把產能專注在改善人類生活，而不是對舊式的瀏覽器修修補補。（拜託不要再用 IE 了！）</p>
<h3 id=如果你是網頁開發者>如果你是網頁開發者<a hidden class=anchor aria-hidden=true href=#如果你是網頁開發者>#</a></h3>
<p>身為一個住在自由地區的網頁開發者，要有一種使命感：</p>
<blockquote>
<p><strong>A person should be able to use the Web with any devices and browsers.</strong>
— Mozilla Wiki</p>
</blockquote>
<p>對筆者來說，這句話就是網路相容性的終極目標。在開發網頁時，需時時刻刻測試網頁在主流的瀏覽器的體驗是否一致，在行動載具或筆電上是否皆能正確執行。這不是為了觸及更多使用者賺更多錢（雖然老闆應該是這樣想），是為了讓不同族群能夠無礙的使用網頁。如果把網頁視為人類的知識累積，那這些珍貴的知識就不應該只讓少數人把持。</p>
<p>大多開發者想像中的網頁相容性可能是 CSS 相容啊，有沒有支援 ES6 語法啊，需不需要裝 Promise polyfill 等等。但很多人不知道，<strong>Accessbility</strong> 也是網頁相容性的一環。對身心不方便的朋友，我們更需要照顧到他們的需求，讓這些朋友能夠跟無畏的使用網路。Wendell Liu 這一篇 <a href=https://medium.com/frochu/%E5%9B%9E%E6%AD%B8%E5%88%9D%E5%BF%83-%E4%B8%80%E6%8E%A2web-accessibility-baaa4d22f4a7>A11y 的文章</a> 寫得非常清楚，不妨花時間讀一讀，肯定會收穫滿滿！。</p>
<p>最後，同樣是 Accessiblity，<strong>偏鄉網路存取權</strong>也是常被漠視的一環。在政府大力推行 E 化政策之下，透過網路學習或辦公對年輕一代已是稀鬆平常的事情，但對某些沒有網路或是網路訊號不好的地區，在網路上傳或下載資料都是一件很痛苦的事情，開發商應該好好評估網路頻寬，減少不必要的封包傳輸，提升網站的效能。並在必要時提供訊號不佳的地區一個替代方案（例如 Facebook Lite 這種作法）。Mozilla 的 IRL Podcast 就有<a href=https://irlpodcast.org/episode6/>一期在介紹網路存取權</a>，大家都知道網路存取權在這個時代可謂基本人權，那「<strong>迅速有效的網路存取，是奢侈品，還是百姓的權利呢？</strong>」我認為這個議題非常值得思考。</p>
<blockquote>
<p>題外話：IRL 這個 podcast 在探討網路與生活間交互作用，主軸就是 <em>Our online life is real life</em>，內容有趣又不失深度，對英文廣播有興趣的朋友可以參考。</p>
</blockquote>
<h2 id=結語>結語<a hidden class=anchor aria-hidden=true href=#結語>#</a></h2>
<p>網頁相容性對前端開發來說非常重要，但也相對繁雜，許多人避之唯恐不及。筆者經手開發的軟體之受眾剛好是圖書館，而圖書館又是許多缺乏網路存取管道的朋友接觸網路的一個窗口，網路存取權與相容性更顯重要。雖然支援舊版瀏覽器真的很惱人（看那精美的 issue list），但仍要不斷提醒自己：</p>
<p>這就是身為前端工程師的使命。</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://weihanglo.tw/tags/internet-explorer/>Internet Explorer</a></li>
<li><a href=https://weihanglo.tw/tags/front-end/>Front-end</a></li>
<li><a href=https://weihanglo.tw/tags/javascript/>JavaScript</a></li>
<li><a href=https://weihanglo.tw/tags/web-compatibility/>Web Compatibility</a></li>
<li><a href=https://weihanglo.tw/tags/web-access-right/>Web Access Right</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://weihanglo.tw/posts/2018/tokio-internals/>
<span class=title>« Prev Page</span>
<br>
<span>【譯】Tokio 內部機制：從頭理解 Rust 非同步 I/O 框架</span>
</a>
<a class=next href=https://weihanglo.tw/posts/2017/how-is-new-terminal-in-vs-code-so-fast/>
<span class=title>Next Page »</span>
<br>
<span>How Is New Terminal In VS Code So Fast?</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>CC BY-NC-SA 4.0</span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>