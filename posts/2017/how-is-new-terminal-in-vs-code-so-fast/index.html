<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>How Is New Terminal In VS Code So Fast? | Weihang Lo</title>
<meta name=keywords content="Canvas,Front-end,Terminal,Visual Studio Code,Source Reading,Xterm.js">
<meta name=description content="Last week, a new version (1.17) of Visual Studio Code was released. While there are many fascinating improvements and features introduced, the one that cought my eyes is &ldquo;Integrated Terminal performance&rdquo; section. Let&rsquo;s check out what they&rsquo;ve done!
(written on 2017-10-12, based on Xterm.js v3, VS Code 1.17)
Old Performance Issue The integrated terminal in VS Code is powered by another popular open-source project &ldquo;Xterm.js&rdquo;, which is currently maintained by SourceLair and community contributors.">
<meta name=author content>
<link rel=canonical href=https://weihanglo.tw/posts/2017/how-is-new-terminal-in-vs-code-so-fast/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style>
<link rel=icon href=https://weihanglo.tw/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://weihanglo.tw/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://weihanglo.tw/favicon-32x32.png>
<link rel=apple-touch-icon href=https://weihanglo.tw/apple-touch-icon.png>
<link rel=mask-icon href=https://weihanglo.tw/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:!0},{left:'$',right:'$',display:!1},{left:'\\(',right:'\\)',display:!1},{left:'\\[',right:'\\]',display:!0}],throwOnError:!1})})</script>
<meta property="og:title" content="How Is New Terminal In VS Code So Fast?">
<meta property="og:description" content="Last week, a new version (1.17) of Visual Studio Code was released. While there are many fascinating improvements and features introduced, the one that cought my eyes is &ldquo;Integrated Terminal performance&rdquo; section. Let&rsquo;s check out what they&rsquo;ve done!
(written on 2017-10-12, based on Xterm.js v3, VS Code 1.17)
Old Performance Issue The integrated terminal in VS Code is powered by another popular open-source project &ldquo;Xterm.js&rdquo;, which is currently maintained by SourceLair and community contributors.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://weihanglo.tw/posts/2017/how-is-new-terminal-in-vs-code-so-fast/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2017-10-12T22:05:03+08:00">
<meta property="article:modified_time" content="2017-10-12T22:05:03+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="How Is New Terminal In VS Code So Fast?">
<meta name=twitter:description content="Last week, a new version (1.17) of Visual Studio Code was released. While there are many fascinating improvements and features introduced, the one that cought my eyes is &ldquo;Integrated Terminal performance&rdquo; section. Let&rsquo;s check out what they&rsquo;ve done!
(written on 2017-10-12, based on Xterm.js v3, VS Code 1.17)
Old Performance Issue The integrated terminal in VS Code is powered by another popular open-source project &ldquo;Xterm.js&rdquo;, which is currently maintained by SourceLair and community contributors.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://weihanglo.tw/posts/"},{"@type":"ListItem","position":3,"name":"How Is New Terminal In VS Code So Fast?","item":"https://weihanglo.tw/posts/2017/how-is-new-terminal-in-vs-code-so-fast/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How Is New Terminal In VS Code So Fast?","name":"How Is New Terminal In VS Code So Fast?","description":"Last week, a new version (1.17) of Visual Studio Code was released. While there are many fascinating improvements and features introduced, the one that cought my eyes is \u0026ldquo;Integrated Terminal performance\u0026rdquo; section. Let\u0026rsquo;s check out what they\u0026rsquo;ve done!\n(written on 2017-10-12, based on Xterm.js v3, VS Code 1.17)\nOld Performance Issue The integrated terminal in VS Code is powered by another popular open-source project \u0026ldquo;Xterm.js\u0026rdquo;, which is currently maintained by SourceLair and community contributors.","keywords":["Canvas","Front-end","Terminal","Visual Studio Code","Source Reading","Xterm.js"],"articleBody":"Last week, a new version (1.17) of Visual Studio Code was released. While there are many fascinating improvements and features introduced, the one that cought my eyes is “Integrated Terminal performance” section. Let’s check out what they’ve done!\n(written on 2017-10-12, based on Xterm.js v3, VS Code 1.17)\nOld Performance Issue The integrated terminal in VS Code is powered by another popular open-source project “Xterm.js”, which is currently maintained by SourceLair and community contributors. There are many real-world use cases of Xterm.js, such as RStudio and JupyterLab (Ah ha! Data scientist!), not to mention SourceLair itself. One can say that Xterm.js dominates web-based terminal world as React does in front-end development.\nAs same as other web-based HTML terminal emulators, old versions of Xterm.js are powered by old fashion. Rendering from HTMLElements, selecting text via document.getSelection, receiving DOM MouseEvents. All these works were done by a sequence of DOM manipulations.\nDevelopment in modern web technologies lowers the barriers for other devs to contribute to. Every programmer can easily pick up a JavaScript cookbook to study, then boasts about new frameworks on Github trending as he is a JavaScript expert. However, web techs also brings another significant drawback: performance.\nAs we mention to web performance, two key concepts should be kept in mind: reflow and repaint.\n Image from MDN. We focus on layout and paint.\n Reflow When a web page is initialized, the render engine calculates dimensions and position of all elements to layout them in proper place. This is known as layout. Although layout is a normal stage of browser rendering process, any updates of position, dimensions or other properties on a specific element after initialization will lead to an additional layout on that element, and all its child nodes need to do a extra layout, too (except nodes with absolute position). These synchronously layout calculations are called reflows, which might result in performance bottlenecks.\n Here is a list of what forces layout / reflow. Read it to avoid reflows.\n Repaint A repaint occurs when changes are made to an element’s visibility, background color, or other styles not relevant to layout. Repaints are less expensive than reflows, but also have some impact on browser responsive time.\nDOM manipulations Poor performance is not web techs or JavaScript’s faults. It always counts on implementation details. Hyper and Upterm are two delightful terminal emulators based on Electron. They add many convenient features to improve our boring daily terminal lives. The pain points are their performance issues due to DOM rendering. Both rendering implementations depend on heavy DOM manipulations.\nImagine you are running a yes-like command that writes output at full 10.2GiB/s speed. You will find that your web-based terminal emulator stuck and cannot response to any mouse event anymore. The high speed yes triggers a tremendous amount of synchronous reflows and repaints. Soon, the browser becomes irresponsive.\nOptimization in Dark DOM Era Back to the original version before refactoring to canvas renderer (which started at c6d4c73c). VS Code used naïve way to render terminal output. We can simplify the old rendering process into following steps:\n Setup initial row elements corresponding to each row in terminal. That is to say, if size of the terminal is 80 * 24. It would creates 24  representing each row. Loops lines from current terminal buffer. Each line is an array of character data. A character data stores its own width and characters information. Loop character data in each line. Wrap each characters as innerHTML in a  element. Remember that we need to escape special character such like ,  and \u0026. Append s to each row element. Then append each row element to terminal element. If anything changes, repeat previous steps.  What a nightmare!\nIf you are an experienced web developer, you may feel uncomfortable with all those implementation. Modifying DOM between each updates is highly expensive and leads to janky behavior. Luckily, talented maintainers of Xterm.js found their own solution to improve performance. They\n Use DocumentFragment to batch DOM manipulations to reduce DOM reflow/layout. Build an object pool to reuse  elements containing characters to render. This reduce a plenty of new element creation time. Setup a skip-frame mechanism to throttle refresh rate when consuming large streamed buffer. Implement a custom selection logic to support multiple pages selections instead of document.getSelection.  Despite that these methods made performance much better (at least better than other popular project I’ve tried), the implementation still had some space for enhancements. For instance,\n Modification of s in  rows still trigger some unnecessary reflows. The old rendering process will always remove entire line from DOM, and then append new element to DOM, even when only a single character changed. Though the skip-frame mechanism can free CPU from endless requestAnimationFrame events, the skip-frame itself means dropping frame from 60 FPS animation. Most characters used in terminal can represent in ASCII code, but a browser always use UTF-16 DOMString to store the information, which may be seen as a waste of memory usage.  Simple Intro of Canvas As the recent blog post said, the new canvas-based rendering engine renders 5 to 45 times faster, and reduces input latency, power usage and many more. Sounds perfect! However, not all front-end developers are familiar with canvas API. Here are some basic concepts of canvas API you need to know.\nThe  is an HTML element providing API for rendering graphics via scripting (JavaScript) on the fly. Modern browsers would also enable hardware-acceleration of canvas rendering by default. You can think of canvas API as an optimized version of browser’s repaint powered by GPU.\nAPI Provider To render a 2D canvas, one developer just need to follow simple steps shown below:\n Create a rendering context (by creating a  element). Access contexts (use canvas.getContext('2d') for 2D rendering context). Start drawing via various commands. All drawing results are rendered onto canvas element as an composited image.  As you can see, learning 2D canvas rendering needs only a small amount (around 70 API for 2D context) of human memory. Most of these drawing API are style-related. As a web developer, you must have seen more CSS styles than these tiny group of drawing commands. Memorizing 70 additional methods is just a piece of cake, huh?\nResource Saver Another selling points is that 2D Canvas rendering provides a plenty of pixel-awared drawing commands. Instead of updating the whole canvas element, these drawing methods let you decide your region of interest to be re-render in per-pixel level. Almost all drawing API provide optional coordinates and size parameters for devs to tweak what they really desire. The process of updating only changed elements is called invalidation, and that preserves much precious CPU and GPU time.\nAs opposed to DOM elements, styles in 2D canvas are shared between each path belongs to the canvas. No need to store inline-styling information for every elements. If you want to temporarily store your style state, you can use the standard context.save() and context.restore() methods to push/pop your styles from a stack-like context state container. That’s why I call canvas a memory saver!\nPerformance Booster As well as saving resources, canvas rendering also gives us ways to jack up performance. One is using detached canvas as an off-screen canvas or using OffScreenCanvas directly. The latter can even draw canvas in worker threads!\nAnother way is creating a texture atlas. A texture atlas a.k.a. sprite sheet, is an image packed other small pieces of sub-images into itself. When drawing a sub-image, one can picks up the sub-image by its own texture coordinates. The reason to store images in single texture is that GPU is often more performant when accessing a large texture one time than multiple tiny images many times.\n Nyancat runs on VS Code without janky!\n Canvas to the Rescue After understand big concepts in 2D canvas. Let’s dive into the pull request that made canvas renderer. First, recap what they’ve done:\n Texture atlas (use ImageBitmap) for ASCII codes and ANSI 256 colors. Unicode characters and true-colored text would be drawn on the fly. Only render changes. To determine state changes, use custom GridCache to store previous state for comparisons with incoming changes. Use four different render layers to separate concerns and reduce the whole canvas re-rendering. Remove skip-frame mechanism because new rendering performance is extremely fast.  Texture Atlas and Color Managements First, we look into the texture atlas.\nXterm.js constructs a global atlas generator shared between terminals with the same configuration (defined in ICharAtlasConfig and ICharAtlasCacheEntry). This can reduces some duplicated construction if an app gets a multiple terminal instances such as VS Code. The actual time that a atlas generated is terminal being opened by calling acquireCharAtlas. Internally, acquireCharAtlas would compare between configurations (font size, char width, color, etc.) to avoid overhead works.\nThe private class CharAtlasGenerator does the real stuff. It sets attribute alpha to false to reduce redundant transparent compositions. Though this config seen like a limit of flexibility, the texture atlas is enough to provides frequently used colors for most text-based programs in the world. Moreover, the generator draws all ASCII code with 8 ANSI color (3 bit) in normal and bold styles onto an detached canvas in advance. That would be nearly 256 * 16 = 4096 characters pre-rendered (though some char is invisible and not printable).\n That’s how the CharAtlas looks behind the scene.\n All colors you need on your 5-year-old ASUS laptop is here. Whoever needs more characters atlas?\n In the beginning, I found that the CharAtlas generating actually twice (canvas element and ImageBitmap). Tyriar told me the intent, what they want to achieve is not only improving the construction performance, but decreasing drawing latency.\n Separating Render Layers Xterm.js separates the canvas rendering into four different layers (ordered from bottom to top):\n TextRenderLayer: Render background and foreground of the content. SelectionRenderLayer: Render only selected region. LinkRenderLayer: Render hyperlink with extra color and text decorator (underline). CursorRenderLayer: Render different style of a blinking cursor.  This can gain a performance boost since the render engine only repaint changed parts instead of the whole canvas. While constructing 4 different canvases is awesome, we lost the chance to set canvas' alpha channel to opaque. This may lead to a performance drop on 2D graphic composition. The compositor requires extra GPU time to composite 4 additional transparent contexts. GUI framework providers always recommend that use opaque layer as possible as we can (at least iOS UIKit and Canvas 2D Context said).\nIn reality, it may not cause any problem if you layer is not opaque. I have not yet done any profiling or tests. Just have a thought on this kind of situation.\nOn the other side, it is very pleasant to trace a well-organized source code. We do not need to plunge ourselves into each lines if we only want to understand a little part of code. And Xterm.js does this job perfectly. The separation of render layers is an awesome example. The feeling deepens even more when the codebase is written in TypeScript. As a former iOS engineer, the syntax of type annotations are very familiar and helpful to rapidly grasp the big picture of a project for a newcomer. Maybe it’s time to use TypeScript in our next project. Thanks Xterm.js contributors!\nBugs After Breaking Changes Canvas renderer is awesome! Canvas renderer is promising! Canvas renderer outperforms all competitors in web-based terminal world!\nIs the new renderer really that invulnerable? Maybe not.\nLet me introduce some interesting issues after the switch of render engine.\nRendering Unicode Characters Wrong When it comes to strings and texts. This may be a big nightmare to all developers. One feature Xterms.js always promoting is handling CJK fonts well. Actually, before introducing canvas renderer, most of this works done by browsers' DOM render engine internally to handle various widths of Unicode characters. When the team chose to render character on our own renderer, the burden fell on Xterm.js itself. To render texts properly, Xterm.js needs to manually track width of all characters. Explicitly set width of render region is a must. 2D Canvas API is always that imperative and there is no way to stay away from it.\nSurprisingly, Xterm.js has already done it before canvas render landed! It used a custom data structure to track width of a character for some resizing calculations. The only task after renderer changed is passing the character width into canvas.fillText.\nActually, character width received from terminal input are not always correct. Some characters consume more space than expected.The truth is Xterm.js extracted some concepts from this wcwidth.c implementation. Although the implementation covered almost all CJK and other Unicode characters with various width, it have not been modified time since 2007. During these 10 years, Emoji become prosperous. Suddenly, outdated wcwidth implementation cannot support arriving crazy overflowing characters.\nBut Xterm.js team did not feel contented with the situation, and later they resolved the issue blazing fast. If you want to know about what they did, there was nothing but delegating up the responsibility of width calculation to web browsers' render engine. When calling ctx.measureText, the render engine measures the target text in specific canvas context, then returns a TextMatrix that stores information abount how the text would be rendered, such as width, actualBoundingBoxLeft, and alphabeticBaseline. This implementation need not to acquire any Unicode code point mapping beforehand. Just believe that all browsers do it right.\nLack of True Color Support As hardware advanced, true color terminal programs are more common nowadays. The lack of real true color support become a major problems of Xterm.js. I haven’t trace to intent why the original Xterm.js supported only ANSI 256 color, but it makes sense that canvas renderer does not support true color.\nThere is a class ColorManager which constructs ANSI 256 color to hex color mapping table beforehand in Xterm.js v3. This eliminates dupe computations of each hex color. However, If we want to store all the true color palette, that would be combinations of 3 color channels (RGB) mutiplying alpha channel, which approximately equal to 16 million of combinations! It’s impossible to store that huge CharAtlas in memory simultaneously.\nThus, they use a hacky way (in Terminal.ts) to make colors look like true color. The goal of this algorithm is to find the nearest color in ANSI 256 color palette. While we try some real tests on it, we still can tell the differences without doubt. Some matching results are even so worse that they almost look like inverted colors. Many open-source projects depended on Xterm.js are eager for true color supports, including famous terminal app Hyper. However, it seems that supports for true color is not the primary goal and has been remove from v3 milestones, but the related discussion on Github is still valuable to take a look.\n The REAL true color in Alacritty.\n  The **quasi-**true color in VS Code 1.17.\n Summary It is very lucky see that a widely used library is brave enough to make breaking changes. When I followed up the PR to read source code of Xterm.js, I almost believed that I were working with those brilliant contributors. The experience of tracing a well documented refactor process is awesome. You can learn from some surprising solutions you have never thought before. You can also learn many communicating skills in open source world. Although canvas API is not the latest web standard and Xterm.js is not a well-known project compared with React and Vue, the success of Xterm.js’s renderer refactor is worthy for learning!\n","wordCount":"2580","inLanguage":"en","datePublished":"2017-10-12T22:05:03+08:00","dateModified":"2017-10-12T22:05:03+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://weihanglo.tw/posts/2017/how-is-new-terminal-in-vs-code-so-fast/"},"publisher":{"@type":"Organization","name":"Weihang Lo","logo":{"@type":"ImageObject","url":"https://weihanglo.tw/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://weihanglo.tw accesskey=h title="Weihang Lo (Alt + H)">Weihang Lo</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://weihanglo.tw/ title=Home>
<span>Home</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/posts/ title=Posts>
<span>Posts</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
How Is New Terminal In VS Code So Fast?
</h1>
<div class=post-meta><span title="2017-10-12 22:05:03 +0800 +0800">October 12, 2017</span>&nbsp;·&nbsp;13 min
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#old-performance-issue aria-label="Old Performance Issue">Old Performance Issue</a><ul>
<li>
<a href=#reflow aria-label=Reflow>Reflow</a></li>
<li>
<a href=#repaint aria-label=Repaint>Repaint</a></li>
<li>
<a href=#dom-manipulations aria-label="DOM manipulations">DOM manipulations</a></li></ul>
</li>
<li>
<a href=#optimization-in-dark-dom-era aria-label="Optimization in Dark DOM Era">Optimization in Dark DOM Era</a></li>
<li>
<a href=#simple-intro-of-canvas aria-label="Simple Intro of Canvas">Simple Intro of Canvas</a><ul>
<li>
<a href=#api-provider aria-label="API Provider">API Provider</a></li>
<li>
<a href=#resource-saver aria-label="Resource Saver">Resource Saver</a></li>
<li>
<a href=#performance-booster aria-label="Performance Booster">Performance Booster</a></li></ul>
</li>
<li>
<a href=#canvas-to-the-rescue aria-label="Canvas to the Rescue">Canvas to the Rescue</a><ul>
<li>
<a href=#texture-atlas-and-color-managements aria-label="Texture Atlas and Color Managements">Texture Atlas and Color Managements</a></li>
<li>
<a href=#separating-render-layers aria-label="Separating Render Layers">Separating Render Layers</a></li></ul>
</li>
<li>
<a href=#bugs-after-breaking-changes aria-label="Bugs After Breaking Changes">Bugs After Breaking Changes</a><ul>
<li>
<a href=#rendering-unicode-characters-wrong aria-label="Rendering Unicode Characters Wrong">Rendering Unicode Characters Wrong</a></li>
<li>
<a href=#lack-of-true-color-support aria-label="Lack of True Color Support">Lack of True Color Support</a></li></ul>
</li>
<li>
<a href=#summary aria-label=Summary>Summary</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p><img loading=lazy src=https://i.imgur.com/KGfkJxn.png alt>
</p>
<p>Last week, a new version (1.17) of Visual Studio Code was released. While there are many fascinating improvements and features introduced, the one that cought my eyes is &ldquo;Integrated Terminal performance&rdquo; section. Let&rsquo;s check out what they&rsquo;ve done!</p>
<p><em>(written on 2017-10-12, based on Xterm.js v3, VS Code 1.17)</em></p>
<h2 id=old-performance-issue>Old Performance Issue<a hidden class=anchor aria-hidden=true href=#old-performance-issue>#</a></h2>
<p>The integrated terminal in VS Code is powered by another popular open-source project <a href=https://github.com/sourcelair/xterm.js>&ldquo;Xterm.js&rdquo;</a>, which is currently maintained by <a href=https://www.sourcelair.com>SourceLair</a> and community contributors. There are many real-world use cases of Xterm.js, such as <a href=https://www.rstudio.com/products/RStudio/>RStudio</a> and <a href=https://github.com/jupyterlab/jupyterlab>JupyterLab</a> (Ah ha! Data scientist!), not to mention SourceLair itself. One can say that Xterm.js dominates web-based terminal world as React does in front-end development.</p>
<p>As same as other web-based HTML terminal emulators, old versions of Xterm.js are powered by old fashion. Rendering from <code>HTMLElement</code>s, selecting text via <code>document.getSelection</code>, receiving DOM <code>MouseEvent</code>s. All these works were done by a sequence of DOM manipulations.</p>
<p>Development in modern web technologies lowers the barriers for other devs to contribute to. Every programmer can easily pick up a JavaScript cookbook to study, then boasts about new frameworks on Github trending as he is a JavaScript expert. However, web techs also brings another significant drawback: performance.</p>
<p>As we mention to web performance, two key concepts should be kept in mind: <strong>reflow</strong> and <strong>repaint</strong>.</p>
<p><img loading=lazy src=gecko-rendering-process.png alt="Gecko Rendering Process">
</p>
<blockquote>
<p>Image from MDN. We focus on <strong>layout</strong> and <strong>paint</strong>.</p>
</blockquote>
<h3 id=reflow>Reflow<a hidden class=anchor aria-hidden=true href=#reflow>#</a></h3>
<p>When a web page is initialized, the render engine calculates dimensions and position of all elements to layout them in proper place. This is known as <strong>layout</strong>. Although layout is a normal stage of browser rendering process, any updates of position, dimensions or other properties on a specific element after initialization will lead to an additional layout on that element, and all its child nodes need to do a extra layout, too (except nodes with absolute position). These synchronously layout calculations are called <strong>reflows</strong>, which might result in performance bottlenecks.</p>
<blockquote>
<p>Here is a list of <a href=https://gist.github.com/paulirish/5d52fb081b3570c81e3a>what forces layout / reflow</a>. Read it to avoid reflows.</p>
</blockquote>
<h3 id=repaint>Repaint<a hidden class=anchor aria-hidden=true href=#repaint>#</a></h3>
<p>A <strong>repaint</strong> occurs when changes are made to an element&rsquo;s visibility, background color, or other styles not relevant to layout. Repaints are less expensive than reflows, but also have some impact on browser responsive time.</p>
<h3 id=dom-manipulations>DOM manipulations<a hidden class=anchor aria-hidden=true href=#dom-manipulations>#</a></h3>
<p>Poor performance is not web techs or JavaScript&rsquo;s faults. It always counts on implementation details. <a href=https://hyper.is/>Hyper</a> and <a href=https://github.com/railsware/upterm>Upterm</a> are two delightful terminal emulators based on Electron. They add many convenient features to improve our boring daily terminal lives. The pain points are their performance issues due to DOM rendering. Both rendering implementations depend on heavy DOM manipulations.</p>
<p>Imagine you are running a <code>yes</code>-like command that writes output at <a href=https://www.reddit.com/r/unix/comments/6gxduc/how_is_gnu_yes_so_fast/>full 10.2GiB/s speed</a>. You will find that your web-based terminal emulator stuck and cannot response to any mouse event anymore. The high speed <code>yes</code> triggers a tremendous amount of synchronous <strong>reflows</strong> and <strong>repaints</strong>. Soon, the browser becomes irresponsive.</p>
<h2 id=optimization-in-dark-dom-era>Optimization in Dark DOM Era<a hidden class=anchor aria-hidden=true href=#optimization-in-dark-dom-era>#</a></h2>
<p>Back to the original version before refactoring to canvas renderer (which started at <a href=https://github.com/sourcelair/xterm.js/commit/c6d4c73c>c6d4c73c</a>). VS Code used naïve way to render terminal output. We can simplify the old rendering process into following steps:</p>
<ol>
<li>Setup initial row elements corresponding to each row in terminal. That is to say, if size of the terminal is 80 * 24. It would creates 24 <code>&lt;div></code> representing each row.</li>
<li>Loops lines from current terminal buffer. Each line is an array of character data. A character data stores its own width and characters information.</li>
<li>Loop character data in each line. Wrap each characters as <code>innerHTML</code> in a <code>&lt;span></code> element. Remember that we need to escape special character such like <code>&lt;</code>, <code>></code> and <code>&</code>.</li>
<li>Append <code>&lt;span></code>s to each row element. Then append each row element to terminal element.</li>
<li>If anything changes, repeat previous steps.</li>
</ol>
<p><strong>What a nightmare!</strong></p>
<p>If you are an experienced web developer, you may feel uncomfortable with all those implementation. Modifying DOM between each updates is highly expensive and leads to janky behavior. Luckily, talented maintainers of Xterm.js found their own solution to improve performance. They</p>
<ul>
<li><a href=https://github.com/sourcelair/xterm.js/blob/c6d4c73c8a8c23ce102918fc0342cf33d2986711/src/Renderer.ts#L159>Use <code>DocumentFragment</code> to batch DOM manipulations</a> to reduce DOM reflow/layout.</li>
<li><a href=https://github.com/sourcelair/xterm.js/blob/c6d4c73c8a8c23ce102918fc0342cf33d2986711/src/Renderer.ts#L35>Build an object pool</a> to reuse <code>&lt;span></code> elements containing characters to render. This reduce a plenty of new element creation time.</li>
<li><a href=https://github.com/sourcelair/xterm.js/blob/c6d4c73c8a8c23ce102918fc0342cf33d2986711/src/Renderer.ts#L67-L102>Setup a skip-frame mechanism</a> to throttle refresh rate when consuming large streamed buffer.</li>
<li>Implement a <a href=https://github.com/sourcelair/xterm.js/pull/670>custom selection logic</a> to support multiple pages selections instead of <code>document.getSelection</code>.</li>
</ul>
<p>Despite that these methods made performance much better (at least better than other popular project I&rsquo;ve tried), the implementation still had some space for enhancements. For instance,</p>
<ul>
<li>Modification of <code>&lt;span></code>s in <code>&lt;div></code> rows still trigger some unnecessary reflows.</li>
<li>The old rendering process will always remove entire line from DOM, and then append new element to DOM, even when only a single character changed.</li>
<li>Though the skip-frame mechanism can free CPU from endless <code>requestAnimationFrame</code> events, the skip-frame itself means dropping frame from 60 FPS animation.</li>
<li>Most characters used in terminal can represent in ASCII code, but a browser always use UTF-16 <code>DOMString</code> to store the information, which may be seen as a waste of memory usage.</li>
</ul>
<h2 id=simple-intro-of-canvas>Simple Intro of Canvas<a hidden class=anchor aria-hidden=true href=#simple-intro-of-canvas>#</a></h2>
<p><a href=https://code.visualstudio.com/blogs/2017/10/03/terminal-renderer>As the recent blog post said</a>, the new canvas-based rendering engine renders 5 to 45 times faster, and reduces input latency, power usage and many more. Sounds perfect! However, not all front-end developers are familiar with canvas API. Here are some basic concepts of canvas API you need to know.</p>
<p>The <code>&lt;canvas></code> is an HTML element providing API for rendering graphics via scripting (JavaScript) on the fly. Modern browsers would also enable hardware-acceleration of canvas rendering by default. You can think of canvas API as an optimized version of browser&rsquo;s <strong>repaint</strong> powered by GPU.</p>
<h3 id=api-provider>API Provider<a hidden class=anchor aria-hidden=true href=#api-provider>#</a></h3>
<p>To render a 2D canvas, one developer just need to follow simple steps shown below:</p>
<ol>
<li>Create a rendering context (by creating a <code>&lt;canvas></code> element).</li>
<li>Access contexts (use <code>canvas.getContext('2d')</code> for 2D rendering context).</li>
<li>Start drawing via <a href=https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D>various commands</a>.</li>
<li>All drawing results are rendered onto canvas element as an composited image.</li>
</ol>
<p>As you can see, learning 2D canvas rendering needs only a small amount (around 70 API for 2D context) of human memory. Most of these drawing API are style-related. As a web developer, you must have seen more CSS styles than these tiny group of drawing commands. Memorizing 70 additional methods is just a piece of cake, huh?</p>
<h3 id=resource-saver>Resource Saver<a hidden class=anchor aria-hidden=true href=#resource-saver>#</a></h3>
<p>Another selling points is that 2D Canvas rendering provides a plenty of <strong>pixel-awared</strong> drawing commands. Instead of updating the whole canvas element, these drawing methods let you decide your region of interest to be re-render in <a href=https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas>per-pixel level</a>. Almost all drawing API provide optional coordinates and size parameters for devs to tweak what they really desire. The process of updating only changed elements is called <strong>invalidation</strong>, and that preserves much precious CPU and GPU time.</p>
<p>As opposed to DOM elements, styles in 2D canvas are shared between each path belongs to the canvas. No need to store inline-styling information for every elements. If you want to temporarily store your style state, you can use the standard <code>context.save()</code> and <code>context.restore()</code> methods to push/pop your styles from a stack-like context state container. That&rsquo;s why I call canvas a <strong>memory saver</strong>!</p>
<h3 id=performance-booster>Performance Booster<a hidden class=anchor aria-hidden=true href=#performance-booster>#</a></h3>
<p>As well as saving resources, canvas rendering also gives us ways to jack up performance. One is using detached canvas as an off-screen canvas or using <code>OffScreenCanvas</code> directly. The latter can even draw canvas in worker threads!</p>
<p>Another way is creating a texture atlas. A <a href=https://en.wikipedia.org/wiki/Texture_atlas>texture atlas</a> a.k.a. <strong>sprite sheet</strong>, is an image packed other small pieces of sub-images into itself. When drawing a sub-image, one can picks up the sub-image by its own texture coordinates. The reason to store images in single texture is that GPU is often more performant when accessing a large texture one time than multiple tiny images many times.</p>
<p></p>
<blockquote>
<p>Nyancat runs on VS Code without janky!</p>
</blockquote>
<h2 id=canvas-to-the-rescue>Canvas to the Rescue<a hidden class=anchor aria-hidden=true href=#canvas-to-the-rescue>#</a></h2>
<p>After understand big concepts in 2D canvas. Let&rsquo;s dive into <a href=https://github.com/sourcelair/xterm.js/pull/938>the pull request</a> that made canvas renderer. First, recap what they&rsquo;ve done:</p>
<ol>
<li>Texture atlas (use <code>ImageBitmap</code>) for ASCII codes and ANSI 256 colors. Unicode characters and true-colored text would be drawn on the fly.</li>
<li>Only render changes. To determine state changes, use custom <code>GridCache</code> to store previous state for comparisons with incoming changes.</li>
<li>Use four different render layers to separate concerns and reduce the whole canvas re-rendering.</li>
<li>Remove skip-frame mechanism because new rendering performance is extremely fast.</li>
</ol>
<h3 id=texture-atlas-and-color-managements>Texture Atlas and Color Managements<a hidden class=anchor aria-hidden=true href=#texture-atlas-and-color-managements>#</a></h3>
<p>First, we look into the texture atlas.</p>
<p>Xterm.js constructs a global atlas generator shared between terminals with the same configuration (defined in <code>ICharAtlasConfig</code> and <code>ICharAtlasCacheEntry</code>). This can reduces some duplicated construction if an app gets a multiple terminal instances such as VS Code. The actual time that a atlas generated is terminal being opened by calling <code>acquireCharAtlas</code>. Internally, <code>acquireCharAtlas</code> would compare between configurations (font size, char width, color, etc.) to avoid overhead works.</p>
<p>The private class <code>CharAtlasGenerator</code> does the real stuff. It sets attribute <code>alpha</code> to <code>false</code> to reduce redundant transparent compositions. Though this config seen like a limit of flexibility, the texture atlas is enough to provides frequently used colors for most text-based programs in the world. Moreover, the generator draws all ASCII code with 8 ANSI color (3 bit) in normal and bold styles onto an detached canvas in advance. That would be nearly 256 * 16 = 4096 characters pre-rendered (though some char is invisible and not printable).</p>
<p><img loading=lazy src=imagebitmap.png alt=ImageBitmap>
</p>
<blockquote>
<p>That&rsquo;s how the <code>CharAtlas</code> looks behind the scene.</p>
</blockquote>
<p>All colors you need on your 5-year-old ASUS laptop is here. Whoever needs more characters atlas?</p>
<blockquote>
<p>In the beginning, I found that the CharAtlas generating actually twice (canvas element and ImageBitmap). <a href=https://github.com/sourcelair/xterm.js/pull/938#pullrequestreview-69391070>Tyriar told me the intent</a>, what they want to achieve is not only improving the construction performance, but decreasing drawing latency.</p>
</blockquote>
<h3 id=separating-render-layers>Separating Render Layers<a hidden class=anchor aria-hidden=true href=#separating-render-layers>#</a></h3>
<p>Xterm.js separates the canvas rendering into four different layers (ordered from bottom to top):</p>
<ul>
<li><code>TextRenderLayer</code>: Render background and foreground of the content.</li>
<li><code>SelectionRenderLayer</code>: Render only selected region.</li>
<li><code>LinkRenderLayer</code>: Render hyperlink with extra color and text decorator (underline).</li>
<li><code>CursorRenderLayer</code>: Render different style of a blinking cursor.</li>
</ul>
<p>This can gain a performance boost since the render engine only repaint changed parts instead of the whole canvas. While constructing 4 different canvases is awesome, we lost the chance to set canvas' alpha channel to opaque. This may lead to a performance drop on 2D graphic composition. The compositor requires extra GPU time to composite 4 additional transparent contexts. GUI framework providers always recommend that use opaque layer as possible as we can (at least <a href=https://developer.apple.com/documentation/uikit/uiview/1622622-isopaque>iOS UIKit</a> and <a href=https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext#Parameters>Canvas 2D Context</a> said).</p>
<p>In reality, it may not cause any problem if you layer is not opaque. I have not yet done any profiling or tests. Just have a thought on this kind of situation.</p>
<p>On the other side, it is very pleasant to trace a well-organized source code. We do not need to plunge ourselves into each lines if we only want to understand a little part of code. And Xterm.js does this job perfectly. The separation of render layers is an awesome example. The feeling deepens even more when the codebase is written in TypeScript. As a former iOS engineer, the syntax of type annotations are very familiar and helpful to rapidly grasp the big picture of a project for a newcomer. Maybe it&rsquo;s time to use TypeScript in our next project. Thanks Xterm.js contributors!</p>
<h2 id=bugs-after-breaking-changes>Bugs After Breaking Changes<a hidden class=anchor aria-hidden=true href=#bugs-after-breaking-changes>#</a></h2>
<p>Canvas renderer is awesome! Canvas renderer is promising! Canvas renderer outperforms all competitors in web-based terminal world!</p>
<p>Is the new renderer really that invulnerable? Maybe not.</p>
<p>Let me introduce some interesting issues after the switch of render engine.</p>
<h3 id=rendering-unicode-characters-wrong>Rendering Unicode Characters Wrong<a hidden class=anchor aria-hidden=true href=#rendering-unicode-characters-wrong>#</a></h3>
<p>When it comes to strings and texts. This may be a big nightmare to all developers. One feature Xterms.js always promoting is handling CJK fonts well. Actually, before introducing canvas renderer, most of this works done by browsers' DOM render engine internally to handle various widths of Unicode characters. When the team chose to render character on our own renderer, the burden fell on Xterm.js itself. To render texts properly, Xterm.js needs to manually track width of all characters. Explicitly set width of render region is a must. 2D Canvas API is always that imperative and there is no way to stay away from it.</p>
<p>Surprisingly, Xterm.js has already done it before canvas render landed! It used a custom data structure to track width of a character for some resizing calculations. The only task after renderer changed is passing the character width into <code>canvas.fillText</code>.</p>
<p>Actually, character width received from terminal input are not always correct. Some characters <a href=https://github.com/Microsoft/vscode/issues/35102>consume more space than expected</a>.The truth is Xterm.js extracted some concepts from <a href=https://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c>this <code>wcwidth.c</code> implementation</a>. Although the implementation covered almost all CJK and other Unicode characters with various width, it have not been modified time since 2007. During these 10 years, Emoji become prosperous. Suddenly, outdated <code>wcwidth</code> implementation cannot support arriving crazy overflowing characters.</p>
<p>But Xterm.js team did not feel contented with the situation, and later they <a href=https://github.com/sourcelair/xterm.js/pull/997>resolved the issue</a> blazing fast. If you want to know about what they did, there was nothing but <a href=https://github.com/mofux/xterm.js/blob/b3efd7e0fd1e1ebef84cfa05d741a7bbaf9441e4/src/renderer/TextRenderLayer.ts#L207>delegating up the responsibility of width calculation</a> to web browsers' render engine. When calling <code>ctx.measureText</code>, the render engine measures the target text in specific canvas context, then returns a <code>TextMatrix</code> that stores information abount how the text would be rendered, such as <code>width</code>, <code>actualBoundingBoxLeft</code>, and <code>alphabeticBaseline</code>. This implementation need not to acquire any Unicode code point mapping beforehand. Just believe that all browsers do it right.</p>
<h3 id=lack-of-true-color-support>Lack of True Color Support<a hidden class=anchor aria-hidden=true href=#lack-of-true-color-support>#</a></h3>
<p>As hardware advanced, true color terminal programs are more common nowadays. The lack of real true color support become a major problems of Xterm.js. I haven&rsquo;t trace to intent why the original Xterm.js supported only ANSI 256 color, but it makes sense that canvas renderer does not support true color.</p>
<p>There is a class <code>ColorManager</code> which constructs ANSI 256 color to hex color mapping table beforehand in Xterm.js v3. This eliminates dupe computations of each hex color. However, If we want to store all the true color palette, that would be combinations of 3 color channels (RGB) mutiplying alpha channel, which approximately equal to 16 million of combinations! It&rsquo;s impossible to store that huge <code>CharAtlas</code> in memory simultaneously.</p>
<p>Thus, they use a hacky way (in <a href=https://github.com/sourcelair/xterm.js/blob/2e8410da4bf4ccc44b7277ec22a0d473565c9d13/src/Terminal.ts#L2146-L2230>Terminal.ts</a>) to make colors look like true color. The goal of this algorithm is to find the nearest color in ANSI 256 color palette. While we try <a href=https://gist.github.com/XVilka/8346728>some real tests</a> on it, we still can tell the differences without doubt. Some matching results are even so worse that they almost look like inverted colors. Many open-source projects depended on Xterm.js are eager for true color supports, including famous terminal app <a href=https://github.com/zeit/hyper/issues/2294>Hyper</a>. However, it seems that supports for true color is not the primary goal and has been remove from v3 milestones, but <a href=https://github.com/sourcelair/xterm.js/issues/484>the related discussion on Github</a> is still valuable to take a look.</p>
<p><img loading=lazy src=real-true-color-image.png alt="Real True Color Image">
</p>
<blockquote>
<p>The <strong>REAL</strong> true color in <a href=https://github.com/jwilm/alacritty>Alacritty</a>.</p>
</blockquote>
<p><img loading=lazy src=fake-true-color-image.png alt="Fake True Color Image">
</p>
<blockquote>
<p>The **quasi-**true color in VS Code 1.17.</p>
</blockquote>
<h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2>
<p>It is very lucky see that a widely used library is brave enough to make breaking changes. When I followed up the PR to read source code of Xterm.js, I almost believed that I were working with those brilliant contributors. The experience of tracing a well documented refactor process is awesome. You can learn from some surprising solutions you have never thought before. You can also learn many communicating skills in open source world. Although canvas API is not the latest web standard and Xterm.js is not a well-known project compared with React and Vue, the success of Xterm.js&rsquo;s renderer refactor is worthy for learning!</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://weihanglo.tw/tags/canvas/>Canvas</a></li>
<li><a href=https://weihanglo.tw/tags/front-end/>Front-end</a></li>
<li><a href=https://weihanglo.tw/tags/terminal/>Terminal</a></li>
<li><a href=https://weihanglo.tw/tags/visual-studio-code/>Visual Studio Code</a></li>
<li><a href=https://weihanglo.tw/tags/source-reading/>Source Reading</a></li>
<li><a href=https://weihanglo.tw/tags/xterm.js/>Xterm.js</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://weihanglo.tw/posts/2017/days-with-internet-explorer-2/>
<span class=title>« Prev Page</span>
<br>
<span>與 IE 相處的日子二：淺談網頁相容性</span>
</a>
<a class=next href=https://weihanglo.tw/posts/2017/binary-data-manipulations-in-javascript/>
<span class=title>Next Page »</span>
<br>
<span>使用 JavaScript 處理二進位資料</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>CC BY-NC-SA 4.0</span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>