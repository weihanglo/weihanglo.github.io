<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rx 入門一：迭代器模式 | Life is a refactoring process without tests</title>
<meta name=keywords content="Design Patterns,Iterator Pattern,Swift,ReactiveX"><meta name=description content="本篇介紹 Rx 的重要基礎概念 Iterator pattern（迭代器模式）。 （撰於 2017-08-15，基於 Swift 3.1） Definition 迭代器模式（Iterator patter"><meta name=author content><link rel=canonical href=https://weihanglo.tw/posts/2017/intro-rx-1-iterator-pattern/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://weihanglo.tw/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://weihanglo.tw/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://weihanglo.tw/favicon-32x32.png><link rel=apple-touch-icon href=https://weihanglo.tw/apple-touch-icon.png><link rel=mask-icon href=https://weihanglo.tw/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://weihanglo.tw/posts/2017/intro-rx-1-iterator-pattern/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:title" content="Rx 入門一：迭代器模式"><meta property="og:description" content="本篇介紹 Rx 的重要基礎概念 Iterator pattern（迭代器模式）。 （撰於 2017-08-15，基於 Swift 3.1） Definition 迭代器模式（Iterator patter"><meta property="og:type" content="article"><meta property="og:url" content="https://weihanglo.tw/posts/2017/intro-rx-1-iterator-pattern/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-08-15T13:06:59+08:00"><meta property="article:modified_time" content="2017-08-15T13:06:59+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rx 入門一：迭代器模式"><meta name=twitter:description content="本篇介紹 Rx 的重要基礎概念 Iterator pattern（迭代器模式）。 （撰於 2017-08-15，基於 Swift 3.1） Definition 迭代器模式（Iterator patter"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://weihanglo.tw/posts/"},{"@type":"ListItem","position":2,"name":"Rx 入門一：迭代器模式","item":"https://weihanglo.tw/posts/2017/intro-rx-1-iterator-pattern/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rx 入門一：迭代器模式","name":"Rx 入門一：迭代器模式","description":"本篇介紹 Rx 的重要基礎概念 Iterator pattern（迭代器模式）。 （撰於 2017-08-15，基於 Swift 3.1） Definition 迭代器模式（Iterator patter","keywords":["Design Patterns","Iterator Pattern","Swift","ReactiveX"],"articleBody":"本篇介紹 Rx 的重要基礎概念 Iterator pattern（迭代器模式）。\n（撰於 2017-08-15，基於 Swift 3.1）\nDefinition 迭代器模式（Iterator pattern） 提供一個迭代器，讓使用者透過特定方式走訪序列（sequence）中的元素，而不需知道底層的演算法。\nApplication Iterator pattern 是最基本的設計模式之一，基本上大部分語言的 for-in loop 都是 iterator pattern 的實作。我們可以說 Python 的 for x in iterable 符合 iterator pattern，因為 Python 將該 iterable 封裝起來，使用者對 iterator 如何取得下一個 element 並不知情；Swift 的 for x in Sequence 中 Sequence protocol 也有 iterator 介面，並提供了 default implementation。\n相反地， C 的 for (int i = 0; i \u003c n; i++) 通常不認為是 iterator pattern，因為使用者知道底層資料儲存在連續的記憶體空間中，也必須自行透過指針迭代。\n透過 iterator 封裝的序列（或集合），讓調用者不需關係實作，只需使用統一的 for loop，或是 map、reduce、filter 等高階函數，即操作序列中的元素，完全與演算法解耦合。\nRequirements 一般來說，要符合 iterator pattern 的實作，通常會有以下幾個介面：\n一個取得下一個 element 的方法，通常是 next 告知使用者是否仍有下個 element 的方法，各語言有自己對應的實作，如： 拋出 Exception（Python） 主動 call hasNext 方法（Java） 回傳 flag 判斷迭代是否完成（JavaScript） 直接回傳 nil（Swift） IteratorProtocol \u0026 Sequence 在深入 iterator pattern 前，先來理解 Swift 最重要的兩個 protocol：IteratorProtocol 與 Sequence。\nSwift 實作 iterator 須符合 IteratorProtocol，該 protocol 要求一個 next method。雖然簡單，但要實作 iterator pattern 也是滿繁瑣的。我們直接看例子。\n// 宣告一個 countdown 用的 iterator struct，每次迭代時會將當前計數減一。 struct CountdownIterator: IteratorProtocol { var count: Int mutating func next() -\u003e Int? { guard count \u003e 0 else { return nil } count -= 1 return count } } 其實這樣就做完我們的 iterator 了，我們可以嘗試使用 while loop 使用這個倒數計時器。\nvar it = CountdownIterator(count: 5) while let v = it.next() { print(v) } /// 4 3 2 1 0 不過通常我們會希望將 next 方法藏起來，利用簡單的 for-in loop 迭代，這時候就該 Sequence protocol 出場。Sequence protocol 提供一個按序迭代的介面，讓調用者可好整以暇的使用。只要符合 Comparable、Equatable 等 protocol，Sequence 甚至提供許多方便的 default implementations。\n一般來說，Sequence 需有 iterator 的 associatedType，以及 makeIterator 方法，提供 sequence 製造 iterator 的介面。\nstruct Countdown: Sequence { let count: Int func makeIterator() -\u003e CountdownIterator { return CountdownIterator(countdown: self.count) } } let countdown = Countdown(count: 5) for i in countdown { print(i) } /// 4 3 2 1 0 countdown.forEach { print($0) } // ⚠️： Sequence 並沒有保證 repeated access /// 4 3 2 1 0 這些步驟看起來異常繁瑣，我們可以利用 Swift 提供的 default implementation 減少 trivial part。若同時符合 Sequence 與 IteratorProtocol，只要實作 next方法，則 Sequence 會自動產生 makeIterator。\nstruct Countdown: Sequence, IteratorProtocol { var count: Int mutating func next() -\u003e Int? { guard count \u003e 0 else { return nil } count -= 1 return count } } // 可以透過 default implementation 直接使用 `map` 方法！ Countdown(count: 5).map { $0 * 5 } /// [20, 15, 10, 5, 0] Collection protocols Sequence protocol 僅提供迭代方法，並不能保證序列能否走訪多遍，也沒有提供 subscript（下標）。Collection protocol 提供 subscript 的容器介面，並建議實作 access elements 預期為 O(1) 複雜度。\n不過實際情況因實作而異，例如 Doubly linked-list 遵循繼承自 Collection 的 BidirectionalCollection protocol，卻無法如符合 RandomAccessCollection 的 Array 一樣有 O(1) 的隨機存取操作。\n這些 Collection protocols 加強了 Iterator pattern 應用面的生產力，演算法能以更豐富的方式呈現給使用者。好比 Swift Standard Library 中的 Array、Dictionary 和 String 也都是實作 Collection protocol 的案例，而這些的集合實作就非常夠開發者使用了，幾乎不需考慮底層的演算法，更甚不必接觸任何 Iterator。\nConclusion Iterator pattern 封裝了許多演算法，讓使用者能夠專注在更高層次的邏輯上；iterator pattern 同時也提供迭代完畢的訊息，許多程式間通訊得以透過 iterator 完成不同的任務。近來很流行的 generator／coroutine 都是建立於 iterator pattern 上，Rx 的設計理念也是吸收 iterator pattern 的精華，提供 Observable no data available 與 error 的重要特性。\nReference SwiftDoc.org Wiki: Iterator pattern ","wordCount":"1550","inLanguage":"en","datePublished":"2017-08-15T13:06:59+08:00","dateModified":"2017-08-15T13:06:59+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://weihanglo.tw/posts/2017/intro-rx-1-iterator-pattern/"},"publisher":{"@type":"Organization","name":"Life is a refactoring process without tests","logo":{"@type":"ImageObject","url":"https://weihanglo.tw/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://weihanglo.tw/ accesskey=h title="Life is a refactoring process without tests (Alt + H)">Life is a refactoring process without tests</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://weihanglo.tw/ title=Home><span>Home</span></a></li><li><a href=https://weihanglo.tw/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://weihanglo.tw/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://weihanglo.tw/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Rx 入門一：迭代器模式</h1><div class=post-meta><span title='2017-08-15 13:06:59 +0800 +0800'>August 15, 2017</span>&nbsp;·&nbsp;4 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#definition aria-label=Definition>Definition</a></li><li><a href=#application aria-label=Application>Application</a></li><li><a href=#requirements aria-label=Requirements>Requirements</a></li><li><a href=#iteratorprotocol--sequence aria-label="IteratorProtocol & Sequence">IteratorProtocol & Sequence</a></li><li><a href=#collection-protocols aria-label="Collection protocols">Collection protocols</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><p>本篇介紹 Rx 的重要基礎概念 <strong>Iterator pattern</strong>（迭代器模式）。</p><p><em>（撰於 2017-08-15，基於 Swift 3.1）</em></p><h2 id=definition>Definition<a hidden class=anchor aria-hidden=true href=#definition>#</a></h2><p><a href=https://en.wikipedia.org/wiki/Iterator_pattern>迭代器模式（Iterator pattern）</a> 提供一個迭代器，讓使用者透過特定方式走訪序列（sequence）中的元素，而不需知道底層的演算法。</p><h2 id=application>Application<a hidden class=anchor aria-hidden=true href=#application>#</a></h2><p>Iterator pattern 是最基本的設計模式之一，基本上大部分語言的 <code>for-in</code> loop 都是 iterator pattern 的實作。我們可以說 Python 的 <code>for x in iterable</code> 符合 iterator pattern，因為 Python 將該 <code>iterable</code> 封裝起來，使用者對 iterator 如何取得下一個 element 並不知情；Swift 的 <code>for x in Sequence</code> 中 <code>Sequence</code> protocol 也有 iterator 介面，並提供了 default implementation。</p><p>相反地， C 的 <code>for (int i = 0; i &lt; n; i++)</code> 通常不認為是 iterator pattern，因為使用者知道底層資料儲存在連續的記憶體空間中，也必須自行透過指針迭代。</p><p>透過 iterator 封裝的序列（或集合），讓調用者不需關係實作，只需使用統一的 for loop，或是 <code>map</code>、<code>reduce</code>、<code>filter</code> 等高階函數，即操作序列中的元素，完全與演算法解耦合。</p><h2 id=requirements>Requirements<a hidden class=anchor aria-hidden=true href=#requirements>#</a></h2><p>一般來說，要符合 iterator pattern 的實作，通常會有以下幾個介面：</p><ol><li>一個取得下一個 element 的方法，通常是 <code>next</code></li><li>告知使用者是否仍有下個 element 的方法，各語言有自己對應的實作，如：</li></ol><ul><li>拋出 Exception（Python）</li><li>主動 call <code>hasNext</code> 方法（Java）</li><li>回傳 flag 判斷迭代是否完成（JavaScript）</li><li>直接回傳 <code>nil</code>（Swift）</li></ul><h2 id=iteratorprotocol--sequence>IteratorProtocol & Sequence<a hidden class=anchor aria-hidden=true href=#iteratorprotocol--sequence>#</a></h2><p>在深入 iterator pattern 前，先來理解 Swift 最重要的兩個 protocol：<code>IteratorProtocol</code> 與 <code>Sequence</code>。</p><p>Swift 實作 iterator 須符合 <a href=http://swiftdoc.org/v3.1/protocol/IteratorProtocol/>IteratorProtocol</a>，該 protocol 要求一個 <code>next</code> method。雖然簡單，但要實作 iterator pattern 也是滿繁瑣的。我們直接看例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// 宣告一個 countdown 用的 iterator struct，每次迭代時會將當前計數減一。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CountdownIterator</span>: IteratorProtocol {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> count: Int
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>mutating</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>next</span>() -&gt; Int? {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>guard</span> count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>else</span> { <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> }
</span></span><span style=display:flex><span>        count <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> count
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其實這樣就做完我們的 iterator 了，我們可以嘗試使用 <code>while</code> loop 使用這個倒數計時器。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>var</span> it = CountdownIterator(count: <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> v = it.next() {
</span></span><span style=display:flex><span>  print(v)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/// 4 3 2 1 0</span>
</span></span></code></pre></div><p>不過通常我們會希望將 next 方法藏起來，利用簡單的 for-in loop 迭代，這時候就該 <a href=http://swiftdoc.org/v3.1/protocol/Sequence/>Sequence</a> protocol 出場。<strong>Sequence</strong> protocol 提供一個按序迭代的介面，讓調用者可好整以暇的使用。只要符合 <code>Comparable</code>、<code>Equatable</code> 等 protocol，Sequence 甚至提供許多方便的 default implementations。</p><p>一般來說，Sequence 需有 iterator 的 associatedType，以及 <code>makeIterator</code> 方法，提供 sequence 製造 iterator 的介面。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Countdown</span>: Sequence {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> count: Int
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeIterator</span>() -&gt; CountdownIterator {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> CountdownIterator(countdown: <span style=color:#66d9ef>self</span>.count)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> countdown = Countdown(count: <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> countdown {
</span></span><span style=display:flex><span>    print(i)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/// 4 3 2 1 0</span>
</span></span><span style=display:flex><span>countdown.forEach { print($0) } <span style=color:#75715e>// ⚠️： Sequence 並沒有保證 repeated access</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 4 3 2 1 0</span>
</span></span></code></pre></div><p>這些步驟看起來異常繁瑣，我們可以利用 Swift 提供的 default implementation 減少 trivial part。若同時符合 Sequence 與 IteratorProtocol，只要實作 <code>next</code>方法，則 Sequence 會自動產生 <code>makeIterator</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Countdown</span>: Sequence, IteratorProtocol {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> count: Int
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>mutating</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>next</span>() -&gt; Int? {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>guard</span> count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>else</span> { <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span> }
</span></span><span style=display:flex><span>        count <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> count
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 可以透過 default implementation 直接使用 `map` 方法！</span>
</span></span><span style=display:flex><span>Countdown(count: <span style=color:#ae81ff>5</span>).map { $0 <span style=color:#f92672>*</span> <span style=color:#ae81ff>5</span> }
</span></span><span style=display:flex><span><span style=color:#75715e>/// [20, 15, 10, 5, 0]</span>
</span></span></code></pre></div><h2 id=collection-protocols>Collection protocols<a hidden class=anchor aria-hidden=true href=#collection-protocols>#</a></h2><p>Sequence protocol 僅提供迭代方法，並不能保證序列能否走訪多遍，也沒有提供 subscript（下標）。<a href=http://swiftdoc.org/v3.1/protocol/Collection/>Collection</a> protocol 提供 subscript 的容器介面，並建議實作 access elements 預期為 O(1) 複雜度。<br>不過實際情況因實作而異，例如 Doubly linked-list 遵循繼承自 Collection 的 <a href=http://swiftdoc.org/nightly/protocol/BidirectionalCollection/>BidirectionalCollection </a>protocol，卻無法如符合 <a href=http://swiftdoc.org/nightly/protocol/RandomAccessCollection/>RandomAccessCollection</a> 的 Array 一樣有 O(1) 的隨機存取操作。</p><p>這些 Collection protocols 加強了 Iterator pattern 應用面的生產力，演算法能以更豐富的方式呈現給使用者。好比 Swift Standard Library 中的 Array、Dictionary 和 String 也都是實作 Collection protocol 的案例，而這些的集合實作就非常夠開發者使用了，幾乎不需考慮底層的演算法，更甚不必接觸任何 Iterator。</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Iterator pattern 封裝了許多演算法，讓使用者能夠專注在更高層次的邏輯上；iterator pattern 同時也提供迭代完畢的訊息，許多程式間通訊得以透過 iterator 完成不同的任務。近來很流行的 generator／coroutine 都是建立於 iterator pattern 上，Rx 的設計理念也是吸收 iterator pattern 的精華，提供 <code>Observable</code> <strong>no data available</strong> 與 <strong>error</strong> 的重要特性。</p><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><ul><li><a href=http://swiftdoc.org/>SwiftDoc.org</a></li><li><a href=https://en.wikipedia.org/wiki/Iterator_pattern>Wiki: Iterator pattern</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://weihanglo.tw/tags/design-patterns/>Design Patterns</a></li><li><a href=https://weihanglo.tw/tags/iterator-pattern/>Iterator Pattern</a></li><li><a href=https://weihanglo.tw/tags/swift/>Swift</a></li><li><a href=https://weihanglo.tw/tags/reactivex/>ReactiveX</a></li></ul><nav class=paginav><a class=prev href=https://weihanglo.tw/posts/2017/intro-rx-2-observer-pattern/><span class=title>« Prev</span><br><span>Rx 入門二：觀察者模式</span>
</a><a class=next href=https://weihanglo.tw/posts/2017/intro-rx-0-reactivex/><span class=title>Next »</span><br><span>Rx 入門零：ReactiveX</span></a></nav></footer></article></main><footer class=footer><span>CC BY-NC-SA 4.0</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>