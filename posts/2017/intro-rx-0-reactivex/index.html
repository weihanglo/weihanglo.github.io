<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rx 入門零：ReactiveX | Life is a refactoring process without tests</title>
<meta name=keywords content="ReactiveX,Design Patterns"><meta name=description content="聽過 Reactive Programming 嗎？ReactiveX（Rx）是近來火紅的技術，帶動函數響應式程式設計的熱潮。本系列將從 Rx 最原始的概念解釋起，一步步認識 Rx 巧妙的設計"><meta name=author content><link rel=canonical href=https://weihanglo.tw/posts/2017/intro-rx-0-reactivex/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://weihanglo.tw/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://weihanglo.tw/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://weihanglo.tw/favicon-32x32.png><link rel=apple-touch-icon href=https://weihanglo.tw/apple-touch-icon.png><link rel=mask-icon href=https://weihanglo.tw/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://weihanglo.tw/posts/2017/intro-rx-0-reactivex/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:title" content="Rx 入門零：ReactiveX"><meta property="og:description" content="聽過 Reactive Programming 嗎？ReactiveX（Rx）是近來火紅的技術，帶動函數響應式程式設計的熱潮。本系列將從 Rx 最原始的概念解釋起，一步步認識 Rx 巧妙的設計"><meta property="og:type" content="article"><meta property="og:url" content="https://weihanglo.tw/posts/2017/intro-rx-0-reactivex/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-08-15T09:22:37+08:00"><meta property="article:modified_time" content="2017-08-15T09:22:37+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rx 入門零：ReactiveX"><meta name=twitter:description content="聽過 Reactive Programming 嗎？ReactiveX（Rx）是近來火紅的技術，帶動函數響應式程式設計的熱潮。本系列將從 Rx 最原始的概念解釋起，一步步認識 Rx 巧妙的設計"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://weihanglo.tw/posts/"},{"@type":"ListItem","position":2,"name":"Rx 入門零：ReactiveX","item":"https://weihanglo.tw/posts/2017/intro-rx-0-reactivex/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rx 入門零：ReactiveX","name":"Rx 入門零：ReactiveX","description":"聽過 Reactive Programming 嗎？ReactiveX（Rx）是近來火紅的技術，帶動函數響應式程式設計的熱潮。本系列將從 Rx 最原始的概念解釋起，一步步認識 Rx 巧妙的設計","keywords":["ReactiveX","Design Patterns"],"articleBody":" 聽過 Reactive Programming 嗎？ReactiveX（Rx）是近來火紅的技術，帶動函數響應式程式設計的熱潮。本系列將從 Rx 最原始的概念解釋起，一步步認識 Rx 巧妙的設計理念。期盼讀完後，人人心中都能有 Reactive 的思維！\n（撰於 2017-08-15）\nWhy use Rx 狂熱驅動開發（Hype Driven Development） 是當前軟體工程界的奇特現象，每當一個新概念新技術出來，不乏有人大力吹捧。這次，小弟同樣被狂熱驅動，要來吹捧 ReactiveX（Rx）的設計理念，但在開始推坑之前，我們仍須問自己：「為什麼要用 Rx？Rx 想解決什麼問題？ 」知道一個技術的應用範圍，遠比只會拿著新玩具揮舞來得重要。\nAsynchronous: unified asynchronous APIs 時至今日，軟體工程越來越複雜，無論前端或後端工程、大量的非同步（asynchronous）操作散落於程式各處，各種不同的非同步 API 如 Promise、async／await、callback function 混雜在一起，讓開發一個穩定的非同步程式變得難上加難。若考慮例外捕捉／處理，非同步的程式就會更加複雜了。\n如果採用的 Rx，一切的資料或事件都會轉換為 Observable，透過 Observable，就可以在統一的 API 操作非同步的程式了。這就是 ReactiveX 的核心價值：An API for asynchronous programming with observable streams。\nDeclarative: better coding style Rx 除了統一非同步程式的 API 之外，另外一大特色即是採用聲明式程式設計典範（Declarative Programming Paradigm），相較於傳統命令式設計（Imperative Programming），聲明式的程式設計更能專注於程式要做什麼（What to do），而非命令程式語言該怎麼做（How to do），也減少了許多人為因素的錯誤（例如忘記調用 update 導致頁面未更新）。\n就拿網頁前端工程最熱門的兩大框架 ReactJS 與 VueJS 來說，都是 Declarative 的最佳實踐案例，也帶動整個軟體工程界對 Declarative 與 Imperative 程式設計的比較與反思。\nUbiquitous: exists in major programming languages Rx 並不是某個語言的函式庫，Rx 本質上是一個程式設計的思想，有人稱他為 Reactive Programming，有人覺得 Rx 有函數式程式設計的味道，應該稱為 Functional Reactive Programming，我們姑且就稱他為 Rx。正因為 Rx 沒有語言上的限制，幾乎所有主流語言都有對應的實作，例如：\nRxJava 與他的夥伴 RxAndroid 以 TypeScript 開發的 RxJS 5 與舊版的 RxJS RxSwift 以及早期非常熱門的 ReactiveCocoa 其他諸如 Python、Ruby、C#、Kotlin、Go 等，族繁不及備載。 除了語言上沒有限制，從 backend 到 frontend，都可以是 Rx 的應用場景，是個名副其實的 fundamental library。\nPromising: more and more usage ReactiveX 早先是由 Microsoft 開發的開源專案，越來越多語言支持後，也越來越多大型公司開始採用與開發，例如 RxJava 最早就是 Netflix 的開源專案，Google 的 Angular 也大量使用 RxJS。知名募資網站 Kickstarter 在其開源 App 專案中也廣用 ReactiveX 技術。其他諸如 Airbnb、Github、Trello 都有導入 Rx 的技術。再者，Observable 的提案已經進入 Stage 1，我相信 Observable 終將納入 ECMAScript 標準中。\n事實上，小弟並不擔心 Rx 這門技術走向盡頭與否，因為 Rx 是程式思維，而非單一函式庫，了解不同的寫作範式，對程式設計絕對有莫大幫助。\nUnder the hood Rx 揉合了許多程式設計思想，使得很多想法變得可能，例如：\n統一同步非同步操作的例外／錯誤處理（unify exception handling） 事件、資料都以資料流（data stream）呈現，讓不同的來源可被重新組合（composable） 捨棄 stateful 的狀態管理，一切都是資料流（less statefull） Rx 能實現這些想法，主要歸功於以下三個重要的核心概念：\nObserver pattern Iterator pattern Functional programming Observer pattern 替 Rx 提供了 Reactive programming 的基礎，監聽資料流的變化，推送給訂閱者。\nIterator pattern 則替 Observer pattern 加上兩個不可或缺的特性，\n可通知訂閱者資料流已達末端，沒有資料了。 可通知訂閱者有錯誤發生。 這兩特性打造 Rx 最重要的概念「Observable」，Observable 類似一般的 Iterable，唯一的差異就是資料的流向，傳統 Iterable 是將資料 pull 下來，而 Observable 則是將資料 push 給訂閱者。除此之外，任何 Iterable 上的操作，都可以在 Observable 上操作。\n最後，借助 Functional Programming 的典範，Rx 多樣化的 operators 就好比數學上的函式，可任意組合、轉換與重用相同的 data stream，並利用 operator chaining 串連所有的運算，讓程式邏輯不用再充斥著 temporary variable。\nConclusion 本篇主要介紹 Rx 欲解決的問題域，並理解 Rx 三大核心概念。之後，我們會利用幾個篇幅，簡單介紹 Iterator Pattern、Observer Pattern，以及 Functional Programming。\n","wordCount":"1749","inLanguage":"en","datePublished":"2017-08-15T09:22:37+08:00","dateModified":"2017-08-15T09:22:37+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://weihanglo.tw/posts/2017/intro-rx-0-reactivex/"},"publisher":{"@type":"Organization","name":"Life is a refactoring process without tests","logo":{"@type":"ImageObject","url":"https://weihanglo.tw/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://weihanglo.tw/ accesskey=h title="Life is a refactoring process without tests (Alt + H)">Life is a refactoring process without tests</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://weihanglo.tw/ title=Home><span>Home</span></a></li><li><a href=https://weihanglo.tw/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://weihanglo.tw/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://weihanglo.tw/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Rx 入門零：ReactiveX</h1><div class=post-meta><span title='2017-08-15 09:22:37 +0800 +0800'>August 15, 2017</span>&nbsp;·&nbsp;4 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#why-use-rx aria-label="Why use Rx">Why use Rx</a><ul><li><a href=#asynchronous-unified-asynchronous-apis aria-label="Asynchronous: unified asynchronous APIs">Asynchronous: unified asynchronous APIs</a></li><li><a href=#declarative-better-coding-style aria-label="Declarative: better coding style">Declarative: better coding style</a></li><li><a href=#ubiquitous-exists-in-major-programming-languages aria-label="Ubiquitous: exists in major programming languages">Ubiquitous: exists in major programming languages</a></li><li><a href=#promising-more-and-more-usage aria-label="Promising: more and more usage">Promising: more and more usage</a></li></ul></li><li><a href=#under-the-hood aria-label="Under the hood">Under the hood</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><p><img loading=lazy src=https://i.imgur.com/2oGARle.png alt></p><p>聽過 Reactive Programming 嗎？ReactiveX（Rx）是近來火紅的技術，帶動函數響應式程式設計的熱潮。本系列將從 Rx 最原始的概念解釋起，一步步認識 Rx 巧妙的設計理念。期盼讀完後，人人心中都能有 Reactive 的思維！</p><p><em>（撰於 2017-08-15）</em></p><h2 id=why-use-rx>Why use Rx<a hidden class=anchor aria-hidden=true href=#why-use-rx>#</a></h2><p><a href=https://blog.daftcode.pl/hype-driven-development-3469fc2e9b22>狂熱驅動開發（Hype Driven Development）</a> 是當前軟體工程界的奇特現象，每當一個新概念新技術出來，不乏有人大力吹捧。這次，小弟同樣被狂熱驅動，要來吹捧 <a href=reactivex.io>ReactiveX（Rx）</a>的設計理念，但在開始推坑之前，我們仍須問自己：「為什麼要用 Rx？Rx 想解決什麼問題？ 」知道一個技術的應用範圍，遠比只會拿著新玩具揮舞來得重要。</p><h3 id=asynchronous-unified-asynchronous-apis>Asynchronous: unified asynchronous APIs<a hidden class=anchor aria-hidden=true href=#asynchronous-unified-asynchronous-apis>#</a></h3><p>時至今日，軟體工程越來越複雜，無論前端或後端工程、大量的非同步（asynchronous）操作散落於程式各處，各種不同的非同步 API 如 Promise、async／await、callback function 混雜在一起，讓開發一個穩定的非同步程式變得難上加難。若考慮例外捕捉／處理，非同步的程式就會更加複雜了。</p><p>如果採用的 Rx，一切的資料或事件都會轉換為 <strong>Observable</strong>，透過 Observable，就可以在<strong>統一的 API 操作非同步的程式了</strong>。這就是 ReactiveX 的核心價值：<strong>An API for asynchronous programming with observable streams</strong>。</p><h3 id=declarative-better-coding-style>Declarative: better coding style<a hidden class=anchor aria-hidden=true href=#declarative-better-coding-style>#</a></h3><p>Rx 除了統一非同步程式的 API 之外，另外一大特色即是採用<a href=https://en.wikipedia.org/wiki/Declarative_programming>聲明式程式設計典範（Declarative Programming Paradigm）</a>，相較於傳統<a href=https://en.wikipedia.org/wiki/Imperative_programming>命令式設計（Imperative Programming）</a>，聲明式的程式設計更能專注於程式<strong>要做什麼</strong>（What to do），而非命令程式語言<strong>該怎麼做</strong>（How to do），也減少了許多人為因素的錯誤（例如忘記調用 <code>update</code> 導致頁面未更新）。</p><p>就拿網頁前端工程最熱門的兩大框架 <a href=https://facebook.github.io/react/>ReactJS</a> 與 <a href=https://vuejs.org/>VueJS</a> 來說，都是 Declarative 的最佳實踐案例，也帶動整個軟體工程界對 Declarative 與 Imperative 程式設計的比較與反思。</p><h3 id=ubiquitous-exists-in-major-programming-languages>Ubiquitous: exists in major programming languages<a hidden class=anchor aria-hidden=true href=#ubiquitous-exists-in-major-programming-languages>#</a></h3><p>Rx 並不是某個語言的函式庫，Rx 本質上是一個程式設計的思想，有人稱他為 <a href=https://en.wikipedia.org/wiki/Reactive_programming>Reactive Programming</a>，有人覺得 Rx 有函數式程式設計的味道，應該稱為 <a href=https://en.wikipedia.org/wiki/Functional_reactive_programming>Functional Reactive Programming</a>，我們姑且就稱他為 Rx。正因為 Rx 沒有語言上的限制，幾乎所有主流語言都有對應的實作，例如：</p><ul><li><a href=https://github.com/ReactiveX/RxJava>RxJava</a> <img loading=lazy src="https://img.shields.io/github/stars/reactivex/rxjava.svg?style=social&amp;label=Star" alt>
與他的夥伴 <a href=https://github.com/ReactiveX/RxAndroid>RxAndroid</a> <img loading=lazy src="https://img.shields.io/github/stars/reactivex/rxandroid.svg?style=social&amp;label=Star" alt></li><li>以 TypeScript 開發的 <a href=https://github.com/ReactiveX/RxJS>RxJS 5</a> <img loading=lazy src="https://img.shields.io/github/stars/reactivex/rxjs.svg?style=social&amp;label=Star" alt>
與舊版的 <a href=https://github.com/Reactive-Extensions/RxJS>RxJS</a> <img loading=lazy src="https://img.shields.io/github/stars/reactive-extensions/rxjs.svg?style=social&amp;label=Star" alt></li><li><a href=https://github.com/ReactiveX/RxSwift>RxSwift</a> <img loading=lazy src="https://img.shields.io/github/stars/reactivex/rxswift.svg?style=social&amp;label=Star" alt>
以及早期非常熱門的 <a href=https://github.com/ReactiveCocoa/ReactiveCocoa>ReactiveCocoa</a> <img loading=lazy src="https://img.shields.io/github/stars/ReactiveCocoa/ReactiveCocoa.svg?style=social&amp;label=Star" alt></li><li>其他諸如 Python、Ruby、C#、Kotlin、Go 等，族繁不及備載。</li></ul><p>除了語言上沒有限制，從 backend 到 frontend，都可以是 Rx 的應用場景，是個名副其實的 fundamental library。</p><h3 id=promising-more-and-more-usage>Promising: more and more usage<a hidden class=anchor aria-hidden=true href=#promising-more-and-more-usage>#</a></h3><p>ReactiveX 早先是由 Microsoft 開發的開源專案，越來越多語言支持後，也越來越多大型公司開始採用與開發，例如 RxJava 最早就是 <a href=https://www.slideshare.net/InfoQ/functional-reactive-programming-in-the-netflix-api>Netflix 的開源專案</a>，Google 的 <a href=https://angular.io>Angular</a> 也大量使用 RxJS。知名募資網站 Kickstarter 在其<a href=https://github.com/kickstarter>開源 App 專案</a>中也廣用 ReactiveX 技術。其他諸如 Airbnb、Github、Trello 都有導入 Rx 的技術。再者，<a href=https://tc39.github.io/proposal-observable/>Observable 的提案已經進入 Stage 1</a>，我相信 Observable 終將納入 ECMAScript 標準中。</p><p>事實上，小弟並不擔心 Rx 這門技術走向盡頭與否，因為 Rx 是程式思維，而非單一函式庫，了解不同的寫作範式，對程式設計絕對有莫大幫助。</p><h2 id=under-the-hood>Under the hood<a hidden class=anchor aria-hidden=true href=#under-the-hood>#</a></h2><p>Rx 揉合了許多程式設計思想，使得很多想法變得可能，例如：</p><ul><li>統一同步非同步操作的例外／錯誤處理（unify exception handling）</li><li>事件、資料都以資料流（data stream）呈現，讓不同的來源可被重新組合（composable）</li><li>捨棄 stateful 的狀態管理，一切都是資料流（less statefull）</li></ul><p>Rx 能實現這些想法，主要歸功於以下三個重要的核心概念：</p><ul><li><a href=https://en.wikipedia.org/wiki/Observer_pattern>Observer pattern</a></li><li><a href=https://en.wikipedia.org/wiki/Iterator_pattern>Iterator pattern</a></li><li><a href=https://en.wikipedia.org/wiki/Functional_programming>Functional programming</a></li></ul><p><strong>Observer pattern</strong> 替 Rx 提供了 Reactive programming 的基礎，監聽資料流的變化，推送給訂閱者。</p><p><strong>Iterator pattern</strong> 則替 Observer pattern 加上兩個不可或缺的特性，</p><ul><li>可通知訂閱者資料流已達末端，沒有資料了。</li><li>可通知訂閱者有錯誤發生。</li></ul><p>這兩特性打造 Rx 最重要的概念「<strong>Observable</strong>」，Observable 類似一般的 <strong>Iterable</strong>，唯一的差異就是資料的流向，傳統 Iterable 是將資料 <strong>pull</strong> 下來，而 Observable 則是將資料 <strong>push</strong> 給訂閱者。除此之外，<strong>任何 Iterable 上的操作，都可以在 Observable 上操作</strong>。</p><p>最後，借助 <strong>Functional Programming</strong> 的典範，Rx 多樣化的 operators 就好比數學上的函式，可任意組合、轉換與重用相同的 data stream，並利用 operator chaining 串連所有的運算，讓程式邏輯不用再充斥著 temporary variable。</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>本篇主要介紹 Rx 欲解決的問題域，並理解 Rx 三大核心概念。之後，我們會利用幾個篇幅，簡單介紹 Iterator Pattern、Observer Pattern，以及 Functional Programming。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://weihanglo.tw/tags/reactivex/>ReactiveX</a></li><li><a href=https://weihanglo.tw/tags/design-patterns/>Design Patterns</a></li></ul><nav class=paginav><a class=prev href=https://weihanglo.tw/posts/2017/intro-rx-1-iterator-pattern/><span class=title>« Prev</span><br><span>Rx 入門一：迭代器模式</span>
</a><a class=next href=https://weihanglo.tw/posts/2017/thoughts-on-react-native-from-an-ios-developer/><span class=title>Next »</span><br><span>Thoughts on React Native from an iOS developer</span></a></nav></footer></article></main><footer class=footer><span>CC BY-NC-SA 4.0</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>