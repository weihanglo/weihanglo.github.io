<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rx 入門二：觀察者模式 | Life is a refactoring process without tests</title>
<meta name=keywords content="Design Patterns,Observer Pattern,Swift,ReactiveX"><meta name=description content="本篇介紹 Rx 另一個重要的基礎概念 Observer pattern（觀察者模式）。 （撰於 2017-08-15，基於 Swift 3.1） Definition 觀察者模式（Observer pat"><meta name=author content><link rel=canonical href=https://weihanglo.tw/posts/2017/intro-rx-2-observer-pattern/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://weihanglo.tw/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://weihanglo.tw/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://weihanglo.tw/favicon-32x32.png><link rel=apple-touch-icon href=https://weihanglo.tw/apple-touch-icon.png><link rel=mask-icon href=https://weihanglo.tw/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://weihanglo.tw/posts/2017/intro-rx-2-observer-pattern/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:title" content="Rx 入門二：觀察者模式"><meta property="og:description" content="本篇介紹 Rx 另一個重要的基礎概念 Observer pattern（觀察者模式）。 （撰於 2017-08-15，基於 Swift 3.1） Definition 觀察者模式（Observer pat"><meta property="og:type" content="article"><meta property="og:url" content="https://weihanglo.tw/posts/2017/intro-rx-2-observer-pattern/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-08-15T16:32:39+08:00"><meta property="article:modified_time" content="2017-08-15T16:32:39+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rx 入門二：觀察者模式"><meta name=twitter:description content="本篇介紹 Rx 另一個重要的基礎概念 Observer pattern（觀察者模式）。 （撰於 2017-08-15，基於 Swift 3.1） Definition 觀察者模式（Observer pat"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://weihanglo.tw/posts/"},{"@type":"ListItem","position":2,"name":"Rx 入門二：觀察者模式","item":"https://weihanglo.tw/posts/2017/intro-rx-2-observer-pattern/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rx 入門二：觀察者模式","name":"Rx 入門二：觀察者模式","description":"本篇介紹 Rx 另一個重要的基礎概念 Observer pattern（觀察者模式）。 （撰於 2017-08-15，基於 Swift 3.1） Definition 觀察者模式（Observer pat","keywords":["Design Patterns","Observer Pattern","Swift","ReactiveX"],"articleBody":"本篇介紹 Rx 另一個重要的基礎概念 Observer pattern（觀察者模式）。\n（撰於 2017-08-15，基於 Swift 3.1）\nDefinition 觀察者模式（Observer pattern）定義出一對多的相依關係，一個目標物件（subject）負責管理所有相依的觀察者（observer），「當 subject 自身的狀態發生變化時，自動通知所有觀察者」。\nApplication Observer pattern 是一個非常泛用的設計模式，幾乎各種語言都有類似的設計。例 DOM Event 架構利用 dispatchEvent 及 EventListener 達成 observer pattern。Cocoa programming 有著名的 Key-Value Observing 來觀察物件上特定 key 的 value 變化。\nPros and Cons Pros 只要介面符合，任何物件都可以是 Observer。 可確認該狀態變化是由該 subject 通知，有較高的控制權。 熱門且容易理解的設計模式。 Cons Subject 和 Observer 通常必須知道彼此之間的部分屬性，有較緊的耦合性。 Subject 管理所有 observer，容易因 reference cycle 產生 memory leak。 部份實作並無法保證不同的 observer 接收到通知的時間順序。 承上，因此 thread-safe 與 asynchronous 的 observer pattern 不容易實作。 First attempt Swift 中實作 observer pattern 非常容易，除了透過 Objective-C 傳統的 Key-value observing 以外，直觀的 Property Observer 是最好的實作方式了。以下示範 property observer 實作 observer pattern。\n不示範 KVO 是因為 Swift 4 KVC 又大改了！這次 keyPath 不再是易出錯的 string，改為實實在在的 KeyPath 型別，期待一下吧。\n首先，我們先建立一個 protocol，裡面有幾個 requirements，willChange、didChange 會在 subject 狀態變更時調用。由於需要獨立辨識每個的 observer，所以會是一個 class-only protocol，才能透過 === identity operator 比較 reference。\n// 建立一個 protocol 給 observer 實作，subject 會呼叫 protocol PropertyObserver: AnyObject { // class-only func willChange(to newValue: Any?) func didChange(from oldValue: Any?) } 再來，我們建立 Subject 型別，裡面有\nobservers array，管理所有觀察者（需注意 memory leak，必要時可利用 weak reference wrapper）。 一個用來示範的 name property，實作 willSet、didSet 兩個 property observer，裡面分別調用 PropertyObserver 的 willChange 與 didChange 方法。 add 與 remove 兩個對應的新增／移除 observer 的方法。 struct Subject { // 建立一個 observers array private var observers: [PropertyObserver] = [] // 利用 Swift 自帶的 property observer，通知每個 observer var name: String = \"empty\" { willSet { observers.forEach { $0.willChange(to: newValue) } } didSet { observers.forEach { $0.didChange(from: oldValue) } } } // 新增 observer mutating func add(observer: PropertyObserver) { observers.append(observer) } // 移除 observer mutating func remove(observer: PropertyObserver) { observers = observers.filter { $0 !== observer } } } 最後，我們實作 Observer。\nclass Observer: PropertyObserver { let name: String // Demo 用 init(name: string) { self.name = name } func willChange(to newValue: Any?) { print(\"\\(name) will change to \\(newValue ?? \"nil\").\") } func didChange(from oldValue: Any?) { print(\"\\(name) did change from \\(oldValue ?? \"nil\").\") } } 測試看看吧！\nvar subject = Subject() var observerA = Observer(name: \"A\") var observerB = Observer(name: \"B\") subject.add(observer: observerA) subject.add(observer: observerB) subject.name = \"1234\" print(\"---------- Remove observerA ----------\") subject.remove(observer: observerA) subject.name = \"4321\" /// A will change to 1234. /// B will change to 1234. /// A did change from empty. /// B did change from empty. /// ---------- Remove observerA ---------- /// B will change to 4321. /// B did change from 1234. 以上的是非常簡單的 Observer pattern 實作，但也有許多缺陷，例如：\n不易指定 property，互相都需要了解內部屬性。 僅能從 Subject 移除 observer，observer 無法主動停止觀察。 一定要建立完整的 Observer，才能觀察變化。 Second attempt 根據上述缺點，我們可以從幾個面向加強：\nSubject 的 observer 可以是 closure，解耦 willChange 與 didChange。 Subject.add 之後可回傳一個 Disposable 的物件，讓觀察者可以透過這個物件停止觀察。 首先，建立一個新的 Disposable protocol，包含 dispose method，可以自行停止觀察。\nprotocol Disposable { func dispose() } 再來是新的 Subject，這邊比較多繁瑣的實作細節，主要實作：\nobservers 改成兩個 willChangeObservers、didChangeObservers array，分別存放不同的觀察者。 Observer 的型別改為 closure，讓調用者更易於使用。 observe 要傳入欲觀察的對應 ObservationType。 class Subject { enum ObservationType { case willChange case didChange } typealias Observation = Int typealias Observer = (Any?) -\u003e Void private static var id = 0 private var willChangeObservers: [(Observation, Observer)] = [] private var didChangeObservers: [(Observation, Observer)] = [] var name: String = \"empty\" { willSet { willChangeObservers.forEach { $0.1(newValue) } } didSet { didChangeObservers.forEach { $0.1(oldValue) } } } func observe(type: ObservationType, with closure: @escaping Observer) -\u003e ClosureDisposable { Subject.id += 1 switch type { case .willChange: willChangeObservers.append((Subject.id, closure)) case .didChange: didChangeObservers.append((Subject.id, closure)) } return ClosureDisposable(owner: self, id: Subject.id, type: type) } func remove(observer: ClosureDisposable) { switch observer.type { case .willChange: if let index = willChangeObservers.index(where: { $0.0 == observer.id }) { willChangeObservers.remove(at: index) } case .didChange: if let index = didChangeObservers.index(where: { $0.0 == observer.id }) { didChangeObservers.remove(at: index) } } } } 這裡實作前面的 Disposable，為了符合 Subject 的需求，我們暴露 Observation 與 ObservationType 給 ClosureDisposable。\n實務上，可再訂定更詳細的泛型，或直接將 Disposable 的實際型別定義在 Subject 的 nested class。\nclass ClosureDisposable: Disposable { private(set) weak var owner: Subject? let id: Subject.Observation let type: Subject.ObservationType init(owner: Subject, id: Subject.Observation, type: Subject.ObservationType) { self.owner = owner self.id = id self.type = type } func dispose() { owner?.remove(observer: self) } } 最後，讓我們來看看結果吧！\nvar subject = Subject() let observerA = subject.observe(type: .willChange) { val in print(\"A will change to \\(val ?? \"\")\") } let observerB = subject.observe(type: .willChange) { val in print(\"B will change to \\(val ?? \"\")\") } let observerC = subject.observe(type: .didChange) { val in print(\"C did change to \\(val ?? \"\")\") } subject.name = \"1234\" print(\"---------- Remove observerB \u0026 C ----------\") // subject 移除觀察 subject.remove(observer: observerB) // Observer 使用 dispose 主動停止觀察 observerC.dispose() subject.name = \"4321\" /// A will change to 1234 /// B will change to 1234 /// C did change to empty /// ---------- Remove observerB \u0026 C ---------- /// A will change to 4321 這是我們的第二次嘗試，雖然仍有 ClosureDisposable 與 Subject 耦合性的問題，也暴露太多類別的細節。不過對比第一次，對外接口使用 closure 來綁定 subject，勉強稱得上乾淨利落。\nPub-sub pattern 一些狀況下，若需要完全解耦合，或許 Pub-sub pattern 會比 observer pattern 更適合。\nPub-sub pattern（Publish-subscribe，訂閱／發佈模式）是一種訊息傳遞設計模式，概念是利用中介 message 做為 publisher（對應 subject）及 subscriber（對應 observer）的溝通橋樑，subscriber 只需訂閱特定 message，而 publisher 則僅負責發佈（broadcast）message。兩者耦合性低，可作為 observer pattern 替代品，但程式也容易變得更複雜。\n實務上，Cocoa 的 NSNotification 是徹底實踐 pub-sub pattern 的範例；以高效著稱的 in-memory database Redis 也有強大的 Pub／Sub 功能。此外，Modern web app 的狀態管理架構兩大陣營 Redux 與 MobX，也可以視為 pub-sub pattern 與 observer pattern 的對抗。\nConclusion Swift 的 Property observer 讓實作 observer 的門檻降低了，很多有趣的實現，例如 Cocoa Bindings，在 iOS 上變得更簡潔更 Swifty。了解 observer pattern 與組件間的通訊運作原理，勢必能夠帶來更多不同的設計架構，Rx 就是如此孕育而生。\nReference Wiki: Observer pattern Wiki: Publish-subscribe pattern ","wordCount":"2254","inLanguage":"en","datePublished":"2017-08-15T16:32:39+08:00","dateModified":"2017-08-15T16:32:39+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://weihanglo.tw/posts/2017/intro-rx-2-observer-pattern/"},"publisher":{"@type":"Organization","name":"Life is a refactoring process without tests","logo":{"@type":"ImageObject","url":"https://weihanglo.tw/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://weihanglo.tw/ accesskey=h title="Life is a refactoring process without tests (Alt + H)">Life is a refactoring process without tests</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://weihanglo.tw/ title=Home><span>Home</span></a></li><li><a href=https://weihanglo.tw/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://weihanglo.tw/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://weihanglo.tw/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Rx 入門二：觀察者模式</h1><div class=post-meta><span title='2017-08-15 16:32:39 +0800 +0800'>August 15, 2017</span>&nbsp;·&nbsp;5 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#definition aria-label=Definition>Definition</a></li><li><a href=#application aria-label=Application>Application</a></li><li><a href=#pros-and-cons aria-label="Pros and Cons">Pros and Cons</a></li><li><a href=#first-attempt aria-label="First attempt">First attempt</a></li><li><a href=#second-attempt aria-label="Second attempt">Second attempt</a></li><li><a href=#pub-sub-pattern aria-label="Pub-sub pattern">Pub-sub pattern</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div><div class=post-content><p>本篇介紹 Rx 另一個重要的基礎概念 <strong>Observer pattern</strong>（觀察者模式）。</p><p><em>（撰於 2017-08-15，基於 Swift 3.1）</em></p><h2 id=definition>Definition<a hidden class=anchor aria-hidden=true href=#definition>#</a></h2><p><a href=https://en.wikipedia.org/wiki/Observer_pattern>觀察者模式（Observer pattern）</a>定義出一對多的相依關係，一個目標物件（subject）負責管理所有相依的觀察者（observer），「當 subject 自身的狀態發生變化時，自動通知所有觀察者」。</p><h2 id=application>Application<a hidden class=anchor aria-hidden=true href=#application>#</a></h2><p>Observer pattern 是一個非常泛用的設計模式，幾乎各種語言都有類似的設計。例 DOM Event 架構利用 <code>dispatchEvent</code> 及 <code>EventListener</code> 達成 observer pattern。Cocoa programming 有著名的 <a href=https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html>Key-Value Observing</a> 來觀察物件上特定 key 的 value 變化。</p><h2 id=pros-and-cons>Pros and Cons<a hidden class=anchor aria-hidden=true href=#pros-and-cons>#</a></h2><ul><li>Pros<ul><li>只要介面符合，任何物件都可以是 Observer。</li><li>可確認該狀態變化是由該 subject 通知，有較高的控制權。</li><li>熱門且容易理解的設計模式。</li></ul></li><li>Cons<ul><li>Subject 和 Observer 通常必須知道彼此之間的部分屬性，有較緊的耦合性。</li><li>Subject 管理所有 observer，容易因 reference cycle 產生 memory leak。</li><li>部份實作並無法保證不同的 observer 接收到通知的時間順序。</li><li>承上，因此 thread-safe 與 asynchronous 的 observer pattern 不容易實作。</li></ul></li></ul><h2 id=first-attempt>First attempt<a hidden class=anchor aria-hidden=true href=#first-attempt>#</a></h2><p>Swift 中實作 observer pattern 非常容易，除了透過 Objective-C 傳統的 Key-value observing 以外，直觀的 <strong>Property Observer</strong> 是最好的實作方式了。以下示範 property observer 實作 observer pattern。</p><blockquote><p>不示範 KVO 是因為 <a href=https://github.com/apple/swift-evolution/blob/master/proposals/0161-key-paths.md>Swift 4 KVC 又大改了</a>！這次 keyPath 不再是易出錯的 string，改為實實在在的 KeyPath 型別，期待一下吧。</p></blockquote><p>首先，我們先建立一個 protocol，裡面有幾個 requirements，<code>willChange</code>、<code>didChange</code> 會在 subject 狀態變更時調用。由於需要獨立辨識每個的 observer，所以會是一個 class-only protocol，才能透過 <code>===</code> identity operator 比較 reference。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#75715e>// 建立一個 protocol 給 observer 實作，subject 會呼叫</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protocol</span> <span style=color:#a6e22e>PropertyObserver</span>: AnyObject { <span style=color:#75715e>// class-only</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>willChange</span>(to newValue: Any?)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>didChange</span>(from oldValue: Any?)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>再來，我們建立 <code>Subject</code> 型別，裡面有</p><ul><li><code>observers</code> array，管理所有觀察者（需注意 memory leak，必要時可利用 weak reference wrapper）。</li><li>一個用來示範的 <code>name</code> property，實作 <code>willSet</code>、<code>didSet</code> 兩個 property observer，裡面分別調用 <code>PropertyObserver</code> 的 <code>willChange</code> 與 <code>didChange</code> 方法。</li><li><code>add</code> 與 <code>remove</code> 兩個對應的新增／移除 observer 的方法。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Subject</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 建立一個 observers array</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> observers: [PropertyObserver] = []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 利用 Swift 自帶的 property observer，通知每個 observer</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> name: String = <span style=color:#e6db74>&#34;empty&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>willSet</span> {
</span></span><span style=display:flex><span>      observers.forEach { $0.willChange(to: newValue) }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>didSet</span> {
</span></span><span style=display:flex><span>      observers.forEach { $0.didChange(from: oldValue) }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 新增 observer</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>mutating</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>add</span>(observer: PropertyObserver) {
</span></span><span style=display:flex><span>    observers.append(observer)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 移除 observer</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>mutating</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>remove</span>(observer: PropertyObserver) {
</span></span><span style=display:flex><span>    observers = observers.filter { $0 <span style=color:#f92672>!==</span> observer }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>最後，我們實作 <code>Observer</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Observer</span>: PropertyObserver {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> name: String <span style=color:#75715e>// Demo 用</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>init</span>(name: string) { <span style=color:#66d9ef>self</span>.name = name }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>willChange</span>(to newValue: Any?) {
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\(</span>name<span style=color:#e6db74>)</span><span style=color:#e6db74> will change to </span><span style=color:#e6db74>\(</span>newValue ?? <span style=color:#e6db74>&#34;nil&#34;</span><span style=color:#e6db74>)</span><span style=color:#e6db74>.&#34;</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>didChange</span>(from oldValue: Any?) {
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\(</span>name<span style=color:#e6db74>)</span><span style=color:#e6db74> did change from </span><span style=color:#e6db74>\(</span>oldValue ?? <span style=color:#e6db74>&#34;nil&#34;</span><span style=color:#e6db74>)</span><span style=color:#e6db74>.&#34;</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>測試看看吧！</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>var</span> subject = Subject()
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> observerA = Observer(name: <span style=color:#e6db74>&#34;A&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> observerB = Observer(name: <span style=color:#e6db74>&#34;B&#34;</span>)
</span></span><span style=display:flex><span>subject.add(observer: observerA)
</span></span><span style=display:flex><span>subject.add(observer: observerB)
</span></span><span style=display:flex><span>subject.name = <span style=color:#e6db74>&#34;1234&#34;</span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;---------- Remove observerA ----------&#34;</span>)
</span></span><span style=display:flex><span>subject.remove(observer: observerA)
</span></span><span style=display:flex><span>subject.name = <span style=color:#e6db74>&#34;4321&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// A will change to 1234.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// B will change to 1234.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// A did change from empty.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// B did change from empty.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// ---------- Remove observerA ----------</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// B will change to 4321.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// B did change from 1234.</span>
</span></span></code></pre></div><p>以上的是非常簡單的 Observer pattern 實作，但也有許多缺陷，例如：</p><ul><li>不易指定 property，互相都需要了解內部屬性。</li><li>僅能從 Subject 移除 observer，observer 無法主動停止觀察。</li><li>一定要建立完整的 Observer，才能觀察變化。</li></ul><h2 id=second-attempt>Second attempt<a hidden class=anchor aria-hidden=true href=#second-attempt>#</a></h2><p>根據上述缺點，我們可以從幾個面向加強：</p><ul><li>Subject 的 observer 可以是 closure，解耦 <code>willChange</code> 與 <code>didChange</code>。</li><li><code>Subject.add</code> 之後可回傳一個 <code>Disposable</code> 的物件，讓觀察者可以透過這個物件停止觀察。</li></ul><p>首先，建立一個新的 <code>Disposable</code> protocol，包含 <code>dispose</code> method，可以自行停止觀察。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>protocol</span> <span style=color:#a6e22e>Disposable</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>dispose</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>再來是新的 <code>Subject</code>，這邊比較多繁瑣的實作細節，主要實作：</p><ul><li><code>observers</code> 改成兩個 <code>willChangeObservers</code>、<code>didChangeObservers</code> array，分別存放不同的觀察者。</li><li><code>Observer</code> 的型別改為 closure，讓調用者更易於使用。</li><li><code>observe</code> 要傳入欲觀察的對應 <code>ObservationType</code>。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Subject</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>ObservationType</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> willChange
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> didChange
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>typealias</span> Observation = Int
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>typealias</span> Observer = (Any?) -&gt; Void
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>var</span> id = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> willChangeObservers: [(Observation, Observer)] = []
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> didChangeObservers: [(Observation, Observer)] = []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> name: String = <span style=color:#e6db74>&#34;empty&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>willSet</span> { willChangeObservers.forEach { $0.<span style=color:#ae81ff>1</span>(newValue) } }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>didSet</span> { didChangeObservers.forEach { $0.<span style=color:#ae81ff>1</span>(oldValue) } }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>observe</span>(type: ObservationType, with closure: @escaping Observer) -&gt; ClosureDisposable {
</span></span><span style=display:flex><span>    Subject.id <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> type {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> .willChange: willChangeObservers.append((Subject.id, closure))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> .didChange: didChangeObservers.append((Subject.id, closure))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ClosureDisposable(owner: <span style=color:#66d9ef>self</span>, id: Subject.id, type: type)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>remove</span>(observer: ClosureDisposable) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> observer.type {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> .willChange:
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> index = willChangeObservers.index(<span style=color:#66d9ef>where</span>: { $0.<span style=color:#ae81ff>0</span> == observer.id }) {
</span></span><span style=display:flex><span>        willChangeObservers.remove(at: index)
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> .didChange:
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> index = didChangeObservers.index(<span style=color:#66d9ef>where</span>: { $0.<span style=color:#ae81ff>0</span> == observer.id }) {
</span></span><span style=display:flex><span>        didChangeObservers.remove(at: index)
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>這裡實作前面的 <code>Disposable</code>，為了符合 <code>Subject</code> 的需求，我們暴露 <code>Observation</code> 與 <code>ObservationType</code> 給 <code>ClosureDisposable</code>。<br>實務上，可再訂定更詳細的泛型，或直接將 Disposable 的實際型別定義在 <code>Subject</code> 的 nested class。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ClosureDisposable</span>: Disposable {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span>(<span style=color:#66d9ef>set</span>) <span style=color:#66d9ef>weak</span> <span style=color:#66d9ef>var</span> owner: Subject?
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> id: Subject.Observation
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> type: Subject.ObservationType
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>init</span>(owner: Subject, id: Subject.Observation, type: Subject.ObservationType) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>self</span>.owner = owner
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>self</span>.id = id
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>self</span>.type = type
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>dispose</span>() {
</span></span><span style=display:flex><span>    owner?.remove(observer: <span style=color:#66d9ef>self</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>最後，讓我們來看看結果吧！</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>var</span> subject = Subject()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> observerA = subject.observe(type: .willChange) { val <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  print(<span style=color:#e6db74>&#34;A will change to </span><span style=color:#e6db74>\(</span>val ?? <span style=color:#e6db74>&#34;&#34;</span><span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> observerB = subject.observe(type: .willChange) { val <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  print(<span style=color:#e6db74>&#34;B will change to </span><span style=color:#e6db74>\(</span>val ?? <span style=color:#e6db74>&#34;&#34;</span><span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> observerC = subject.observe(type: .didChange) { val <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  print(<span style=color:#e6db74>&#34;C did change to </span><span style=color:#e6db74>\(</span>val ?? <span style=color:#e6db74>&#34;&#34;</span><span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>subject.name = <span style=color:#e6db74>&#34;1234&#34;</span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;---------- Remove observerB &amp; C ----------&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// subject 移除觀察</span>
</span></span><span style=display:flex><span>subject.remove(observer: observerB)
</span></span><span style=display:flex><span><span style=color:#75715e>// Observer 使用 dispose 主動停止觀察</span>
</span></span><span style=display:flex><span>observerC.dispose()
</span></span><span style=display:flex><span>subject.name = <span style=color:#e6db74>&#34;4321&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// A will change to 1234</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// B will change to 1234</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// C did change to empty</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// ---------- Remove observerB &amp; C ----------</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// A will change to 4321</span>
</span></span></code></pre></div><p>這是我們的第二次嘗試，雖然仍有 <code>ClosureDisposable</code> 與 <code>Subject</code> 耦合性的問題，也暴露太多類別的細節。不過對比第一次，對外接口使用 closure 來綁定 subject，勉強稱得上乾淨利落。</p><h2 id=pub-sub-pattern>Pub-sub pattern<a hidden class=anchor aria-hidden=true href=#pub-sub-pattern>#</a></h2><p>一些狀況下，若需要完全解耦合，或許 <a href=https://en.wikipedia.org/wiki/Publish-subscribe_pattern>Pub-sub pattern</a> 會比 observer pattern 更適合。</p><p><strong>Pub-sub pattern</strong>（Publish-subscribe，訂閱／發佈模式）是一種訊息傳遞設計模式，概念是利用中介 message 做為 publisher（對應 subject）及 subscriber（對應 observer）的溝通橋樑，subscriber 只需訂閱特定 message，而 publisher 則僅負責發佈（broadcast）message。兩者耦合性低，可作為 observer pattern 替代品，但程式也容易變得更複雜。</p><p>實務上，Cocoa 的 <code>NSNotification</code> 是徹底實踐 pub-sub pattern 的範例；以高效著稱的 in-memory database <a href=https://redis.io/>Redis</a> 也有強大的 Pub／Sub 功能。此外，Modern web app 的狀態管理架構兩大陣營 <a href=https://redux.js.org/>Redux</a> 與 <a href=https://mobx.js.org/>MobX</a>，也可以視為 pub-sub pattern 與 observer pattern 的對抗。</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Swift 的 Property observer 讓實作 observer 的門檻降低了，很多有趣的實現，例如 Cocoa Bindings，在 iOS 上變得更簡潔更 Swifty。了解 observer pattern 與組件間的通訊運作原理，勢必能夠帶來更多不同的設計架構，Rx 就是如此孕育而生。</p><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><ul><li><a href=https://en.wikipedia.org/wiki/Observer_pattern>Wiki: Observer pattern</a></li><li><a href=https://en.wikipedia.org/wiki/Publish-subscribe_pattern>Wiki: Publish-subscribe pattern</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://weihanglo.tw/tags/design-patterns/>Design Patterns</a></li><li><a href=https://weihanglo.tw/tags/observer-pattern/>Observer Pattern</a></li><li><a href=https://weihanglo.tw/tags/swift/>Swift</a></li><li><a href=https://weihanglo.tw/tags/reactivex/>ReactiveX</a></li></ul><nav class=paginav><a class=prev href=https://weihanglo.tw/posts/2017/binary-data-manipulations-in-javascript/><span class=title>« Prev</span><br><span>使用 JavaScript 處理二進位資料</span>
</a><a class=next href=https://weihanglo.tw/posts/2017/intro-rx-1-iterator-pattern/><span class=title>Next »</span><br><span>Rx 入門一：迭代器模式</span></a></nav></footer></article></main><footer class=footer><span>CC BY-NC-SA 4.0</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>