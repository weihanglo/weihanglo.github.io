<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="如何利用 Swift 的語言特性來處理例外？使用 Optional 是常見的做法。如果成功就返回 value，失敗則返回 nil，這種模式常用於簡單的狀況。然而，面對複雜的情況，例如網路請求，若只簡單返回 nil，調用者並無法得知是 404，抑或 500。為了解決這個問題，我們必須緊緊抱住錯誤／例外處理的大腿。
（撰於 2017-04-10，基於 Swift 3.1）
Intro of Exception Handling 在開始介紹 Swift 例外處理之前，先來了解什麼是例外處理。維基百科道：
 &mldr;is the process of responding to the occurrence, during computation, of exceptions – anomalous or exceptional conditions requiring special processing – often changing the normal flow of program execution.
 簡單來說，就是某些例外狀況，需要特別的處理，這個處理過程就稱為例外處理，而這個處理常伴隨程式流程轉移改變。
寫習慣 C++／Objective-C 的同學，想必很排斥寫 try-catch 這種吃效能、又易出錯的例外處理，明明 if&mldr;else 就能打遍天下嘛！而喜歡 Python／Ruby 的朋友對 raise 和各種 Exceptions 一定不陌生，甚至 Python 底層的 iterator 都是用 StopIteration Exception 實作。依照各個程式語言的設計，例外處理大致分為兩類："><meta name=theme-color content="#ffcd00"><meta property="og:title" content="理解 Swift 的 Error Handling • Weihang Lo"><meta property="og:description" content="如何利用 Swift 的語言特性來處理例外？使用 Optional 是常見的做法。如果成功就返回 value，失敗則返回 nil，這種模式常用於簡單的狀況。然而，面對複雜的情況，例如網路請求，若只簡單返回 nil，調用者並無法得知是 404，抑或 500。為了解決這個問題，我們必須緊緊抱住錯誤／例外處理的大腿。
（撰於 2017-04-10，基於 Swift 3.1）
Intro of Exception Handling 在開始介紹 Swift 例外處理之前，先來了解什麼是例外處理。維基百科道：
 &mldr;is the process of responding to the occurrence, during computation, of exceptions – anomalous or exceptional conditions requiring special processing – often changing the normal flow of program execution.
 簡單來說，就是某些例外狀況，需要特別的處理，這個處理過程就稱為例外處理，而這個處理常伴隨程式流程轉移改變。
寫習慣 C++／Objective-C 的同學，想必很排斥寫 try-catch 這種吃效能、又易出錯的例外處理，明明 if&mldr;else 就能打遍天下嘛！而喜歡 Python／Ruby 的朋友對 raise 和各種 Exceptions 一定不陌生，甚至 Python 底層的 iterator 都是用 StopIteration Exception 實作。依照各個程式語言的設計，例外處理大致分為兩類："><meta property="og:url" content="https://weihanglo.tw/posts/2017/swift-error-handling/"><meta property="og:site_name" content="Weihang Lo"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:tag" content="Swift"><meta property="article:tag" content="Error Handling"><meta property="article:published_time" content="2017-04-10T16:36:33+08:00"><meta property="article:modified_time" content="2017-04-10T16:36:33+08:00"><meta name=twitter:card content="summary"><meta name=generator content="Hugo 0.74.3"><title>理解 Swift 的 Error Handling • Weihang Lo</title><link rel=canonical href=https://weihanglo.tw/posts/2017/swift-error-handling/><link rel=icon href=/favicon.ico><link rel=stylesheet href=/assets/css/main.ab98e12b.css><link rel=stylesheet href=/css/custom.css><style>:root{--color-accent:#ffcd00}</style></head><body class="page type-posts"><div class=site><a class=screen-reader-text href=#content>Skip to Content</a><div class=main><nav id=main-menu class="menu main-menu" aria-label="Main Menu"><div class=container><ul><li class=item><a href=/>Home</a></li><li class=item><a href=/posts/>Posts</a></li><li class=item><a href=/tags/>Tags</a></li><li class=item><a href=/about/>About</a></li></ul></div></nav><div class=header-widgets><div class=container></div></div><header id=header class="header site-header"><div class="container sep-after"><div class=header-info><p class="site-title title">Weihang Lo</p><p class="desc site-desc"></p></div></div></header><main id=content><article lang=en class=entry><header class="header entry-header"><div class="container sep-after"><div class=header-info><h1 class=title>理解 Swift 的 Error Handling</h1></div><div class=entry-meta><span class=posted-on><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg><span class=screen-reader-text>Posted on</span>
<time class=entry-date datetime=2017-04-10T16:36:33+08:00>2017, Apr 10</time></span>
<span class=reading-time><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 15 15"/></svg>5 mins read</span></div></div></header><div class="container entry-content"><p><img src=https://npmawesome.com/wp-content/uploads/2014/08/Catch-All-The-Errors.png alt></p><p>如何利用 <strong>Swift</strong> 的語言特性來處理例外？使用 <strong>Optional</strong> 是常見的做法。如果成功就返回 <strong>value</strong>，失敗則返回 <code>nil</code>，這種模式常用於簡單的狀況。然而，面對複雜的情況，例如網路請求，若只簡單返回 <code>nil</code>，調用者並無法得知是 <strong>404</strong>，抑或 <strong>500</strong>。為了解決這個問題，我們必須緊緊抱住<a href=https://en.wikipedia.org/wiki/Exception_handling>錯誤／例外處理</a>的大腿。</p><p><em>（撰於 2017-04-10，基於 Swift 3.1）</em></p><h2 id=intro-of-exception-handling>Intro of Exception Handling</h2><p>在開始介紹 Swift 例外處理之前，先來了解什麼是例外處理。維基百科道：</p><blockquote><p>&mldr;is the process of responding to the occurrence, during computation, of exceptions – anomalous or exceptional conditions requiring special processing – often changing the normal flow of program execution.</p></blockquote><p>簡單來說，就是某些例外狀況，需要特別的處理，這個處理過程就稱為<strong>例外處理</strong>，而這個處理常伴隨程式流程轉移改變。</p><p>寫習慣 C++／Objective-C 的同學，想必很排斥寫 <strong>try-catch</strong> 這種吃效能、又易出錯的例外處理，明明 <strong>if&mldr;else</strong> 就能打遍天下嘛！而喜歡 Python／Ruby 的朋友對 <code>raise</code> 和各種 Exceptions 一定不陌生，甚至 Python 底層的 iterator 都是用 <code>StopIteration</code> Exception 實作。依照各個程式語言的設計，例外處理大致分為兩類：</p><ul><li>融入一般的 control flow（Python、Ruby 之流）</li><li>處理特殊、不正常的情況（C++、Objective-C、C# 等）</li></ul><p>大多數程式語言，無論屬於哪一類，只要涉及例外處理，就可能出現<a href="https://stackoverflow.com/search?tab=relevance&q=exception%20performance">效能上的疑慮</a>，很難避開 <a href=https://en.wikipedia.org/wiki/Call_stack#STACK-UNWINDING>Call Stack Unwinding</a> 的問題。能改善的方法之一，就是明確定義哪些 function 能拋出例外，哪些必須拋出例外，哪些錯誤不需要拋出，而是 programmer 自己應該要 handle 的。</p><p>要釐清這個問題，首先要定義錯誤，程式錯誤的範疇很廣，不同的狀況有不同的應對方式，大致上可以分為以下幾種類型：</p><ul><li><p><strong>Simple Errors</strong></p><p>一些很明顯可能產生錯誤的操作，例如 type casting、parsing string to integer。這種錯誤通常很容易理解，不需要過多的描述，在 Swift 或其他語言中，一般返回 <code>nil</code>／<code>undefined</code>／<code>none</code> 等值。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>let</span> result = Int(<span style=color:#e6db74>&#34;I am not an integer, and will return an Optional&#34;</span>)
</code></pre></div></li><li><p><strong>Logical Failures</strong></p><p>由 programmer 產生的錯誤，我們給他一個可愛的暱稱「bug」。Swift 強大的編譯器會幫開發者檢查這些問題，減少 logical failures 的數量。</p></li><li><p><strong>Recoverable Errors</strong></p><p>導致此錯誤的原因複雜，但能夠合理預料的錯誤。例如<strong>開啟檔案</strong>，可能會有 <strong>Permission Denied</strong>、<strong>File Not Found</strong> 等不同的錯誤。這類的錯誤就是 <strong>Exceptions Handling</strong> 主要的目標。</p></li></ul><h2 id=swift-error-handling>Swift Error Handling</h2><p>Swift 在 2.0 版為了妥善處理錯誤，並避免影響效能，決定僅針對 <strong>Recoverable Error</strong> 引入 Error Handling 機制，其他系統底層／語言層的錯誤還是需要 programmer 自行避免。截至 3.1 版，相關的關鍵字如下：</p><ul><li><code>do</code></li><li><code>catch</code></li><li><code>try</code></li><li><code>throw</code></li><li><code>throws</code></li><li><code>rethrows</code></li><li><code>defer</code></li><li><code>Error</code></li></ul><p>Swift 的錯誤處理與主流設計大相逕庭，不幫 programmer 躲過自作孽的 <strong>Login Failure</strong>，不會 catch <strong>index out of bound</strong> 這類錯誤。實際上，Swift 的錯誤處理就只是<a href=https://andybargh.com/error-handling-in-swift/>另一種 Return Type，與相關的 Syntax Sugar</a>。其<a href=https://github.com/apple/swift/blob/master/docs/ErrorHandling.rst>設計理念／特色</a>整理如下：</p><ul><li>拋出錯誤之處需為顯式聲明。</li><li>函式必須顯式宣告它會<strong>拋出錯誤</strong>，讓 programmer 明確得知哪些程式該處理錯誤。</li><li>拋出錯誤的效能如同初始化並返回 <strong>Error</strong> 型別一樣簡單，不涉及 stack unwinding。</li></ul><p>Swift 有四種方法處理 Error：</p><ol><li>轉拋／傳遞錯誤（error propagation）。</li><li>使用 <strong>do-catch</strong> 陳述句處理。</li><li>將 Error 轉為 <strong>Optional Value</strong>（<code>try?</code>）。</li><li>停止錯誤傳遞（<code>try!</code>）</li></ol><p>能被拋出的錯誤需繼承 <code>Error</code> protocol，在此先定義一個錯誤類型，爾後再介紹。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>DRMError</span>: Error {
    <span style=color:#66d9ef>case</span> timeout
    <span style=color:#66d9ef>case</span> invalidHeader
    <span style=color:#66d9ef>case</span> missingParam(String)
    <span style=color:#66d9ef>case</span> responseFailure(code: Int, message: Data)
}
</code></pre></div><h3 id=propagating-errors>Propagating Errors</h3><p>第一種處理方法：透過 <strong>throwing function</strong> 轉拋／傳遞錯誤。</p><p>任何一個 function、method 或 initializer 若要拋出錯誤，需在參數之後，Return Type 之前加上 <code>throws</code> 來宣告一個 <strong>throwing function</strong>，顯式聲明該函式的需要錯誤處理。並利用 <code>throw</code> 來拋出錯誤。我們可以利用這個特性，將錯誤轉拋／傳遞出去給外面的作用域。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>canThrowTimeout</span>() <span style=color:#66d9ef>throws</span> { <span style=color:#75715e>// 可以拋出錯誤</span>
    <span style=color:#66d9ef>throw</span> DRMError.timeout
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>isHeaderEmpty</span>(header: [String: Any]) <span style=color:#66d9ef>throws</span> -&gt; Bool { <span style=color:#75715e>// 可以拋出錯誤</span>
    <span style=color:#66d9ef>guard</span> header.count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>else</span> { <span style=color:#66d9ef>throw</span> DRMError.invalidHeader }
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
}

<span style=color:#75715e>// 這個函式會錯誤轉拋／傳遞出去，將錯誤處理責任轉移到調用它的作用域。</span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>throwPropagation</span>() <span style=color:#66d9ef>throws</span> {
    <span style=color:#66d9ef>throw</span> DRMError.missingParam(<span style=color:#e6db74>&#34;pubkey&#34;</span>)
    <span style=color:#66d9ef>try</span> canThrowTimeout()
}

<span style=color:#66d9ef>try</span> throwPropagation()
</code></pre></div><blockquote><p>調用 <strong>throwing function</strong> 時，必須在該函式前使用 <code>try</code> 顯式調用，否則編譯不會過。</p></blockquote><blockquote><p>我們可以把 <code>throw</code> 視為一種特殊的 <code>return</code>，專門用來返回一個 <strong>Error</strong> 實例。</p></blockquote><h3 id=using-do-catch>Using <code>do-catch</code></h3><p>第二種處理方法：使用 <strong>do-catch</strong> 來捕獲錯誤。</p><p><strong>do-catch</strong> 就好比 Objective-C 的 <code>@try-@catch</code>，在 <code>do</code> 區塊內拋出的錯誤會被捕獲，並尋找對應的 <code>catch</code> 區塊來處理錯誤。用法如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>do</span> {
    <span style=color:#66d9ef>try</span> throwPropagation() <span style=color:#75715e>// 只能從用 try 標註的 throwing function 捕獲錯誤</span>
    <span style=color:#75715e>// 若調用 `catchFromThis()` 這樣的函式，未使用 `try` 標註，</span>
    <span style=color:#75715e>// 錯誤無法被捕獲（實際上也沒辦法拋出 custom error）。</span>
    <span style=color:#75715e>// ...</span>
} <span style=color:#66d9ef>catch</span> DRMError.timeout { <span style=color:#75715e>// 使用 pattern matching 捕獲特定錯誤</span>
    print(<span style=color:#e6db74>&#34;Oh No! Timeout!&#34;</span>)
} <span style=color:#66d9ef>catch</span> DRMError.missingParam(<span style=color:#66d9ef>let</span> p) <span style=color:#66d9ef>where</span> p == <span style=color:#e6db74>&#34;pubkey&#34;</span> { <span style=color:#75715e>// pattern matching + generic where clause</span>
    print(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\(</span>param<span style=color:#e6db74>)</span><span style=color:#e6db74> is missing.&#34;</span>)
} <span style=color:#66d9ef>catch</span> { <span style=color:#75715e>// 捕獲剩下的所有錯誤（類似 default），並 binding 到區域變數 `error`</span>
    print(<span style=color:#e6db74>&#34;Unexpected Error&#34;</span>)
}
</code></pre></div><p>範例中，看到了 <code>catch</code> 結合 Swift 強大的 <strong>pattern matching</strong> 來捕獲錯誤，並活用 <strong>value binding</strong> 獲取錯誤的詳細資訊。我們可以把 <code>catch</code> 看作 <strong>switch-case</strong> 來使用各種 Swift patterns 的奇技淫巧。唯一不同的是，<strong>do-catch</strong> 不需要枚舉所有可能拋出的錯誤，若有錯誤未被處理，它將會繼續傳遞到周遭的作用域。</p><h3 id=converting-to-optional>Converting to Optional</h3><p>第三種處理法：利用 <code>try?</code> 將錯誤轉換成 Optional。</p><p>這種作法大家應該都很能理解，直接貼官方的例子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>someThrowingFunction</span>() <span style=color:#66d9ef>throws</span> -&gt; Int {
    <span style=color:#75715e>// ...</span>
}

<span style=color:#66d9ef>let</span> x = <span style=color:#66d9ef>try</span>? someThrowingFunction() <span style=color:#75715e>// `x` 是一個 Optional</span>

<span style=color:#66d9ef>let</span> y: Int?
<span style=color:#66d9ef>do</span> {
    y = <span style=color:#66d9ef>try</span> someThrowingFunction() <span style=color:#75715e>// 若無拋出錯誤，則將賦值給 `y`</span>
} <span style=color:#66d9ef>catch</span> {
    y = <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>透過 <code>try?</code>，將 <strong>throwing function</strong> 的錯誤轉換成 Optional 後，理所當然可以使用 Optional 的所有特性，例如 <strong>optional-binding</strong>，例如官方的範例：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fetchData</span>() -&gt; Data? {
    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> data = <span style=color:#66d9ef>try</span>? fetchDataFromDisk() { <span style=color:#66d9ef>return</span> data }
    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> data = <span style=color:#66d9ef>try</span>? fetchDataFromServer() { <span style=color:#66d9ef>return</span> data }
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><h3 id=stopping-propagation>Stopping Propagation</h3><p>第四種作法：使用 <code>try!</code> 停止錯誤繼續傳遞。</p><p>當你<strong>非常有信心</strong>錯誤不會發生，可以使用 <code>try!</code> 停止錯誤往下傳遞。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#75715e>// 接續前一個例子</span>
<span style=color:#75715e>// `x` 是一個 Int，如果 someThrowingFunction 拋出錯誤，則會得到 runtime error。</span>
<span style=color:#66d9ef>let</span> x = <span style=color:#66d9ef>try</span>! someThrowingFunction()
</code></pre></div><h2 id=other-handling-keywords>Other Handling Keywords</h2><p>到此，我們介紹了 <code>do</code>、<code>catch</code>、<code>try</code>、<code>throw</code>、<code>throws</code>，這裡接著介紹 <code>rethrows</code>、<code>defer</code> 與 <code>Error</code>。</p><h3 id=rethrows-your-error><code>rethrows</code> your Error</h3><p><code>rethrows</code> 這個關鍵字乍看很詭異，但它並非會再拋出錯誤，如果一個函式宣告為 <code>rethrows</code>，意指</p><blockquote><p>這個 <strong>rethrowing function</strong> 只會在它的函式型別參數（function parameter）拋出錯誤時，才會拋出錯誤。</p></blockquote><p>要宣告為 <strong>rethrowing function</strong>，必須符合幾個要素：</p><ul><li>至少一個函式型別參數帶有 <strong>throwing function</strong> signature。</li><li>只能在 <strong>do-catch</strong> 的 <code>catch</code> 語句中使用 <code>throw</code> 拋出錯誤。</li><li><code>do</code> 語句中只能處理作為參數的 <strong>throwing function</strong> 拋出的錯誤。</li></ul><p>簡單的範例如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>rethrowFunction</span>(callback: () <span style=color:#66d9ef>throws</span> -&gt; Void) <span style=color:#66d9ef>rethrows</span> {
    <span style=color:#66d9ef>try</span> callback()
}

<span style=color:#66d9ef>try</span> rethrowFunction {
  <span style=color:#66d9ef>throw</span> DRMError.timeout
}
</code></pre></div><p>我們可以看到，許多與函數式程式設計相關 methods，都有帶 <code>rethrows</code> 的 signatures，例如 <code>Collection</code> 的 <code>map()</code> 與 <code>index(where:)</code>，讓處理集合時，可以將錯誤傳遞到正確的作用域。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>protocol</span> <span style=color:#a6e22e>Collection</span> : Sequence {
  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>map</span>&lt;T&gt;(<span style=color:#66d9ef>_</span> transform: (Element) <span style=color:#66d9ef>throws</span> -&gt; T) <span style=color:#66d9ef>rethrows</span> -&gt; [T]

  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>index</span>(<span style=color:#66d9ef>where</span> predicate: (<span style=color:#66d9ef>Self</span>.Iterator.Element) <span style=color:#66d9ef>throws</span> -&gt; Bool) <span style=color:#66d9ef>rethrows</span> -&gt; <span style=color:#66d9ef>Self</span>.Index?
}
</code></pre></div><h3 id=defer-your-finally><code>defer</code> Your Finally</h3><p>相信熟悉其他語言的童鞋，一定在想「我的 <strong>try-catch-finally</strong> 的 <code>finally</code> 呢？」，先前說過，Swift 的 error handling 只是一些甜死人的語法糖，官方並沒有特別為這個 model 增添關鍵字，而是使用大家已知的 <code>defer</code>，不懂的趕快<a href=https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/doc/uid/TP40014097-CH33-ID532>點這裡</a>惡補一下。</p><p>這裡寫段開檔的 pseudo code 給大家瞧瞧：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>handle</span>(fileError error: FileError) {
  <span style=color:#66d9ef>switch</span> error {
  <span style=color:#66d9ef>case</span> .notFound: print(<span style=color:#e6db74>&#34;File not found.&#34;</span>)
  <span style=color:#66d9ef>case</span> .permissionDenied: print(<span style=color:#e6db74>&#34;Permission denied&#34;</span>)
  <span style=color:#66d9ef>default</span>: print(<span style=color:#e6db74>&#34;Unknown error occurred.&#34;</span>)
  }
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>writeTo</span>(file: File, data: Data) {
    <span style=color:#66d9ef>defer</span> { close(file) } <span style=color:#75715e>// 在這個 code block 結束之前執行</span>

    <span style=color:#66d9ef>do</span> {
        <span style=color:#66d9ef>try</span> openFile(file)
    } <span style=color:#66d9ef>catch</span> <span style=color:#66d9ef>let</span> error <span style=color:#66d9ef>as</span> FileError {
        handle(fileError: error)
    } <span style=color:#66d9ef>catch</span> <span style=color:#66d9ef>_</span> { <span style=color:#75715e>// wildcard pattern without binding error value to error</span>
        print(<span style=color:#e6db74>&#34;This is not a FileError.&#34;</span>)
    }
}
</code></pre></div><h3 id=customize-your-error>Customize Your <code>Error</code></h3><p>一開始，我們實現了一個 <code>DRMError</code> 繼承了 <code>Error</code>，讓我們自定義的錯誤能夠正確拋出。那這個 <code>Error</code> protocol 究竟葫蘆裡買啥藥？很驚人地，<code>Error</code> 是個 empty protocol，沒有任何實現，可說是名副其實的語法糖。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>protocol</span> <span style=color:#a6e22e>Error</span> {
}

<span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>Error</span> {
}

<span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>Error</span> <span style=color:#66d9ef>where</span> <span style=color:#66d9ef>Self</span>.RawValue : SignedInteger {
}

<span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>Error</span> <span style=color:#66d9ef>where</span> <span style=color:#66d9ef>Self</span>.RawValue : UnsignedInteger {
}
</code></pre></div><p>由於 <strong>do-catch</strong> 和 Swift patterns 緊密結合，官方推薦使用 <code>enum</code> 客製化我們自己的 Error Type。當有特殊需求，例如 Errors 間有共享的 state 或 data 時，也可用如 <code>struct</code> 來實現自定義 Error，舉個官方的 XML Parsing 例子：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>XMLParsingError</span>: Error {
   <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>ErrorKind</span> {
       <span style=color:#66d9ef>case</span> invalidCharacter
       <span style=color:#66d9ef>case</span> mismatchedTag
       <span style=color:#66d9ef>case</span> internalError
   }

   <span style=color:#66d9ef>let</span> line: Int
   <span style=color:#66d9ef>let</span> column: Int
   <span style=color:#66d9ef>let</span> kind: ErrorKind
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>parse</span>(<span style=color:#66d9ef>_</span> source: String) <span style=color:#66d9ef>throws</span> -&gt; XMLDoc {
   <span style=color:#75715e>// ...</span>
   <span style=color:#66d9ef>throw</span> XMLParsingError(line: <span style=color:#ae81ff>19</span>, column: <span style=color:#ae81ff>5</span>, kind: .mismatchedTag)
}

<span style=color:#66d9ef>do</span> {
   <span style=color:#66d9ef>let</span> xmlDoc = <span style=color:#66d9ef>try</span> parse(myXMLData)
} <span style=color:#66d9ef>catch</span> <span style=color:#66d9ef>let</span> e <span style=color:#66d9ef>as</span> XMLParsingError {
   print(<span style=color:#e6db74>&#34;Parsing error: </span><span style=color:#e6db74>\(</span>e.kind<span style=color:#e6db74>)</span><span style=color:#e6db74> [</span><span style=color:#e6db74>\(</span>e.line<span style=color:#e6db74>)</span><span style=color:#e6db74>:</span><span style=color:#e6db74>\(</span>e.column<span style=color:#e6db74>)</span><span style=color:#e6db74>]&#34;</span>)
} <span style=color:#66d9ef>catch</span> {
   print(<span style=color:#e6db74>&#34;Other error: </span><span style=color:#e6db74>\(</span>error<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
}
</code></pre></div><p>上例可清楚呈現解析 XML 時，Error 共享類似的 states。Swift Error Protocol 設計地非常有彈性。</p><h2 id=notices-and-future>Notices and Future</h2><p>Swift 的 Error Handling 設計得很現代很 functional，也讓錯誤處理不再只存在於醜陋的 code 或是不齊全的 document 中，而是提升至語言層面加以約束、保障。同時，仍有幾點需要注意、了解：</p><ul><li><code>throws</code> 關鍵字是 function type 的一部分，而 non-throwing function 是 throwing function 的 subtype，所以可以在任何宣告 throwing function 處使用 non-throwing。</li><li>承上，non-throwing method 可以 override throwing method，<strong>反之則否</strong>。</li><li><code>throw</code> 的功能類似 <code>return</code>，對 asynchronous operation 不夠友善，因此許多人 porting 等其他語言的 <code>Promise</code>/<code>Future</code> 的特性，來彌補異步錯誤處理的不足。比較知名的庫有 <a href=https://github.com/mxcl/PromiseKit>PromiseKit</a> 等（想學習 <code>Promise</code> 概念，可參考<a href=https://developers.google.com/web/fundamentals/getting-started/primers/promises>這個連結</a>）。</li></ul><p>如果未來，語言層級的平行運算（並行運算）就像<a href=https://onevcat.com/2016/12/concurrency/>這篇文章</a>所說的，會在 Swift 5 推出；如果之後 <code>async</code>／<code>await</code> 如同 <strong>ES7</strong> 一樣納入 Swift 標準，如果 actor system 真的導入 Swift 中，天知道兩年後 Swift 寫起來會有多舒服！</p><h2 id=reference>Reference</h2><ul><li><a href=https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html>Swift Language Guide - Error Handling</a></li><li><a href=https://en.wikipedia.org/wiki/Exception_handling>Wiki - Exception Handling</a></li><li><a href=https://github.com/apple/swift/blob/master/docs/ErrorHandling.rst>Error Handling in Swift 2.0</a></li><li><a href=https://andybargh.com/error-handling-in-swift/>Andy Bargh - Error Handling in Swift</a></li></ul></div><footer class=entry-footer><div class="container sep-before"><div class=tags><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2H12l8.59 8.59A2 2 0 0120.59 13.41z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=screen-reader-text>Tags: </span><a class=tag href=/tags/swift/>Swift</a>, <a class=tag href=/tags/error-handling/>Error Handling</a></div></div><div style=text-align:center;padding-top:2em><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/><img src=https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png alt=cc-by-nc-sa-4></a></div></footer></article><nav class=entry-nav><div class=container><div class="prev-entry sep-before"><a href=/posts/2017/fed-toolchain/><span aria-hidden=true><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="20" y1="12" x2="4" y2="12"/><polyline points="10 18 4 12 10 6"/></svg>Previous</span>
<span class=screen-reader-text>Previous post: </span>大前端時代的工具箱</a></div><div class="next-entry sep-before"><a href=/posts/2017/swift-generics/><span class=screen-reader-text>Next post: </span>理解 Swift Generics<span aria-hidden=true>Next<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="4" y1="12" x2="20" y2="12"/><polyline points="14 6 20 12 14 18"/></svg></span></a></div></div></nav></main><footer id=footer class=footer><div class="container sep-before"><section class="widget widget-social_menu sep-after"><nav aria-label="Social Menu"><ul><li><a href=https://github.com/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Github account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li><a href=https://facebook.com/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Facebook account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M18 2h-3a5 5 0 00-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 011-1h3z"/></svg></a></li><li><a href=https://twitter.com/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Twitter account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><title>Twitter icon</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></li><li><a href=https://linkedin.com/in/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Linkedin account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></li><li><a href=https://t.me/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Telegram account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><title>Telegram icon</title><path d="M23.91 3.79 20.3 20.84c-.25 1.21-.98 1.5-2 .94l-5.5-4.07-2.66 2.57c-.3.3-.55.56-1.1.56-.72.0-.6-.27-.84-.95L6.3 13.7l-5.45-1.7c-1.18-.35-1.19-1.16.26-1.75l21.26-8.2c.97-.43 1.9.24 1.53 1.73z"/></svg></a></li></ul></nav></section><div class=copyright><p>&copy; 2017-2021 Weihang Lo</p></div></div></footer></div></div><script>window.__assets_js_src="/assets/js/"</script><script src=/assets/js/main.c3bcf2df.js></script><script src=/js/custom.js></script></body></html>