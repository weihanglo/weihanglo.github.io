<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>理解 Swift 的 Error Handling | Weihang Lo</title>
<meta name=keywords content="Swift,Error Handling">
<meta name=description content="如何利用 Swift 的語言特性來處理例外？使用 Optional 是常見的做法。如果成功就返回 value，失敗則返回 nil，這種模式常用於簡單的狀況。然而，面對複雜的情">
<meta name=author content>
<link rel=canonical href=https://weihanglo.tw/posts/2017/swift-error-handling/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style>
<link rel=icon href=https://weihanglo.tw/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://weihanglo.tw/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://weihanglo.tw/favicon-32x32.png>
<link rel=apple-touch-icon href=https://weihanglo.tw/apple-touch-icon.png>
<link rel=mask-icon href=https://weihanglo.tw/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:!0},{left:'$',right:'$',display:!1},{left:'\\(',right:'\\)',display:!1},{left:'\\[',right:'\\]',display:!0}],throwOnError:!1})})</script>
<meta property="og:title" content="理解 Swift 的 Error Handling">
<meta property="og:description" content="如何利用 Swift 的語言特性來處理例外？使用 Optional 是常見的做法。如果成功就返回 value，失敗則返回 nil，這種模式常用於簡單的狀況。然而，面對複雜的情">
<meta property="og:type" content="article">
<meta property="og:url" content="https://weihanglo.tw/posts/2017/swift-error-handling/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2017-04-10T16:36:33+08:00">
<meta property="article:modified_time" content="2017-04-10T16:36:33+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="理解 Swift 的 Error Handling">
<meta name=twitter:description content="如何利用 Swift 的語言特性來處理例外？使用 Optional 是常見的做法。如果成功就返回 value，失敗則返回 nil，這種模式常用於簡單的狀況。然而，面對複雜的情">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://weihanglo.tw/posts/"},{"@type":"ListItem","position":3,"name":"理解 Swift 的 Error Handling","item":"https://weihanglo.tw/posts/2017/swift-error-handling/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"理解 Swift 的 Error Handling","name":"理解 Swift 的 Error Handling","description":"如何利用 Swift 的語言特性來處理例外？使用 Optional 是常見的做法。如果成功就返回 value，失敗則返回 nil，這種模式常用於簡單的狀況。然而，面對複雜的情","keywords":["Swift","Error Handling"],"articleBody":"如何利用 Swift 的語言特性來處理例外？使用 Optional 是常見的做法。如果成功就返回 value，失敗則返回 nil，這種模式常用於簡單的狀況。然而，面對複雜的情況，例如網路請求，若只簡單返回 nil，調用者並無法得知是 404，抑或 500。為了解決這個問題，我們必須緊緊抱住錯誤／例外處理的大腿。\n（撰於 2017-04-10，基於 Swift 3.1）\nIntro of Exception Handling 在開始介紹 Swift 例外處理之前，先來了解什麼是例外處理。維基百科道：\n …is the process of responding to the occurrence, during computation, of exceptions – anomalous or exceptional conditions requiring special processing – often changing the normal flow of program execution.\n 簡單來說，就是某些例外狀況，需要特別的處理，這個處理過程就稱為例外處理，而這個處理常伴隨程式流程轉移改變。\n寫習慣 C++／Objective-C 的同學，想必很排斥寫 try-catch 這種吃效能、又易出錯的例外處理，明明 if…else 就能打遍天下嘛！而喜歡 Python／Ruby 的朋友對 raise 和各種 Exceptions 一定不陌生，甚至 Python 底層的 iterator 都是用 StopIteration Exception 實作。依照各個程式語言的設計，例外處理大致分為兩類：\n 融入一般的 control flow（Python、Ruby 之流） 處理特殊、不正常的情況（C++、Objective-C、C# 等）  大多數程式語言，無論屬於哪一類，只要涉及例外處理，就可能出現效能上的疑慮，很難避開 Call Stack Unwinding 的問題。能改善的方法之一，就是明確定義哪些 function 能拋出例外，哪些必須拋出例外，哪些錯誤不需要拋出，而是 programmer 自己應該要 handle 的。\n要釐清這個問題，首先要定義錯誤，程式錯誤的範疇很廣，不同的狀況有不同的應對方式，大致上可以分為以下幾種類型：\n  Simple Errors\n一些很明顯可能產生錯誤的操作，例如 type casting、parsing string to integer。這種錯誤通常很容易理解，不需要過多的描述，在 Swift 或其他語言中，一般返回 nil／undefined／none 等值。\nlet result = Int(\"I am not an integer, and will return an Optional\")   Logical Failures\n由 programmer 產生的錯誤，我們給他一個可愛的暱稱「bug」。Swift 強大的編譯器會幫開發者檢查這些問題，減少 logical failures 的數量。\n  Recoverable Errors\n導致此錯誤的原因複雜，但能夠合理預料的錯誤。例如開啟檔案，可能會有 Permission Denied、File Not Found 等不同的錯誤。這類的錯誤就是 Exceptions Handling 主要的目標。\n  Swift Error Handling Swift 在 2.0 版為了妥善處理錯誤，並避免影響效能，決定僅針對 Recoverable Error 引入 Error Handling 機制，其他系統底層／語言層的錯誤還是需要 programmer 自行避免。截至 3.1 版，相關的關鍵字如下：\n do catch try throw throws rethrows defer Error  Swift 的錯誤處理與主流設計大相逕庭，不幫 programmer 躲過自作孽的 Login Failure，不會 catch index out of bound 這類錯誤。實際上，Swift 的錯誤處理就只是另一種 Return Type，與相關的 Syntax Sugar。其設計理念／特色整理如下：\n 拋出錯誤之處需為顯式聲明。 函式必須顯式宣告它會拋出錯誤，讓 programmer 明確得知哪些程式該處理錯誤。 拋出錯誤的效能如同初始化並返回 Error 型別一樣簡單，不涉及 stack unwinding。  Swift 有四種方法處理 Error：\n 轉拋／傳遞錯誤（error propagation）。 使用 do-catch 陳述句處理。 將 Error 轉為 Optional Value（try?）。 停止錯誤傳遞（try!）  能被拋出的錯誤需繼承 Error protocol，在此先定義一個錯誤類型，爾後再介紹。\nenum DRMError: Error { case timeout case invalidHeader case missingParam(String) case responseFailure(code: Int, message: Data) } Propagating Errors 第一種處理方法：透過 throwing function 轉拋／傳遞錯誤。\n任何一個 function、method 或 initializer 若要拋出錯誤，需在參數之後，Return Type 之前加上 throws 來宣告一個 throwing function，顯式聲明該函式的需要錯誤處理。並利用 throw 來拋出錯誤。我們可以利用這個特性，將錯誤轉拋／傳遞出去給外面的作用域。\nfunc canThrowTimeout() throws { // 可以拋出錯誤 throw DRMError.timeout } func isHeaderEmpty(header: [String: Any]) throws - Bool { // 可以拋出錯誤 guard header.count  0 else { throw DRMError.invalidHeader } return true } // 這個函式會錯誤轉拋／傳遞出去，將錯誤處理責任轉移到調用它的作用域。 func throwPropagation() throws { throw DRMError.missingParam(\"pubkey\") try canThrowTimeout() } try throwPropagation()  調用 throwing function 時，必須在該函式前使用 try 顯式調用，否則編譯不會過。\n  我們可以把 throw 視為一種特殊的 return，專門用來返回一個 Error 實例。\n Using do-catch 第二種處理方法：使用 do-catch 來捕獲錯誤。\ndo-catch 就好比 Objective-C 的 @try-@catch，在 do 區塊內拋出的錯誤會被捕獲，並尋找對應的 catch 區塊來處理錯誤。用法如下：\ndo { try throwPropagation() // 只能從用 try 標註的 throwing function 捕獲錯誤 // 若調用 `catchFromThis()` 這樣的函式，未使用 `try` 標註， // 錯誤無法被捕獲（實際上也沒辦法拋出 custom error）。 // ... } catch DRMError.timeout { // 使用 pattern matching 捕獲特定錯誤 print(\"Oh No! Timeout!\") } catch DRMError.missingParam(let p) where p == \"pubkey\" { // pattern matching + generic where clause print(\"\\(param)is missing.\") } catch { // 捕獲剩下的所有錯誤（類似 default），並 binding 到區域變數 `error` print(\"Unexpected Error\") } 範例中，看到了 catch 結合 Swift 強大的 pattern matching 來捕獲錯誤，並活用 value binding 獲取錯誤的詳細資訊。我們可以把 catch 看作 switch-case 來使用各種 Swift patterns 的奇技淫巧。唯一不同的是，do-catch 不需要枚舉所有可能拋出的錯誤，若有錯誤未被處理，它將會繼續傳遞到周遭的作用域。\nConverting to Optional 第三種處理法：利用 try? 將錯誤轉換成 Optional。\n這種作法大家應該都很能理解，直接貼官方的例子：\nfunc someThrowingFunction() throws - Int { // ... } let x = try? someThrowingFunction() // `x` 是一個 Optional let y: Int? do { y = try someThrowingFunction() // 若無拋出錯誤，則將賦值給 `y` } catch { y = nil } 透過 try?，將 throwing function 的錯誤轉換成 Optional 後，理所當然可以使用 Optional 的所有特性，例如 optional-binding，例如官方的範例：\nfunc fetchData() - Data? { if let data = try? fetchDataFromDisk() { return data } if let data = try? fetchDataFromServer() { return data } return nil } Stopping Propagation 第四種作法：使用 try! 停止錯誤繼續傳遞。\n當你非常有信心錯誤不會發生，可以使用 try! 停止錯誤往下傳遞。\n// 接續前一個例子 // `x` 是一個 Int，如果 someThrowingFunction 拋出錯誤，則會得到 runtime error。 let x = try! someThrowingFunction() Other Handling Keywords 到此，我們介紹了 do、catch、try、throw、throws，這裡接著介紹 rethrows、defer 與 Error。\nrethrows your Error rethrows 這個關鍵字乍看很詭異，但它並非會再拋出錯誤，如果一個函式宣告為 rethrows，意指\n 這個 rethrowing function 只會在它的函式型別參數（function parameter）拋出錯誤時，才會拋出錯誤。\n 要宣告為 rethrowing function，必須符合幾個要素：\n 至少一個函式型別參數帶有 throwing function signature。 只能在 do-catch 的 catch 語句中使用 throw 拋出錯誤。 do 語句中只能處理作為參數的 throwing function 拋出的錯誤。  簡單的範例如下：\nfunc rethrowFunction(callback: () throws - Void) rethrows { try callback() } try rethrowFunction { throw DRMError.timeout } 我們可以看到，許多與函數式程式設計相關 methods，都有帶 rethrows 的 signatures，例如 Collection 的 map() 與 index(where:)，讓處理集合時，可以將錯誤傳遞到正確的作用域。\npublic protocol Collection : Sequence { public func map(_ transform: (Element) throws - T) rethrows - [T] public func index(where predicate: (Self.Iterator.Element) throws - Bool) rethrows - Self.Index? } defer Your Finally 相信熟悉其他語言的童鞋，一定在想「我的 try-catch-finally 的 finally 呢？」，先前說過，Swift 的 error handling 只是一些甜死人的語法糖，官方並沒有特別為這個 model 增添關鍵字，而是使用大家已知的 defer，不懂的趕快點這裡惡補一下。\n這裡寫段開檔的 pseudo code 給大家瞧瞧：\nfunc handle(fileError error: FileError) { switch error { case .notFound: print(\"File not found.\") case .permissionDenied: print(\"Permission denied\") default: print(\"Unknown error occurred.\") } } func writeTo(file: File, data: Data) { defer { close(file) } // 在這個 code block 結束之前執行 do { try openFile(file) } catch let error as FileError { handle(fileError: error) } catch _ { // wildcard pattern without binding error value to error print(\"This is not a FileError.\") } } Customize Your Error 一開始，我們實現了一個 DRMError 繼承了 Error，讓我們自定義的錯誤能夠正確拋出。那這個 Error protocol 究竟葫蘆裡買啥藥？很驚人地，Error 是個 empty protocol，沒有任何實現，可說是名副其實的語法糖。\npublic protocol Error { } extension Error { } extension Error where Self.RawValue : SignedInteger { } extension Error where Self.RawValue : UnsignedInteger { } 由於 do-catch 和 Swift patterns 緊密結合，官方推薦使用 enum 客製化我們自己的 Error Type。當有特殊需求，例如 Errors 間有共享的 state 或 data 時，也可用如 struct 來實現自定義 Error，舉個官方的 XML Parsing 例子：\nstruct XMLParsingError: Error { enum ErrorKind { case invalidCharacter case mismatchedTag case internalError } let line: Int let column: Int let kind: ErrorKind } func parse(_ source: String) throws - XMLDoc { // ... throw XMLParsingError(line: 19, column: 5, kind: .mismatchedTag) } do { let xmlDoc = try parse(myXMLData) } catch let e as XMLParsingError { print(\"Parsing error: \\(e.kind)[\\(e.line):\\(e.column)]\") } catch { print(\"Other error: \\(error)\") } 上例可清楚呈現解析 XML 時，Error 共享類似的 states。Swift Error Protocol 設計地非常有彈性。\nNotices and Future Swift 的 Error Handling 設計得很現代很 functional，也讓錯誤處理不再只存在於醜陋的 code 或是不齊全的 document 中，而是提升至語言層面加以約束、保障。同時，仍有幾點需要注意、了解：\n throws 關鍵字是 function type 的一部分，而 non-throwing function 是 throwing function 的 subtype，所以可以在任何宣告 throwing function 處使用 non-throwing。 承上，non-throwing method 可以 override throwing method，反之則否。 throw 的功能類似 return，對 asynchronous operation 不夠友善，因此許多人 porting 等其他語言的 Promise/Future 的特性，來彌補異步錯誤處理的不足。比較知名的庫有 PromiseKit 等（想學習 Promise 概念，可參考這個連結）。  如果未來，語言層級的平行運算（並行運算）就像這篇文章所說的，會在 Swift 5 推出；如果之後 async／await 如同 ES7 一樣納入 Swift 標準，如果 actor system 真的導入 Swift 中，天知道兩年後 Swift 寫起來會有多舒服！\nReference  Swift Language Guide - Error Handling Wiki - Exception Handling Error Handling in Swift 2.0 Andy Bargh - Error Handling in Swift  ","wordCount":"3371","inLanguage":"en","datePublished":"2017-04-10T16:36:33+08:00","dateModified":"2017-04-10T16:36:33+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://weihanglo.tw/posts/2017/swift-error-handling/"},"publisher":{"@type":"Organization","name":"Weihang Lo","logo":{"@type":"ImageObject","url":"https://weihanglo.tw/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://weihanglo.tw accesskey=h title="Weihang Lo (Alt + H)">Weihang Lo</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://weihanglo.tw/ title=Home>
<span>Home</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/posts/ title=Posts>
<span>Posts</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
理解 Swift 的 Error Handling
</h1>
<div class=post-meta><span title="2017-04-10 16:36:33 +0800 +0800">April 10, 2017</span>&nbsp;·&nbsp;7 min
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#intro-of-exception-handling aria-label="Intro of Exception Handling">Intro of Exception Handling</a></li>
<li>
<a href=#swift-error-handling aria-label="Swift Error Handling">Swift Error Handling</a><ul>
<li>
<a href=#propagating-errors aria-label="Propagating Errors">Propagating Errors</a></li>
<li>
<a href=#using-do-catch aria-label="Using do-catch">Using <code>do-catch</code></a></li>
<li>
<a href=#converting-to-optional aria-label="Converting to Optional">Converting to Optional</a></li>
<li>
<a href=#stopping-propagation aria-label="Stopping Propagation">Stopping Propagation</a></li></ul>
</li>
<li>
<a href=#other-handling-keywords aria-label="Other Handling Keywords">Other Handling Keywords</a><ul>
<li>
<a href=#rethrows-your-error aria-label="rethrows your Error"><code>rethrows</code> your Error</a></li>
<li>
<a href=#defer-your-finally aria-label="defer Your Finally"><code>defer</code> Your Finally</a></li>
<li>
<a href=#customize-your-error aria-label="Customize Your Error">Customize Your <code>Error</code></a></li></ul>
</li>
<li>
<a href=#notices-and-future aria-label="Notices and Future">Notices and Future</a></li>
<li>
<a href=#reference aria-label=Reference>Reference</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p><img loading=lazy src=https://npmawesome.com/wp-content/uploads/2014/08/Catch-All-The-Errors.png alt>
</p>
<p>如何利用 <strong>Swift</strong> 的語言特性來處理例外？使用 <strong>Optional</strong> 是常見的做法。如果成功就返回 <strong>value</strong>，失敗則返回 <code>nil</code>，這種模式常用於簡單的狀況。然而，面對複雜的情況，例如網路請求，若只簡單返回 <code>nil</code>，調用者並無法得知是 <strong>404</strong>，抑或 <strong>500</strong>。為了解決這個問題，我們必須緊緊抱住<a href=https://en.wikipedia.org/wiki/Exception_handling>錯誤／例外處理</a>的大腿。</p>
<p><em>（撰於 2017-04-10，基於 Swift 3.1）</em></p>
<h2 id=intro-of-exception-handling>Intro of Exception Handling<a hidden class=anchor aria-hidden=true href=#intro-of-exception-handling>#</a></h2>
<p>在開始介紹 Swift 例外處理之前，先來了解什麼是例外處理。維基百科道：</p>
<blockquote>
<p>&mldr;is the process of responding to the occurrence, during computation, of exceptions – anomalous or exceptional conditions requiring special processing – often changing the normal flow of program execution.</p>
</blockquote>
<p>簡單來說，就是某些例外狀況，需要特別的處理，這個處理過程就稱為<strong>例外處理</strong>，而這個處理常伴隨程式流程轉移改變。</p>
<p>寫習慣 C++／Objective-C 的同學，想必很排斥寫 <strong>try-catch</strong> 這種吃效能、又易出錯的例外處理，明明 <strong>if&mldr;else</strong> 就能打遍天下嘛！而喜歡 Python／Ruby 的朋友對 <code>raise</code> 和各種 Exceptions 一定不陌生，甚至 Python 底層的 iterator 都是用 <code>StopIteration</code> Exception 實作。依照各個程式語言的設計，例外處理大致分為兩類：</p>
<ul>
<li>融入一般的 control flow（Python、Ruby 之流）</li>
<li>處理特殊、不正常的情況（C++、Objective-C、C# 等）</li>
</ul>
<p>大多數程式語言，無論屬於哪一類，只要涉及例外處理，就可能出現<a href="https://stackoverflow.com/search?tab=relevance&q=exception%20performance">效能上的疑慮</a>，很難避開 <a href=https://en.wikipedia.org/wiki/Call_stack#STACK-UNWINDING>Call Stack Unwinding</a> 的問題。能改善的方法之一，就是明確定義哪些 function 能拋出例外，哪些必須拋出例外，哪些錯誤不需要拋出，而是 programmer 自己應該要 handle 的。</p>
<p>要釐清這個問題，首先要定義錯誤，程式錯誤的範疇很廣，不同的狀況有不同的應對方式，大致上可以分為以下幾種類型：</p>
<ul>
<li>
<p><strong>Simple Errors</strong></p>
<p>一些很明顯可能產生錯誤的操作，例如 type casting、parsing string to integer。這種錯誤通常很容易理解，不需要過多的描述，在 Swift 或其他語言中，一般返回 <code>nil</code>／<code>undefined</code>／<code>none</code> 等值。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>let</span> result = Int(<span style=color:#e6db74>&#34;I am not an integer, and will return an Optional&#34;</span>)
</code></pre></div></li>
<li>
<p><strong>Logical Failures</strong></p>
<p>由 programmer 產生的錯誤，我們給他一個可愛的暱稱「bug」。Swift 強大的編譯器會幫開發者檢查這些問題，減少 logical failures 的數量。</p>
</li>
<li>
<p><strong>Recoverable Errors</strong></p>
<p>導致此錯誤的原因複雜，但能夠合理預料的錯誤。例如<strong>開啟檔案</strong>，可能會有 <strong>Permission Denied</strong>、<strong>File Not Found</strong> 等不同的錯誤。這類的錯誤就是 <strong>Exceptions Handling</strong> 主要的目標。</p>
</li>
</ul>
<h2 id=swift-error-handling>Swift Error Handling<a hidden class=anchor aria-hidden=true href=#swift-error-handling>#</a></h2>
<p>Swift 在 2.0 版為了妥善處理錯誤，並避免影響效能，決定僅針對 <strong>Recoverable Error</strong> 引入 Error Handling 機制，其他系統底層／語言層的錯誤還是需要 programmer 自行避免。截至 3.1 版，相關的關鍵字如下：</p>
<ul>
<li><code>do</code></li>
<li><code>catch</code></li>
<li><code>try</code></li>
<li><code>throw</code></li>
<li><code>throws</code></li>
<li><code>rethrows</code></li>
<li><code>defer</code></li>
<li><code>Error</code></li>
</ul>
<p>Swift 的錯誤處理與主流設計大相逕庭，不幫 programmer 躲過自作孽的 <strong>Login Failure</strong>，不會 catch <strong>index out of bound</strong> 這類錯誤。實際上，Swift 的錯誤處理就只是<a href=https://andybargh.com/error-handling-in-swift/>另一種 Return Type，與相關的 Syntax Sugar</a>。其<a href=https://github.com/apple/swift/blob/master/docs/ErrorHandling.rst>設計理念／特色</a>整理如下：</p>
<ul>
<li>拋出錯誤之處需為顯式聲明。</li>
<li>函式必須顯式宣告它會<strong>拋出錯誤</strong>，讓 programmer 明確得知哪些程式該處理錯誤。</li>
<li>拋出錯誤的效能如同初始化並返回 <strong>Error</strong> 型別一樣簡單，不涉及 stack unwinding。</li>
</ul>
<p>Swift 有四種方法處理 Error：</p>
<ol>
<li>轉拋／傳遞錯誤（error propagation）。</li>
<li>使用 <strong>do-catch</strong> 陳述句處理。</li>
<li>將 Error 轉為 <strong>Optional Value</strong>（<code>try?</code>）。</li>
<li>停止錯誤傳遞（<code>try!</code>）</li>
</ol>
<p>能被拋出的錯誤需繼承 <code>Error</code> protocol，在此先定義一個錯誤類型，爾後再介紹。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>DRMError</span>: Error {
    <span style=color:#66d9ef>case</span> timeout
    <span style=color:#66d9ef>case</span> invalidHeader
    <span style=color:#66d9ef>case</span> missingParam(String)
    <span style=color:#66d9ef>case</span> responseFailure(code: Int, message: Data)
}
</code></pre></div><h3 id=propagating-errors>Propagating Errors<a hidden class=anchor aria-hidden=true href=#propagating-errors>#</a></h3>
<p>第一種處理方法：透過 <strong>throwing function</strong> 轉拋／傳遞錯誤。</p>
<p>任何一個 function、method 或 initializer 若要拋出錯誤，需在參數之後，Return Type 之前加上 <code>throws</code> 來宣告一個 <strong>throwing function</strong>，顯式聲明該函式的需要錯誤處理。並利用 <code>throw</code> 來拋出錯誤。我們可以利用這個特性，將錯誤轉拋／傳遞出去給外面的作用域。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>canThrowTimeout</span>() <span style=color:#66d9ef>throws</span> { <span style=color:#75715e>// 可以拋出錯誤</span>
    <span style=color:#66d9ef>throw</span> DRMError.timeout
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>isHeaderEmpty</span>(header: [String: Any]) <span style=color:#66d9ef>throws</span> -&gt; Bool { <span style=color:#75715e>// 可以拋出錯誤</span>
    <span style=color:#66d9ef>guard</span> header.count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>else</span> { <span style=color:#66d9ef>throw</span> DRMError.invalidHeader }
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
}

<span style=color:#75715e>// 這個函式會錯誤轉拋／傳遞出去，將錯誤處理責任轉移到調用它的作用域。</span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>throwPropagation</span>() <span style=color:#66d9ef>throws</span> {
    <span style=color:#66d9ef>throw</span> DRMError.missingParam(<span style=color:#e6db74>&#34;pubkey&#34;</span>)
    <span style=color:#66d9ef>try</span> canThrowTimeout()
}

<span style=color:#66d9ef>try</span> throwPropagation()
</code></pre></div><blockquote>
<p>調用 <strong>throwing function</strong> 時，必須在該函式前使用 <code>try</code> 顯式調用，否則編譯不會過。</p>
</blockquote>
<blockquote>
<p>我們可以把 <code>throw</code> 視為一種特殊的 <code>return</code>，專門用來返回一個 <strong>Error</strong> 實例。</p>
</blockquote>
<h3 id=using-do-catch>Using <code>do-catch</code><a hidden class=anchor aria-hidden=true href=#using-do-catch>#</a></h3>
<p>第二種處理方法：使用 <strong>do-catch</strong> 來捕獲錯誤。</p>
<p><strong>do-catch</strong> 就好比 Objective-C 的 <code>@try-@catch</code>，在 <code>do</code> 區塊內拋出的錯誤會被捕獲，並尋找對應的 <code>catch</code> 區塊來處理錯誤。用法如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>do</span> {
    <span style=color:#66d9ef>try</span> throwPropagation() <span style=color:#75715e>// 只能從用 try 標註的 throwing function 捕獲錯誤</span>
    <span style=color:#75715e>// 若調用 `catchFromThis()` 這樣的函式，未使用 `try` 標註，</span>
    <span style=color:#75715e>// 錯誤無法被捕獲（實際上也沒辦法拋出 custom error）。</span>
    <span style=color:#75715e>// ...</span>
} <span style=color:#66d9ef>catch</span> DRMError.timeout { <span style=color:#75715e>// 使用 pattern matching 捕獲特定錯誤</span>
    print(<span style=color:#e6db74>&#34;Oh No! Timeout!&#34;</span>)
} <span style=color:#66d9ef>catch</span> DRMError.missingParam(<span style=color:#66d9ef>let</span> p) <span style=color:#66d9ef>where</span> p == <span style=color:#e6db74>&#34;pubkey&#34;</span> { <span style=color:#75715e>// pattern matching + generic where clause</span>
    print(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\(</span>param<span style=color:#e6db74>)</span><span style=color:#e6db74> is missing.&#34;</span>)
} <span style=color:#66d9ef>catch</span> { <span style=color:#75715e>// 捕獲剩下的所有錯誤（類似 default），並 binding 到區域變數 `error`</span>
    print(<span style=color:#e6db74>&#34;Unexpected Error&#34;</span>)
}
</code></pre></div><p>範例中，看到了 <code>catch</code> 結合 Swift 強大的 <strong>pattern matching</strong> 來捕獲錯誤，並活用 <strong>value binding</strong> 獲取錯誤的詳細資訊。我們可以把 <code>catch</code> 看作 <strong>switch-case</strong> 來使用各種 Swift patterns 的奇技淫巧。唯一不同的是，<strong>do-catch</strong> 不需要枚舉所有可能拋出的錯誤，若有錯誤未被處理，它將會繼續傳遞到周遭的作用域。</p>
<h3 id=converting-to-optional>Converting to Optional<a hidden class=anchor aria-hidden=true href=#converting-to-optional>#</a></h3>
<p>第三種處理法：利用 <code>try?</code> 將錯誤轉換成 Optional。</p>
<p>這種作法大家應該都很能理解，直接貼官方的例子：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>someThrowingFunction</span>() <span style=color:#66d9ef>throws</span> -&gt; Int {
    <span style=color:#75715e>// ...</span>
}

<span style=color:#66d9ef>let</span> x = <span style=color:#66d9ef>try</span>? someThrowingFunction() <span style=color:#75715e>// `x` 是一個 Optional</span>

<span style=color:#66d9ef>let</span> y: Int?
<span style=color:#66d9ef>do</span> {
    y = <span style=color:#66d9ef>try</span> someThrowingFunction() <span style=color:#75715e>// 若無拋出錯誤，則將賦值給 `y`</span>
} <span style=color:#66d9ef>catch</span> {
    y = <span style=color:#66d9ef>nil</span>
}
</code></pre></div><p>透過 <code>try?</code>，將 <strong>throwing function</strong> 的錯誤轉換成 Optional 後，理所當然可以使用 Optional 的所有特性，例如 <strong>optional-binding</strong>，例如官方的範例：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fetchData</span>() -&gt; Data? {
    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> data = <span style=color:#66d9ef>try</span>? fetchDataFromDisk() { <span style=color:#66d9ef>return</span> data }
    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> data = <span style=color:#66d9ef>try</span>? fetchDataFromServer() { <span style=color:#66d9ef>return</span> data }
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}
</code></pre></div><h3 id=stopping-propagation>Stopping Propagation<a hidden class=anchor aria-hidden=true href=#stopping-propagation>#</a></h3>
<p>第四種作法：使用 <code>try!</code> 停止錯誤繼續傳遞。</p>
<p>當你<strong>非常有信心</strong>錯誤不會發生，可以使用 <code>try!</code> 停止錯誤往下傳遞。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#75715e>// 接續前一個例子</span>
<span style=color:#75715e>// `x` 是一個 Int，如果 someThrowingFunction 拋出錯誤，則會得到 runtime error。</span>
<span style=color:#66d9ef>let</span> x = <span style=color:#66d9ef>try</span>! someThrowingFunction()
</code></pre></div><h2 id=other-handling-keywords>Other Handling Keywords<a hidden class=anchor aria-hidden=true href=#other-handling-keywords>#</a></h2>
<p>到此，我們介紹了 <code>do</code>、<code>catch</code>、<code>try</code>、<code>throw</code>、<code>throws</code>，這裡接著介紹 <code>rethrows</code>、<code>defer</code> 與 <code>Error</code>。</p>
<h3 id=rethrows-your-error><code>rethrows</code> your Error<a hidden class=anchor aria-hidden=true href=#rethrows-your-error>#</a></h3>
<p><code>rethrows</code> 這個關鍵字乍看很詭異，但它並非會再拋出錯誤，如果一個函式宣告為 <code>rethrows</code>，意指</p>
<blockquote>
<p>這個 <strong>rethrowing function</strong> 只會在它的函式型別參數（function parameter）拋出錯誤時，才會拋出錯誤。</p>
</blockquote>
<p>要宣告為 <strong>rethrowing function</strong>，必須符合幾個要素：</p>
<ul>
<li>至少一個函式型別參數帶有 <strong>throwing function</strong> signature。</li>
<li>只能在 <strong>do-catch</strong> 的 <code>catch</code> 語句中使用 <code>throw</code> 拋出錯誤。</li>
<li><code>do</code> 語句中只能處理作為參數的 <strong>throwing function</strong> 拋出的錯誤。</li>
</ul>
<p>簡單的範例如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>rethrowFunction</span>(callback: () <span style=color:#66d9ef>throws</span> -&gt; Void) <span style=color:#66d9ef>rethrows</span> {
    <span style=color:#66d9ef>try</span> callback()
}

<span style=color:#66d9ef>try</span> rethrowFunction {
  <span style=color:#66d9ef>throw</span> DRMError.timeout
}
</code></pre></div><p>我們可以看到，許多與函數式程式設計相關 methods，都有帶 <code>rethrows</code> 的 signatures，例如 <code>Collection</code> 的 <code>map()</code> 與 <code>index(where:)</code>，讓處理集合時，可以將錯誤傳遞到正確的作用域。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>protocol</span> <span style=color:#a6e22e>Collection</span> : Sequence {
  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>map</span>&lt;T&gt;(<span style=color:#66d9ef>_</span> transform: (Element) <span style=color:#66d9ef>throws</span> -&gt; T) <span style=color:#66d9ef>rethrows</span> -&gt; [T]

  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>index</span>(<span style=color:#66d9ef>where</span> predicate: (<span style=color:#66d9ef>Self</span>.Iterator.Element) <span style=color:#66d9ef>throws</span> -&gt; Bool) <span style=color:#66d9ef>rethrows</span> -&gt; <span style=color:#66d9ef>Self</span>.Index?
}
</code></pre></div><h3 id=defer-your-finally><code>defer</code> Your Finally<a hidden class=anchor aria-hidden=true href=#defer-your-finally>#</a></h3>
<p>相信熟悉其他語言的童鞋，一定在想「我的 <strong>try-catch-finally</strong> 的 <code>finally</code> 呢？」，先前說過，Swift 的 error handling 只是一些甜死人的語法糖，官方並沒有特別為這個 model 增添關鍵字，而是使用大家已知的 <code>defer</code>，不懂的趕快<a href=https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/doc/uid/TP40014097-CH33-ID532>點這裡</a>惡補一下。</p>
<p>這裡寫段開檔的 pseudo code 給大家瞧瞧：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>handle</span>(fileError error: FileError) {
  <span style=color:#66d9ef>switch</span> error {
  <span style=color:#66d9ef>case</span> .notFound: print(<span style=color:#e6db74>&#34;File not found.&#34;</span>)
  <span style=color:#66d9ef>case</span> .permissionDenied: print(<span style=color:#e6db74>&#34;Permission denied&#34;</span>)
  <span style=color:#66d9ef>default</span>: print(<span style=color:#e6db74>&#34;Unknown error occurred.&#34;</span>)
  }
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>writeTo</span>(file: File, data: Data) {
    <span style=color:#66d9ef>defer</span> { close(file) } <span style=color:#75715e>// 在這個 code block 結束之前執行</span>

    <span style=color:#66d9ef>do</span> {
        <span style=color:#66d9ef>try</span> openFile(file)
    } <span style=color:#66d9ef>catch</span> <span style=color:#66d9ef>let</span> error <span style=color:#66d9ef>as</span> FileError {
        handle(fileError: error)
    } <span style=color:#66d9ef>catch</span> <span style=color:#66d9ef>_</span> { <span style=color:#75715e>// wildcard pattern without binding error value to error</span>
        print(<span style=color:#e6db74>&#34;This is not a FileError.&#34;</span>)
    }
}
</code></pre></div><h3 id=customize-your-error>Customize Your <code>Error</code><a hidden class=anchor aria-hidden=true href=#customize-your-error>#</a></h3>
<p>一開始，我們實現了一個 <code>DRMError</code> 繼承了 <code>Error</code>，讓我們自定義的錯誤能夠正確拋出。那這個 <code>Error</code> protocol 究竟葫蘆裡買啥藥？很驚人地，<code>Error</code> 是個 empty protocol，沒有任何實現，可說是名副其實的語法糖。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>protocol</span> <span style=color:#a6e22e>Error</span> {
}

<span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>Error</span> {
}

<span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>Error</span> <span style=color:#66d9ef>where</span> <span style=color:#66d9ef>Self</span>.RawValue : SignedInteger {
}

<span style=color:#66d9ef>extension</span> <span style=color:#a6e22e>Error</span> <span style=color:#66d9ef>where</span> <span style=color:#66d9ef>Self</span>.RawValue : UnsignedInteger {
}
</code></pre></div><p>由於 <strong>do-catch</strong> 和 Swift patterns 緊密結合，官方推薦使用 <code>enum</code> 客製化我們自己的 Error Type。當有特殊需求，例如 Errors 間有共享的 state 或 data 時，也可用如 <code>struct</code> 來實現自定義 Error，舉個官方的 XML Parsing 例子：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>XMLParsingError</span>: Error {
   <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>ErrorKind</span> {
       <span style=color:#66d9ef>case</span> invalidCharacter
       <span style=color:#66d9ef>case</span> mismatchedTag
       <span style=color:#66d9ef>case</span> internalError
   }

   <span style=color:#66d9ef>let</span> line: Int
   <span style=color:#66d9ef>let</span> column: Int
   <span style=color:#66d9ef>let</span> kind: ErrorKind
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>parse</span>(<span style=color:#66d9ef>_</span> source: String) <span style=color:#66d9ef>throws</span> -&gt; XMLDoc {
   <span style=color:#75715e>// ...</span>
   <span style=color:#66d9ef>throw</span> XMLParsingError(line: <span style=color:#ae81ff>19</span>, column: <span style=color:#ae81ff>5</span>, kind: .mismatchedTag)
}

<span style=color:#66d9ef>do</span> {
   <span style=color:#66d9ef>let</span> xmlDoc = <span style=color:#66d9ef>try</span> parse(myXMLData)
} <span style=color:#66d9ef>catch</span> <span style=color:#66d9ef>let</span> e <span style=color:#66d9ef>as</span> XMLParsingError {
   print(<span style=color:#e6db74>&#34;Parsing error: </span><span style=color:#e6db74>\(</span>e.kind<span style=color:#e6db74>)</span><span style=color:#e6db74> [</span><span style=color:#e6db74>\(</span>e.line<span style=color:#e6db74>)</span><span style=color:#e6db74>:</span><span style=color:#e6db74>\(</span>e.column<span style=color:#e6db74>)</span><span style=color:#e6db74>]&#34;</span>)
} <span style=color:#66d9ef>catch</span> {
   print(<span style=color:#e6db74>&#34;Other error: </span><span style=color:#e6db74>\(</span>error<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
}
</code></pre></div><p>上例可清楚呈現解析 XML 時，Error 共享類似的 states。Swift Error Protocol 設計地非常有彈性。</p>
<h2 id=notices-and-future>Notices and Future<a hidden class=anchor aria-hidden=true href=#notices-and-future>#</a></h2>
<p>Swift 的 Error Handling 設計得很現代很 functional，也讓錯誤處理不再只存在於醜陋的 code 或是不齊全的 document 中，而是提升至語言層面加以約束、保障。同時，仍有幾點需要注意、了解：</p>
<ul>
<li><code>throws</code> 關鍵字是 function type 的一部分，而 non-throwing function 是 throwing function 的 subtype，所以可以在任何宣告 throwing function 處使用 non-throwing。</li>
<li>承上，non-throwing method 可以 override throwing method，<strong>反之則否</strong>。</li>
<li><code>throw</code> 的功能類似 <code>return</code>，對 asynchronous operation 不夠友善，因此許多人 porting 等其他語言的 <code>Promise</code>/<code>Future</code> 的特性，來彌補異步錯誤處理的不足。比較知名的庫有 <a href=https://github.com/mxcl/PromiseKit>PromiseKit</a> 等（想學習 <code>Promise</code> 概念，可參考<a href=https://developers.google.com/web/fundamentals/getting-started/primers/promises>這個連結</a>）。</li>
</ul>
<p>如果未來，語言層級的平行運算（並行運算）就像<a href=https://onevcat.com/2016/12/concurrency/>這篇文章</a>所說的，會在 Swift 5 推出；如果之後 <code>async</code>／<code>await</code> 如同 <strong>ES7</strong> 一樣納入 Swift 標準，如果 actor system 真的導入 Swift 中，天知道兩年後 Swift 寫起來會有多舒服！</p>
<h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2>
<ul>
<li><a href=https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html>Swift Language Guide - Error Handling</a></li>
<li><a href=https://en.wikipedia.org/wiki/Exception_handling>Wiki - Exception Handling</a></li>
<li><a href=https://github.com/apple/swift/blob/master/docs/ErrorHandling.rst>Error Handling in Swift 2.0</a></li>
<li><a href=https://andybargh.com/error-handling-in-swift/>Andy Bargh - Error Handling in Swift</a></li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://weihanglo.tw/tags/swift/>Swift</a></li>
<li><a href=https://weihanglo.tw/tags/error-handling/>Error Handling</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://weihanglo.tw/posts/2017/swift-generics/>
<span class=title>« Prev Page</span>
<br>
<span>理解 Swift Generics</span>
</a>
<a class=next href=https://weihanglo.tw/posts/2017/fed-toolchain/>
<span class=title>Next Page »</span>
<br>
<span>大前端時代的工具箱</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>CC BY-NC-SA 4.0</span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>