<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="This is a series of quick notes about the fundamentals of the Rust programming language. It would cover parts of basic concepts and patterns in Rust. As a Rust begineer and a non-native English speaker, I may make some silly mistakes in my notes. Please contact me if there are some misleading words.
(written on 2018-09-30)
Ownership and References While a program runs, it need a way to manage memory ."><meta name=theme-color content="#ffcd00"><meta property="og:title" content="Rust: Ownership and References • Weihang Lo"><meta property="og:description" content="This is a series of quick notes about the fundamentals of the Rust programming language. It would cover parts of basic concepts and patterns in Rust. As a Rust begineer and a non-native English speaker, I may make some silly mistakes in my notes. Please contact me if there are some misleading words.
(written on 2018-09-30)
Ownership and References While a program runs, it need a way to manage memory ."><meta property="og:url" content="https://weihanglo.tw/posts/2018/rust-ownership-and-references/"><meta property="og:site_name" content="Weihang Lo"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:tag" content="Rust"><meta property="article:published_time" content="2018-09-30T11:07:45+08:00"><meta property="article:modified_time" content="2018-09-30T11:07:45+08:00"><meta name=twitter:card content="summary"><meta name=generator content="Hugo 0.74.3"><title>Rust: Ownership and References • Weihang Lo</title><link rel=canonical href=https://weihanglo.tw/posts/2018/rust-ownership-and-references/><link rel=icon href=/favicon.ico><link rel=stylesheet href=/assets/css/main.ab98e12b.css><link rel=stylesheet href=/css/custom.css><style>:root{--color-accent:#ffcd00}</style></head><body class="page type-posts"><div class=site><a class=screen-reader-text href=#content>Skip to Content</a><div class=main><nav id=main-menu class="menu main-menu" aria-label="Main Menu"><div class=container><ul><li class=item><a href=/>Home</a></li><li class=item><a href=/posts/>Posts</a></li><li class=item><a href=/tags/>Tags</a></li><li class=item><a href=/about/>About</a></li></ul></div></nav><div class=header-widgets><div class=container></div></div><header id=header class="header site-header"><div class="container sep-after"><div class=header-info><p class="site-title title">Weihang Lo</p><p class="desc site-desc"></p></div></div></header><main id=content><article lang=en class=entry><header class="header entry-header"><div class="container sep-after"><div class=header-info><h1 class=title>Rust: Ownership and References</h1></div><div class=entry-meta><span class=posted-on><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg><span class=screen-reader-text>Posted on</span>
<time class=entry-date datetime=2018-09-30T11:07:45+08:00>2018, Sep 30</time></span>
<span class=reading-time><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 15 15"/></svg>6 mins read</span></div></div></header><div class="container entry-content"><p>This is a series of quick notes about the fundamentals of <a href=https://rust-lang.org>the Rust programming language</a>. It would cover parts of basic concepts and patterns in Rust. As a Rust begineer and a non-native English speaker, I may make some silly mistakes in my notes. Please contact me if there are some misleading words.</p><p><em>(written on 2018-09-30)</em></p><h2 id=ownership-and-references>Ownership and References</h2><p>While a program runs, it need a way to manage memory . Here are three common approaches of memory management:</p><ul><li>Garbage collection. (Go, Python, Ruby, Swift)</li><li>Explicit allocation and free memory. (C, C++)</li><li>Ownership/move semantic. (Rust, C++11 move constructor)</li></ul><p>This note is about core concepts of Rust ownership and how ownership interacts with other features such as references and lifetime.</p><h2 id=ownership>Ownership</h2><h3 id=rust-ownership-rules>Rust Ownership Rules</h3><ol><li>Each value in Rust has a variable that’s called its <em>owner</em>.</li><li>There can only be one owner at a time.</li><li>When the owner goes out of scope, the value will be dropped.</li></ol><blockquote><p>Actually, you only need to remember one thing: Rust guarantees its memory safety by <strong>restricting variables from aliasing</strong>.</p></blockquote><h3 id=stack-vs-heap>Stack v.s. Heap</h3><p>To determine where to store a variable, Rust categorizes varaibles into two groups - stack and heap allocations. Here are some properties held by each procedure.</p><p><strong>Store in stack</strong></p><ul><li>Need to know the size of value at compile time.</li><li>Since the size is known, when the variable get out of scope, the compiler can free the variable automatically.</li></ul><p><strong>Store in heap</strong></p><ul><li>To store a value in heap, you need to request a region of memory from the operating system.</li><li>When cleaning up unused data, you need to explicit free the memory.</li></ul><p>As same as C++ <a href=https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization>RAII pattern</a>, Rust has a special method on object called <code>drop</code> that would be called automatically when a variable goes out of scope. For example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>{                      <span style=color:#75715e>// s is not valid here, it’s not yet declared
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello&#34;</span>;   <span style=color:#75715e>// s is valid from this point forward
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// do stuff with s
</span><span style=color:#75715e></span>}                      <span style=color:#75715e>// the scope is over. 
</span><span style=color:#75715e></span>                       <span style=color:#75715e>// `drop` is called, and s is no longer valid.
</span><span style=color:#75715e></span>
</code></pre></div><p>The question is, if a variable is allocated on heap with multiple aliases, we may not be able to track down where all aliases are in used. Explicitly call <code>drop</code> can lead some aliases to become dangling pointers or cause a double free error. And ownership to the rescue!</p><h2 id=move-clone-and-copy>Move, Clone and Copy</h2><p><strong>Move:</strong> To stop from double free errors, Rust utilize <em>move semantics</em>. If a variable is aliased to the other. You cannot access underlying value from the former variables.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> s1 <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
<span style=color:#66d9ef>let</span> s2 <span style=color:#f92672>=</span> s1;

println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;{}, world!&#34;</span>, s1); <span style=color:#75715e>// Error. Value is moved.
</span></code></pre></div><p>All the data on heap will move its ownership to <code>s2</code>. Now, <code>s1</code> is no longer available.</p><p><img src=https://doc.rust-lang.org/book/second-edition/img/trpl04-04.svg alt></p><p><strong>Clone:</strong> When you do want to keep the ownership of the variable, explicitly call <code>clone</code> may perform a deep copy.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> s1 <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
<span style=color:#66d9ef>let</span> s2 <span style=color:#f92672>=</span> s1.clone();

println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;s1 = {}, s2 = {}&#34;</span>, s1, s2);
</code></pre></div><p><img src=https://doc.rust-lang.org/book/second-edition/img/trpl04-03.svg alt></p><p><strong>Copy:</strong> Sometimes if a type implements <code>Copy</code> trait, it instead has <em>copy semantics</em>. That means <code>clone</code> would be performed automatically when aliasing variables.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> s1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>1234_</span><span style=color:#66d9ef>u8</span>;
<span style=color:#66d9ef>let</span> s2 <span style=color:#f92672>=</span> s1;

println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;s1 = {}, s2 = {}&#34;</span>, s1, s2);
<span style=color:#75715e>// s2 is an copy of s1.
</span></code></pre></div><h3 id=function-and-ownership>Function and Ownership</h3><p><strong>Function parameters:</strong> passing value to function as parameters is semantically same as assignment. For example,</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>takes_ownership</span>(some_string: String) { <span style=color:#75715e>// some_string comes into scope
</span><span style=color:#75715e></span>    println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;{}&#34;</span>, some_string);
} <span style=color:#75715e>// Here, some_string goes out of scope and `drop` is called. The backing
</span><span style=color:#75715e></span>  <span style=color:#75715e>// memory is freed.
</span></code></pre></div><p><strong>Return values:</strong> the ownership can also be transferred out to the caller.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>// takes_and_gives_back will take a String and return one
</span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>takes_and_gives_back</span>(a_string: String) -&gt; String { <span style=color:#75715e>// a_string comes into
</span><span style=color:#75715e></span>                                                      <span style=color:#75715e>// scope
</span><span style=color:#75715e></span>    a_string  <span style=color:#75715e>// a_string is returned and moves out to the calling function
</span><span style=color:#75715e></span>}
</code></pre></div><h2 id=references>References</h2><p>Ownership is about a variable owns the value. What about sharing value among multiple variables? Here comes the concepts of <em>references</em>.</p><p>The properties of Rust references are described as below:</p><ul><li>Similar behavior comparing to C pointer.</li><li>Use <code>&</code> to annotate reference type.</li><li>Use <code>*</code> to dereference.</li><li>Use <code>.</code> (dot) to access method/field under a reference to a struct/enum type.</li><li>No null pointer. Use <code>[Option](https://doc.rust-lang.org/std/option/index.html)</code> instead.</li><li>Mostly the word “<em>reference</em>” is interchangeable with “<em>borrow</em>” in Rust.</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> a: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;string&#34;</span>; 

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>calculate_length</span>(s: <span style=color:#66d9ef>&amp;</span>String) -&gt; <span style=color:#66d9ef>usize</span> { <span style=color:#75715e>// s is a reference to a String
</span><span style=color:#75715e></span>    s.len()
} <span style=color:#75715e>// Here, s goes out of scope. But because it does not have ownership of what
</span><span style=color:#75715e></span>  <span style=color:#75715e>// it refers to, nothing happens.
</span></code></pre></div><h3 id=rules>Rules</h3><p>All references in Rust must follow at lease two rules:</p><ul><li>Having several immutable references (<code>&T</code>) or exact one mutable reference (<code>&mut T</code>).</li><li>A reference must always be valid even it references to null.
(use <code>Option:None</code> to represent null)</li></ul><h3 id=lifetime>Lifetime</h3><p>A reference may be invalid and become a dangling pointer if the owner is dropped. Accessing that reference would cause a undefined behavior. To solve this kind of error, Rust introduces <strong>lifetime</strong> validation for all reference types.</p><p>Here are some characteristics of references’ lifetime:</p><ul><li>A lifetime of a reference is the scope for which the reference is valid.</li><li>Every reference in Rust has its own lifetime.</li><li>Lifetimes is a part of Rust type system. Different lifetimes are seem as different types.</li><li>In most cases, lifetimes are implicit inferred as same as how type being inferred.</li></ul><p>Rust compiler use a mechanism called <em>borrow checker</em> to determine all lifetimes of variables are valid. The following example is invalid due to <code>x</code> cannot “outlive” the outer scope which is longer than its lifetime.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>// would fail to compile
</span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> r;                <span style=color:#75715e>// ---------+-- &#39;a
</span><span style=color:#75715e></span>                          <span style=color:#75715e>//          |
</span><span style=color:#75715e></span>    {                     <span style=color:#75715e>//          |
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;        <span style=color:#75715e>// -+-- &#39;b  |
</span><span style=color:#75715e></span>        r <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>x;           <span style=color:#75715e>//  |       |
</span><span style=color:#75715e></span>    }                     <span style=color:#75715e>// -+       |
</span><span style=color:#75715e></span>                          <span style=color:#75715e>//          |
</span><span style=color:#75715e></span>    println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;r: {}&#34;</span>, r); <span style=color:#75715e>//          |
</span><span style=color:#75715e></span>}                         <span style=color:#75715e>// ---------+
</span></code></pre></div><p>To annotate lifetime of a type, Rust use quirk syntax as followings:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#f92672>&amp;</span><span style=color:#66d9ef>i32</span>        <span style=color:#75715e>// a reference
</span><span style=color:#75715e></span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>i32</span>     <span style=color:#75715e>// a reference with an explicit lifetime
</span><span style=color:#75715e></span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>i32</span> <span style=color:#75715e>// a mutable reference with an explicit lifetime
</span></code></pre></div><p>A lifetime annotation seldom appears alone. It serves as a annotations to generics to imply how references relate to each other. We will cover this part at <a href=https://weihanglo.tw/posts/rust-generics>Generics</a>.</p><h3 id=no-more-null-pointers>No More Null Pointers</h3><p>In languages with null, variables can always be in one of two states: null or not null. To ensure that accessing your references is safe, you must check whether a reference is null every time you use it.</p><p><em>Rust does not have null.</em></p><p>Sounds crazy, huh? Actually, Rust wraps null value into <code>Option&lt;T></code> type to make sure no one would access invalid reference or value. <code>Option&lt;T></code> is defined as an enum:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>    <span style=color:#66d9ef>enum</span> Option<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
        Some(T),
        None,
    }
</code></pre></div><p>To access value under an <code>Option</code> type, one needs to unwrap it instead of direct manipulation. This extra step throw out the infamous null pointer exception in many languages. For example,</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> x: <span style=color:#66d9ef>i8</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
<span style=color:#66d9ef>let</span> y: Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i8</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Some(<span style=color:#ae81ff>5</span>);

<span style=color:#66d9ef>let</span> sum <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> y; <span style=color:#75715e>// cannot compile, you need to unwrap it.
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> sum <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> y.unwrap() <span style=color:#75715e>// Valid!
</span></code></pre></div><p>With the power of pattern matching in Rust, you can even handle <code>Option</code> type more gracefully without explicit wrapping. Read more about <code>[enum](https://doc.rust-lang.org/book/second-edition/ch06-00-enums.html)</code> and <code>[Option](https://doc.rust-lang.org/std/option/enum.Option.html)</code> type.</p><h3 id=raw-pointers>Raw Pointers</h3><p>In unsafe Rust world, we have <strong>raw pointers</strong>, <code>* const T</code> and <code>*mut T</code>, to do more unsafe stuff at your will. That means raw pointers can ignore borrowing rules and is able to be null. We devote the whole <a href=https://weihanglo.tw/posts/2018/unsafe-rust>Unsafe Rust</a> post to introduce the unsafe concept.</p><h2 id=further-resources>Further Resources</h2><ul><li><a href=https://doc.rust-lang.org/book/2018-edition/index.html>The Rust Programming Language - 2018 Edition</a></li><li>Some images and code snippets are <strong>borrowed</strong> from TRPL.</li></ul></div><footer class=entry-footer><div class="container sep-before"><div class=tags><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2H12l8.59 8.59A2 2 0 0120.59 13.41z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=screen-reader-text>Tags: </span><a class=tag href=/tags/rust/>Rust</a></div></div><div style=text-align:center;padding-top:2em><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/><img src=https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png alt=cc-by-nc-sa-4></a></div></footer></article><nav class=entry-nav><div class=container><div class="prev-entry sep-before"><a href=/posts/2018/rust-vs-go/><span aria-hidden=true><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="20" y1="12" x2="4" y2="12"/><polyline points="10 18 4 12 10 6"/></svg>Previous</span>
<span class=screen-reader-text>Previous post: </span>【譯】Rust vs. Go</a></div><div class="next-entry sep-before"><a href=/posts/2019/streamin-hls/><span class=screen-reader-text>Next post: </span>HLS 串流協議二三事<span aria-hidden=true>Next<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="4" y1="12" x2="20" y2="12"/><polyline points="14 6 20 12 14 18"/></svg></span></a></div></div></nav></main><footer id=footer class=footer><div class="container sep-before"><section class="widget widget-social_menu sep-after"><nav aria-label="Social Menu"><ul><li><a href=https://github.com/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Github account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li><a href=https://facebook.com/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Facebook account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M18 2h-3a5 5 0 00-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 011-1h3z"/></svg></a></li><li><a href=https://twitter.com/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Twitter account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><title>Twitter icon</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></li><li><a href=https://linkedin.com/in/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Linkedin account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></li><li><a href=https://t.me/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Telegram account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><title>Telegram icon</title><path d="M23.91 3.79 20.3 20.84c-.25 1.21-.98 1.5-2 .94l-5.5-4.07-2.66 2.57c-.3.3-.55.56-1.1.56-.72.0-.6-.27-.84-.95L6.3 13.7l-5.45-1.7c-1.18-.35-1.19-1.16.26-1.75l21.26-8.2c.97-.43 1.9.24 1.53 1.73z"/></svg></a></li></ul></nav></section><div class=copyright><p>&copy; 2017-2021 Weihang Lo</p></div></div></footer></div></div><script>window.__assets_js_src="/assets/js/"</script><script src=/assets/js/main.c3bcf2df.js></script><script src=/js/custom.js></script></body></html>