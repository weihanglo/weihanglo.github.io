<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Rust: Ownership and References | Weihang Lo</title>
<meta name=keywords content="Rust">
<meta name=description content="This is a series of quick notes about the fundamentals of the Rust programming language. It would cover parts of basic concepts and patterns in Rust. As a Rust begineer and a non-native English speaker, I may make some silly mistakes in my notes. Please contact me if there are some misleading words.
(written on 2018-09-30)
Ownership and References While a program runs, it need a way to manage memory .">
<meta name=author content>
<link rel=canonical href=https://weihanglo.tw/posts/2018/rust-ownership-and-references/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://weihanglo.tw/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://weihanglo.tw/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://weihanglo.tw/favicon-32x32.png>
<link rel=apple-touch-icon href=https://weihanglo.tw/apple-touch-icon.png>
<link rel=mask-icon href=https://weihanglo.tw/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:!0},{left:'$',right:'$',display:!1},{left:'\\(',right:'\\)',display:!1},{left:'\\[',right:'\\]',display:!0}],throwOnError:!1})})</script>
<meta property="og:title" content="Rust: Ownership and References">
<meta property="og:description" content="This is a series of quick notes about the fundamentals of the Rust programming language. It would cover parts of basic concepts and patterns in Rust. As a Rust begineer and a non-native English speaker, I may make some silly mistakes in my notes. Please contact me if there are some misleading words.
(written on 2018-09-30)
Ownership and References While a program runs, it need a way to manage memory .">
<meta property="og:type" content="article">
<meta property="og:url" content="https://weihanglo.tw/posts/2018/rust-ownership-and-references/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2018-09-30T11:07:45+08:00">
<meta property="article:modified_time" content="2018-09-30T11:07:45+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Rust: Ownership and References">
<meta name=twitter:description content="This is a series of quick notes about the fundamentals of the Rust programming language. It would cover parts of basic concepts and patterns in Rust. As a Rust begineer and a non-native English speaker, I may make some silly mistakes in my notes. Please contact me if there are some misleading words.
(written on 2018-09-30)
Ownership and References While a program runs, it need a way to manage memory .">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://weihanglo.tw/posts/"},{"@type":"ListItem","position":3,"name":"Rust: Ownership and References","item":"https://weihanglo.tw/posts/2018/rust-ownership-and-references/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust: Ownership and References","name":"Rust: Ownership and References","description":"This is a series of quick notes about the fundamentals of the Rust programming language. It would cover parts of basic concepts and patterns in Rust. As a Rust begineer and a non-native English speaker, I may make some silly mistakes in my notes. Please contact me if there are some misleading words.\n(written on 2018-09-30)\nOwnership and References While a program runs, it need a way to manage memory .","keywords":["Rust"],"articleBody":"This is a series of quick notes about the fundamentals of the Rust programming language. It would cover parts of basic concepts and patterns in Rust. As a Rust begineer and a non-native English speaker, I may make some silly mistakes in my notes. Please contact me if there are some misleading words.\n(written on 2018-09-30)\nOwnership and References While a program runs, it need a way to manage memory . Here are three common approaches of memory management:\n Garbage collection. (Go, Python, Ruby, Swift) Explicit allocation and free memory. (C, C++) Ownership/move semantic. (Rust, C++11 move constructor)  This note is about core concepts of Rust ownership and how ownership interacts with other features such as references and lifetime.\nOwnership Rust Ownership Rules  Each value in Rust has a variable that’s called its owner. There can only be one owner at a time. When the owner goes out of scope, the value will be dropped.   Actually, you only need to remember one thing: Rust guarantees its memory safety by restricting variables from aliasing.\n Stack v.s. Heap To determine where to store a variable, Rust categorizes varaibles into two groups - stack and heap allocations. Here are some properties held by each procedure.\nStore in stack\n Need to know the size of value at compile time. Since the size is known, when the variable get out of scope, the compiler can free the variable automatically.  Store in heap\n To store a value in heap, you need to request a region of memory from the operating system. When cleaning up unused data, you need to explicit free the memory.  As same as C++ RAII pattern, Rust has a special method on object called drop that would be called automatically when a variable goes out of scope. For example:\n{ // s is not valid here, it’s not yet declared  let s = \"hello\"; // s is valid from this point forward  // do stuff with s } // the scope is over.  // `drop` is called, and s is no longer valid.  The question is, if a variable is allocated on heap with multiple aliases, we may not be able to track down where all aliases are in used. Explicitly call drop can lead some aliases to become dangling pointers or cause a double free error. And ownership to the rescue!\nMove, Clone and Copy Move: To stop from double free errors, Rust utilize move semantics. If a variable is aliased to the other. You cannot access underlying value from the former variables.\nlet s1 = String::from(\"hello\"); let s2 = s1; println!(\"{}, world!\", s1); // Error. Value is moved. All the data on heap will move its ownership to s2. Now, s1 is no longer available.\nClone: When you do want to keep the ownership of the variable, explicitly call clone may perform a deep copy.\nlet s1 = String::from(\"hello\"); let s2 = s1.clone(); println!(\"s1 = {}, s2 = {}\", s1, s2); Copy: Sometimes if a type implements Copy trait, it instead has copy semantics. That means clone would be performed automatically when aliasing variables.\nlet s1 = 1234_u8; let s2 = s1; println!(\"s1 = {}, s2 = {}\", s1, s2); // s2 is an copy of s1. Function and Ownership Function parameters: passing value to function as parameters is semantically same as assignment. For example,\nfn takes_ownership(some_string: String) { // some_string comes into scope  println!(\"{}\", some_string); } // Here, some_string goes out of scope and `drop` is called. The backing  // memory is freed. Return values: the ownership can also be transferred out to the caller.\n// takes_and_gives_back will take a String and return one fn takes_and_gives_back(a_string: String) - String { // a_string comes into  // scope  a_string // a_string is returned and moves out to the calling function } References Ownership is about a variable owns the value. What about sharing value among multiple variables? Here comes the concepts of references.\nThe properties of Rust references are described as below:\n Similar behavior comparing to C pointer. Use \u0026 to annotate reference type. Use * to dereference. Use . (dot) to access method/field under a reference to a struct/enum type. No null pointer. Use [Option](https://doc.rust-lang.org/std/option/index.html) instead. Mostly the word “reference” is interchangeable with “borrow” in Rust.  let a: \u0026str = \"string\"; fn calculate_length(s: \u0026String) - usize { // s is a reference to a String  s.len() } // Here, s goes out of scope. But because it does not have ownership of what  // it refers to, nothing happens. Rules All references in Rust must follow at lease two rules:\n Having several immutable references (\u0026T) or exact one mutable reference (\u0026mut T). A reference must always be valid even it references to null. (use Option:None to represent null)  Lifetime A reference may be invalid and become a dangling pointer if the owner is dropped. Accessing that reference would cause a undefined behavior. To solve this kind of error, Rust introduces lifetime validation for all reference types.\nHere are some characteristics of references’ lifetime:\n A lifetime of a reference is the scope for which the reference is valid. Every reference in Rust has its own lifetime. Lifetimes is a part of Rust type system. Different lifetimes are seem as different types. In most cases, lifetimes are implicit inferred as same as how type being inferred.  Rust compiler use a mechanism called borrow checker to determine all lifetimes of variables are valid. The following example is invalid due to x cannot “outlive” the outer scope which is longer than its lifetime.\n// would fail to compile fn main() { let r; // ---------+-- 'a  // |  { // |  let x = 5; // -+-- 'b |  r = \u0026x; // | |  } // -+ |  // |  println!(\"r: {}\", r); // | } // ---------+ To annotate lifetime of a type, Rust use quirk syntax as followings:\n\u0026i32 // a reference \u0026'a i32 // a reference with an explicit lifetime \u0026'a mut i32 // a mutable reference with an explicit lifetime A lifetime annotation seldom appears alone. It serves as a annotations to generics to imply how references relate to each other. We will cover this part at Generics.\nNo More Null Pointers In languages with null, variables can always be in one of two states: null or not null. To ensure that accessing your references is safe, you must check whether a reference is null every time you use it.\nRust does not have null.\nSounds crazy, huh? Actually, Rust wraps null value into Option type to make sure no one would access invalid reference or value. Option is defined as an enum:\nenum OptionT { Some(T), None, } To access value under an Option type, one needs to unwrap it instead of direct manipulation. This extra step throw out the infamous null pointer exception in many languages. For example,\nlet x: i8 = 5; let y: Optioni8 = Some(5); let sum = x + y; // cannot compile, you need to unwrap it. let sum = x + y.unwrap() // Valid! With the power of pattern matching in Rust, you can even handle Option type more gracefully without explicit wrapping. Read more about [enum](https://doc.rust-lang.org/book/second-edition/ch06-00-enums.html) and [Option](https://doc.rust-lang.org/std/option/enum.Option.html) type.\nRaw Pointers In unsafe Rust world, we have raw pointers, * const T and *mut T, to do more unsafe stuff at your will. That means raw pointers can ignore borrowing rules and is able to be null. We devote the whole Unsafe Rust post to introduce the unsafe concept.\nFurther Resources  The Rust Programming Language - 2018 Edition Some images and code snippets are borrowed from TRPL.  ","wordCount":"1266","inLanguage":"en","datePublished":"2018-09-30T11:07:45+08:00","dateModified":"2018-09-30T11:07:45+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://weihanglo.tw/posts/2018/rust-ownership-and-references/"},"publisher":{"@type":"Organization","name":"Weihang Lo","logo":{"@type":"ImageObject","url":"https://weihanglo.tw/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://weihanglo.tw accesskey=h title="Weihang Lo (Alt + H)">Weihang Lo</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://weihanglo.tw/ title=Home>
<span>Home</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/posts/ title=Posts>
<span>Posts</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Rust: Ownership and References
</h1>
<div class=post-meta><span title="2018-09-30 11:07:45 +0800 +0800">September 30, 2018</span>&nbsp;·&nbsp;6 min
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#ownership-and-references aria-label="Ownership and References">Ownership and References</a></li>
<li>
<a href=#ownership aria-label=Ownership>Ownership</a><ul>
<li>
<a href=#rust-ownership-rules aria-label="Rust Ownership Rules">Rust Ownership Rules</a></li>
<li>
<a href=#stack-vs-heap aria-label="Stack v.s. Heap">Stack v.s. Heap</a></li></ul>
</li>
<li>
<a href=#move-clone-and-copy aria-label="Move, Clone and Copy">Move, Clone and Copy</a><ul>
<li>
<a href=#function-and-ownership aria-label="Function and Ownership">Function and Ownership</a></li></ul>
</li>
<li>
<a href=#references aria-label=References>References</a><ul>
<li>
<a href=#rules aria-label=Rules>Rules</a></li>
<li>
<a href=#lifetime aria-label=Lifetime>Lifetime</a></li>
<li>
<a href=#no-more-null-pointers aria-label="No More Null Pointers">No More Null Pointers</a></li>
<li>
<a href=#raw-pointers aria-label="Raw Pointers">Raw Pointers</a></li></ul>
</li>
<li>
<a href=#further-resources aria-label="Further Resources">Further Resources</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>This is a series of quick notes about the fundamentals of <a href=https://rust-lang.org>the Rust programming language</a>. It would cover parts of basic concepts and patterns in Rust. As a Rust begineer and a non-native English speaker, I may make some silly mistakes in my notes. Please contact me if there are some misleading words.</p>
<p><em>(written on 2018-09-30)</em></p>
<h2 id=ownership-and-references>Ownership and References<a hidden class=anchor aria-hidden=true href=#ownership-and-references>#</a></h2>
<p>While a program runs, it need a way to manage memory . Here are three common approaches of memory management:</p>
<ul>
<li>Garbage collection. (Go, Python, Ruby, Swift)</li>
<li>Explicit allocation and free memory. (C, C++)</li>
<li>Ownership/move semantic. (Rust, C++11 move constructor)</li>
</ul>
<p>This note is about core concepts of Rust ownership and how ownership interacts with other features such as references and lifetime.</p>
<h2 id=ownership>Ownership<a hidden class=anchor aria-hidden=true href=#ownership>#</a></h2>
<h3 id=rust-ownership-rules>Rust Ownership Rules<a hidden class=anchor aria-hidden=true href=#rust-ownership-rules>#</a></h3>
<ol>
<li>Each value in Rust has a variable that’s called its <em>owner</em>.</li>
<li>There can only be one owner at a time.</li>
<li>When the owner goes out of scope, the value will be dropped.</li>
</ol>
<blockquote>
<p>Actually, you only need to remember one thing: Rust guarantees its memory safety by <strong>restricting variables from aliasing</strong>.</p>
</blockquote>
<h3 id=stack-vs-heap>Stack v.s. Heap<a hidden class=anchor aria-hidden=true href=#stack-vs-heap>#</a></h3>
<p>To determine where to store a variable, Rust categorizes varaibles into two groups - stack and heap allocations. Here are some properties held by each procedure.</p>
<p><strong>Store in stack</strong></p>
<ul>
<li>Need to know the size of value at compile time.</li>
<li>Since the size is known, when the variable get out of scope, the compiler can free the variable automatically.</li>
</ul>
<p><strong>Store in heap</strong></p>
<ul>
<li>To store a value in heap, you need to request a region of memory from the operating system.</li>
<li>When cleaning up unused data, you need to explicit free the memory.</li>
</ul>
<p>As same as C++ <a href=https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization>RAII pattern</a>, Rust has a special method on object called <code>drop</code> that would be called automatically when a variable goes out of scope. For example:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>{                      <span style=color:#75715e>// s is not valid here, it’s not yet declared
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello&#34;</span>;   <span style=color:#75715e>// s is valid from this point forward
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// do stuff with s
</span><span style=color:#75715e></span>}                      <span style=color:#75715e>// the scope is over. 
</span><span style=color:#75715e></span>                       <span style=color:#75715e>// `drop` is called, and s is no longer valid.
</span><span style=color:#75715e></span>
</code></pre></div><p>The question is, if a variable is allocated on heap with multiple aliases, we may not be able to track down where all aliases are in used. Explicitly call <code>drop</code> can lead some aliases to become dangling pointers or cause a double free error. And ownership to the rescue!</p>
<h2 id=move-clone-and-copy>Move, Clone and Copy<a hidden class=anchor aria-hidden=true href=#move-clone-and-copy>#</a></h2>
<p><strong>Move:</strong> To stop from double free errors, Rust utilize <em>move semantics</em>. If a variable is aliased to the other. You cannot access underlying value from the former variables.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> s1 <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
<span style=color:#66d9ef>let</span> s2 <span style=color:#f92672>=</span> s1;

println!(<span style=color:#e6db74>&#34;{}, world!&#34;</span>, s1); <span style=color:#75715e>// Error. Value is moved.
</span></code></pre></div><p>All the data on heap will move its ownership to <code>s2</code>. Now, <code>s1</code> is no longer available.</p>
<p><img loading=lazy src=https://doc.rust-lang.org/book/second-edition/img/trpl04-04.svg alt>
</p>
<p><strong>Clone:</strong> When you do want to keep the ownership of the variable, explicitly call <code>clone</code> may perform a deep copy.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> s1 <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
<span style=color:#66d9ef>let</span> s2 <span style=color:#f92672>=</span> s1.clone();

println!(<span style=color:#e6db74>&#34;s1 = {}, s2 = {}&#34;</span>, s1, s2);
</code></pre></div><p><img loading=lazy src=https://doc.rust-lang.org/book/second-edition/img/trpl04-03.svg alt>
</p>
<p><strong>Copy:</strong> Sometimes if a type implements <code>Copy</code> trait, it instead has <em>copy semantics</em>. That means <code>clone</code> would be performed automatically when aliasing variables.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> s1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>1234_</span><span style=color:#66d9ef>u8</span>;
<span style=color:#66d9ef>let</span> s2 <span style=color:#f92672>=</span> s1;

println!(<span style=color:#e6db74>&#34;s1 = {}, s2 = {}&#34;</span>, s1, s2);
<span style=color:#75715e>// s2 is an copy of s1.
</span></code></pre></div><h3 id=function-and-ownership>Function and Ownership<a hidden class=anchor aria-hidden=true href=#function-and-ownership>#</a></h3>
<p><strong>Function parameters:</strong> passing value to function as parameters is semantically same as assignment. For example,</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>takes_ownership</span>(some_string: String) { <span style=color:#75715e>// some_string comes into scope
</span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;{}&#34;</span>, some_string);
} <span style=color:#75715e>// Here, some_string goes out of scope and `drop` is called. The backing
</span><span style=color:#75715e></span>  <span style=color:#75715e>// memory is freed.
</span></code></pre></div><p><strong>Return values:</strong> the ownership can also be transferred out to the caller.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>// takes_and_gives_back will take a String and return one
</span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>takes_and_gives_back</span>(a_string: String) -&gt; String { <span style=color:#75715e>// a_string comes into
</span><span style=color:#75715e></span>                                                      <span style=color:#75715e>// scope
</span><span style=color:#75715e></span>    a_string  <span style=color:#75715e>// a_string is returned and moves out to the calling function
</span><span style=color:#75715e></span>}
</code></pre></div><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2>
<p>Ownership is about a variable owns the value. What about sharing value among multiple variables? Here comes the concepts of <em>references</em>.</p>
<p>The properties of Rust references are described as below:</p>
<ul>
<li>Similar behavior comparing to C pointer.</li>
<li>Use <code>&</code> to annotate reference type.</li>
<li>Use <code>*</code> to dereference.</li>
<li>Use <code>.</code> (dot) to access method/field under a reference to a struct/enum type.</li>
<li>No null pointer. Use <code>[Option](https://doc.rust-lang.org/std/option/index.html)</code> instead.</li>
<li>Mostly the word “<em>reference</em>” is interchangeable with “<em>borrow</em>” in Rust.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> a: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;string&#34;</span>; 

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>calculate_length</span>(s: <span style=color:#66d9ef>&amp;</span>String) -&gt; <span style=color:#66d9ef>usize</span> { <span style=color:#75715e>// s is a reference to a String
</span><span style=color:#75715e></span>    s.len()
} <span style=color:#75715e>// Here, s goes out of scope. But because it does not have ownership of what
</span><span style=color:#75715e></span>  <span style=color:#75715e>// it refers to, nothing happens.
</span></code></pre></div><h3 id=rules>Rules<a hidden class=anchor aria-hidden=true href=#rules>#</a></h3>
<p>All references in Rust must follow at lease two rules:</p>
<ul>
<li>Having several immutable references (<code>&T</code>) or exact one mutable reference (<code>&mut T</code>).</li>
<li>A reference must always be valid even it references to null.
(use <code>Option:None</code> to represent null)</li>
</ul>
<h3 id=lifetime>Lifetime<a hidden class=anchor aria-hidden=true href=#lifetime>#</a></h3>
<p>A reference may be invalid and become a dangling pointer if the owner is dropped. Accessing that reference would cause a undefined behavior. To solve this kind of error, Rust introduces <strong>lifetime</strong> validation for all reference types.</p>
<p>Here are some characteristics of references’ lifetime:</p>
<ul>
<li>A lifetime of a reference is the scope for which the reference is valid.</li>
<li>Every reference in Rust has its own lifetime.</li>
<li>Lifetimes is a part of Rust type system. Different lifetimes are seem as different types.</li>
<li>In most cases, lifetimes are implicit inferred as same as how type being inferred.</li>
</ul>
<p>Rust compiler use a mechanism called <em>borrow checker</em> to determine all lifetimes of variables are valid. The following example is invalid due to <code>x</code> cannot “outlive” the outer scope which is longer than its lifetime.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>// would fail to compile
</span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> r;                <span style=color:#75715e>// ---------+-- &#39;a
</span><span style=color:#75715e></span>                          <span style=color:#75715e>//          |
</span><span style=color:#75715e></span>    {                     <span style=color:#75715e>//          |
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;        <span style=color:#75715e>// -+-- &#39;b  |
</span><span style=color:#75715e></span>        r <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>x;           <span style=color:#75715e>//  |       |
</span><span style=color:#75715e></span>    }                     <span style=color:#75715e>// -+       |
</span><span style=color:#75715e></span>                          <span style=color:#75715e>//          |
</span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;r: {}&#34;</span>, r); <span style=color:#75715e>//          |
</span><span style=color:#75715e></span>}                         <span style=color:#75715e>// ---------+
</span></code></pre></div><p>To annotate lifetime of a type, Rust use quirk syntax as followings:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#f92672>&amp;</span><span style=color:#66d9ef>i32</span>        <span style=color:#75715e>// a reference
</span><span style=color:#75715e></span><span style=color:#f92672>&amp;&#39;</span><span style=color:#a6e22e>a</span> <span style=color:#66d9ef>i32</span>     <span style=color:#75715e>// a reference with an explicit lifetime
</span><span style=color:#75715e></span><span style=color:#f92672>&amp;&#39;</span><span style=color:#a6e22e>a</span> <span style=color:#66d9ef>mut</span> <span style=color:#66d9ef>i32</span> <span style=color:#75715e>// a mutable reference with an explicit lifetime
</span></code></pre></div><p>A lifetime annotation seldom appears alone. It serves as a annotations to generics to imply how references relate to each other. We will cover this part at <a href=https://weihanglo.tw/posts/rust-generics>Generics</a>.</p>
<h3 id=no-more-null-pointers>No More Null Pointers<a hidden class=anchor aria-hidden=true href=#no-more-null-pointers>#</a></h3>
<p>In languages with null, variables can always be in one of two states: null or not null. To ensure that accessing your references is safe, you must check whether a reference is null every time you use it.</p>
<p><em>Rust does not have null.</em></p>
<p>Sounds crazy, huh? Actually, Rust wraps null value into <code>Option&lt;T></code> type to make sure no one would access invalid reference or value. <code>Option&lt;T></code> is defined as an enum:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>    <span style=color:#66d9ef>enum</span> Option<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
        Some(T),
        None,
    }
</code></pre></div><p>To access value under an <code>Option</code> type, one needs to unwrap it instead of direct manipulation. This extra step throw out the infamous null pointer exception in many languages. For example,</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> x: <span style=color:#66d9ef>i8</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
<span style=color:#66d9ef>let</span> y: Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i8</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Some(<span style=color:#ae81ff>5</span>);

<span style=color:#66d9ef>let</span> sum <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> y; <span style=color:#75715e>// cannot compile, you need to unwrap it.
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> sum <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> y.unwrap() <span style=color:#75715e>// Valid!
</span></code></pre></div><p>With the power of pattern matching in Rust, you can even handle <code>Option</code> type more gracefully without explicit wrapping. Read more about <code>[enum](https://doc.rust-lang.org/book/second-edition/ch06-00-enums.html)</code> and <code>[Option](https://doc.rust-lang.org/std/option/enum.Option.html)</code> type.</p>
<h3 id=raw-pointers>Raw Pointers<a hidden class=anchor aria-hidden=true href=#raw-pointers>#</a></h3>
<p>In unsafe Rust world, we have <strong>raw pointers</strong>, <code>* const T</code> and <code>*mut T</code>, to do more unsafe stuff at your will. That means raw pointers can ignore borrowing rules and is able to be null. We devote the whole <a href=https://weihanglo.tw/posts/2018/unsafe-rust>Unsafe Rust</a> post to introduce the unsafe concept.</p>
<h2 id=further-resources>Further Resources<a hidden class=anchor aria-hidden=true href=#further-resources>#</a></h2>
<ul>
<li><a href=https://doc.rust-lang.org/book/2018-edition/index.html>The Rust Programming Language - 2018 Edition</a></li>
<li>Some images and code snippets are <strong>borrowed</strong> from TRPL.</li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://weihanglo.tw/tags/rust/>Rust</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://weihanglo.tw/posts/2019/streamin-hls/>
<span class=title>« Prev Page</span>
<br>
<span>HLS 串流協議二三事</span>
</a>
<a class=next href=https://weihanglo.tw/posts/2018/rust-vs-go/>
<span class=title>Next Page »</span>
<br>
<span>【譯】Rust vs. Go</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>CC BY-NC-SA 4.0</span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>