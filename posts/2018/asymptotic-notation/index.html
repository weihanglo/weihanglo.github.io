<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>漸進符號 Asymptotic Notation | Life is a refactoring process without tests</title>
<meta name=keywords content="Algorithms,Big O">
<meta name=description content="這是個人第一次撰寫 CS 基礎知識的文章，同時也是 Rust Algorithm Club 基礎概念的首篇文章，目前 Rust Algorithm Club 尚未完工，請各位敬請期待。 （撰於 2018-05-31） 日常生">
<meta name=author content>
<link rel=canonical href=https://weihanglo.tw/posts/2018/asymptotic-notation/>
<link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style>
<link rel=icon href=https://weihanglo.tw/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://weihanglo.tw/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://weihanglo.tw/favicon-32x32.png>
<link rel=apple-touch-icon href=https://weihanglo.tw/apple-touch-icon.png>
<link rel=mask-icon href=https://weihanglo.tw/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:!0},{left:'$',right:'$',display:!1},{left:'\\(',right:'\\)',display:!1},{left:'\\[',right:'\\]',display:!0}],throwOnError:!1})})</script>
<meta property="og:title" content="漸進符號 Asymptotic Notation">
<meta property="og:description" content="這是個人第一次撰寫 CS 基礎知識的文章，同時也是 Rust Algorithm Club 基礎概念的首篇文章，目前 Rust Algorithm Club 尚未完工，請各位敬請期待。 （撰於 2018-05-31） 日常生">
<meta property="og:type" content="article">
<meta property="og:url" content="https://weihanglo.tw/posts/2018/asymptotic-notation/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2018-05-31T23:38:59+08:00">
<meta property="article:modified_time" content="2018-05-31T23:38:59+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="漸進符號 Asymptotic Notation">
<meta name=twitter:description content="這是個人第一次撰寫 CS 基礎知識的文章，同時也是 Rust Algorithm Club 基礎概念的首篇文章，目前 Rust Algorithm Club 尚未完工，請各位敬請期待。 （撰於 2018-05-31） 日常生">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://weihanglo.tw/posts/"},{"@type":"ListItem","position":3,"name":"漸進符號 Asymptotic Notation","item":"https://weihanglo.tw/posts/2018/asymptotic-notation/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"漸進符號 Asymptotic Notation","name":"漸進符號 Asymptotic Notation","description":"這是個人第一次撰寫 CS 基礎知識的文章，同時也是 Rust Algorithm Club 基礎概念的首篇文章，目前 Rust Algorithm Club 尚未完工，請各位敬請期待。 （撰於 2018-05-31） 日常生","keywords":["Algorithms","Big O"],"articleBody":" 這是個人第一次撰寫 CS 基礎知識的文章，同時也是 Rust Algorithm Club 基礎概念的首篇文章，目前 Rust Algorithm Club 尚未完工，請各位敬請期待。\n （撰於 2018-05-31）\n日常生活中，你會如何描述處理事情的效率？\n「原來她五分鐘內可以吃掉一頭牛！」\n「房間這麼小你還能擺一堆雜物？還不快收拾！」\n這些描述方法，著重在處理事情的花費時間，或單位空間內的儲存量。描述演算法的效率也如此，就是「測量演算法的執行成本」，例如這個排序法花了 10 秒鐘跑完兩萬筆資料，或是這個模擬演算法很吃資源需要 32 GB 的記憶體。\n然而，在不同的機器規格、環境溫濕度、程式語言、實作方式，以及有沒有放乖乖的變異影響下，相同演算法的執行成本常常不一致。為了消弭這些外部因素，讓分析演算法能夠更科學化。科學家抽絲剝繭，發明一個方法：\n「統計演算法內所需操作步驟的數目。」\n這是最簡單，最粗淺比較不同演算法效率的作法。\n用數學表示演算法效率 「計算步驟數目」很像中小學的數學題目：某公司有三個能力相異的工程師，有的工程師一天解決一個 bug，有的工程師連續工作後效率大幅滑落。每個工程師的除蟲效率可以畫成「bug 數 - 解決 bug 所需時數」函數，橫軸為待處理的臭蟲數，縱軸為解決臭蟲所需時數，如圖一與表所示。\n   時數 \\(\\log N\\) \\(N\\) \\(N \\log N\\)     \\(N=5\\) 2.236 5 8.046   \\(N=30\\) 5.477 30 102.036    不論從圖或表，我們都可以明確看出，當 bug 數目小時，每個工程師耗時差不多；當 bug 數目成長到一定程度時，效率好與效率差的工程師差距就很明顯了。\n我們把場景拉回演算法的範疇，再闡明一次。上述的除蟲效率函數關係，可以簡單視為為「輸入資料量 - 運算成本」關係之函數。例如 \\(f(x)=x^2+3x+6\\)。當輸入資料量增大時，成本也隨之上升，這個用來描述演算法執行成本與輸入資料量之關係的函數，我們稱之為該演算法的「複雜度」。\n何謂漸進符號 了解每個演算法的時間複雜度之後，就能比較何者效率佳。但往往天不從人願，給了我們兩個演算法進行比較。\n$$f(x)=\\sqrt{\\frac{182777}{286}}\\pi x^4+5\\log_{3}^{26}88x^3-e^{777^{log_2^9}}$$\n$$g(x)=3x^6-2x^2$$\n「天啊！這樣要怎麼分析執行效率呀！」\n為了有統一的加薪標準，我們不能假定產品只會產生特定數量的臭蟲，也不能以單一天的工作表現判定員工能力，我們知道老舊系統有無限多個 bug，因此，優秀的老闆關心的是工程師長期處理「海量臭蟲」，在極限下的成長趨勢，這些成長趨勢才是衡量 KPI 的關鍵。再次強調，優秀老闆關心如何榨出是工程師的「極限成長趨勢」，而非一時半刻賣弄學識。\n同樣地，有太多因素干擾影響一個演算法的複雜度，假使我們只觀察當輸入資料量 \\(n\\) 接近無窮大時，演算法的成長趨勢為何，就很接近所謂漸進符號（asymptotic notation）的定義。漸進符號 只關心演算法在極限下的漸進行為，不同的演算法可能使用相同的漸進符號表示。\n我們比較兩個簡單函數，\\(f(x) = 10x + 29\\) 以及 \\(g(x) = x^2 + 1\\)。從圖二可以看出一開始 \\(g(x)\\) 的執行時間比 \\(f(x)\\) 多了不少，但隨著輸入資料量 \\(n\\) 增多，\\(g(x)\\) 的執行時間成長愈來愈快速，最後遠遠大於 \\(f(x)\\)。\n若以 \\(an^2 + bn + c\\) 表示複雜度，就是當存在一個 \\(a  0\\) 時，一定會有 \\(n\\) 符合 \\(an^2  bn + c\\)，這個差距隨著 \\(n\\) 越大越明顯，這是因為首項（leading term），也就是帶有最高指數的那一項，隨著 輸入大小改變，執行時間變化幅度較大。因此，可捨去複雜度函數中其他較不重要的次項與常數，留下最大次項，「透過簡單的函數來表述函數接近極限的行為」,讓複雜度函數更易理解，這就是「漸進符號」的概念。\n這裡介紹常見的幾種漸進符號：\n\\(O\\)：Big O 當我們談論演算法複雜度時，通常關心的是演算法「最糟糕的情況下」，「最多」需要執行多久。Big O 就是描述演算法複雜度上界的漸進符號，當一個演算法「實際」的複雜度（或執行成本對輸入資料量函數）為 \\(f(n)\\) 時，欲以 Big O 描述其複雜度上界時，必須滿足以下定義：\n$$f(n) = O(g(n)) \\colon {\\exists k0\\ \\exists n_0\\ \\forall nn_0\\ |f(n)| \\leq k \\cdot g(n)}$$\n假設有一演算法實際複雜度為 \\(f(n) = 3n + 4\\)，有一組 \\(k = 4;\\ g(n) = n;\\ n_0 = 4\\) 滿足\n$$\\forall n  4,\\ 0 \\leq f(n) = 3n + 4 \\leq 4n$$\n意思是「\\(f(n)\\) 的複雜度上界成長趨勢最終不會超過 \\(g(n) = 4n\\) 」，再代入 \\(O(g(n))\\)，可得演算法最差複雜度為 \\(f(n) = O(n)\\)，也就是「該演算法的成長趨勢不會比 \\(g(n)\\) 來得快」（見圖三）。\n再多看一個例子，若 \\(f(n) = 4n^2 + n\\) 有一組 \\(k = 5;\\ g(n) = n^2;\\ n_0 = 5\\) 滿足\n$$\\forall n  5,\\ 0 \\leq f(n) = 4n^2 + n \\leq 5n^2$$\n則此函數的複雜度為 \\(f(n) = O(n^2)\\)。\n 注意：也寫作 \\(f(n) \\in O(g(n))\\)，因為實際上 \\(O(g(n))\\) 是所以可描述演算法成長趨勢，並滿足上述條件的函數之「集合」。\n \\(\\Omega\\)：Big Omega 相較於 Big O 描述演算法成長趨勢的上界，Big Omega 則是對應成長趨勢的「下界」，定義如下：\n$$f(n) = \\Omega(g(n)) \\colon {\\exists k0\\ \\exists n_0\\ \\forall nn_0\\ |f(n)| \\geq k \\cdot g(n)}$$\n以 \\(f(n) = 3n + 4\\) 為例，有一組 \\(k = 2;\\ g(n) = n;\\ n_0 = 0\\) 滿足上式，因此這個演算法在輸入資料夠大時，「至少」會達到 \\(\\Omega(n)\\) 的複雜度，也就是「該演算法的成長趨勢不會比 \\(g(n)\\) 來得慢」。\n\\(\\Theta\\)：Big Theta Big Theta 則是 Big O 與 Big Omega 兩個漸進上下界所夾出的範圍，表示該演算法在輸入資料夠大時，最終的複雜度會成長到這個範圍中。其定義如下：\n$$f(n) = \\Theta(g(n)) \\colon {\\exists k_10\\ \\exists k_20\\ \\exists n_0\\ \\forall nn_0\\ k_1 \\cdot g(n) \\leq |f(n)| \\leq k_2 \\cdot g(n)}$$\n繼續以 \\(f(n) = 3n + 4\\) 為例，同樣有一組 \\(k_1 = 1;\\ k_2 = 5;\\ g(n) = n;\\ n_0 = 2\\)，滿足\n$$\\forall n \\geq 2,\\ n \\leq f(n) = 3n + 4 \\leq 5n$$\n可得知，\\(f(n) = 3n + 4 \\in \\Theta(n)\\)，表示「該演算法的成長趨勢與 \\(g(n) = n\\) 相同」（見圖四）。\n常見的複雜度 看完了讓人昏昏欲睡的數學定義，現在來認識一些常見的複雜度，從最快最有效率，到最慢最拖台錢的通通一起認識。\n \\(O(1)\\)：常數時間，演算法執行時間與資料量毫無瓜葛。例如讀取 array 首個元素。 \\(O(\\log n)\\)：執行時間隨資料量呈對數比例成長。常見的例子是二元搜索（Binary search）。 \\(O(n)\\)：執行時間隨資料量呈線性成長，例如在無序的 array 中尋找特定值。 \\(O(n \\log n)\\)：執行時間隨資料量呈線性對數成長，常見的合併排序（Mergesort）的複雜度即如斯。 \\(O(n^2)\\)：執行時間隨資料量呈平方成長，例如一些效率不彰的排序法如氣泡排序（Bubble sort）。 \\(O(n^3)\\)：執行時間隨資料量呈立方成長，常見例子為 naïve 實作的矩陣乘法。 \\(O(c^n)\\)：執行時間隨資料量呈指數成長。 \\(O(n!)\\)：執行時間隨資料量呈階乘成長，大部分情況下，這是非常差勁的複雜度。  若想一窺各種常見演算法的複雜度，可以參考這個最全面的 Big-O Cheat Sheet，圖表非常精美直觀！\n 再次強調，漸進符號也可以代表其他執行成本如記憶體空間，並不一定代表執行時間。\n  其他的漸進符號還有 little-o、little-omega 等等，有興趣的朋友可以參考文末的資料。\n 你可能不適合漸進符號 善用漸進符號，可以讓原本複雜艱澀的實際複雜度，簡化至人類容易理解的簡單數學符號，也讓分析演算法效率更為客觀。但實際上，漸進符號省略了常數項與低次項，僅保留最高次項，這種「漸進行為下」的效能表現，在真實世界中，若輸入資料量不夠大，實際複雜度的低次項係數又比高次項大上許多，很可能這個演算法實際上根本沒辦法使用。\n另外，漸進符號僅考慮最差與最佳複雜度，沒有考慮到平均複雜度。舉例來說，Quicksort 最差複雜度為 \\(O(n^2)\\)，乍看之下不是很理想，但這種情況非常稀少；其平均複雜度落在 \\(O(n \\log n)\\)，且其係數相對較低，額外開銷少，自然成為最熱門的排序法之一。\n還有，漸進符號也沒有考慮到不同語言、平台的基礎操作開銷，例如實作排序法時，有些語言「比較」兩個元素的開銷比「置換」來得大，實作上就需要盡量減少置換元素。同樣的，CPU 快取也非常容易忽略，一些快速的搜尋法很可能因為不是線性搜尋，沒辦法充分利用 CPU cache，效能不一定理想。\n總之，漸進符號只能告訴你「當輸入資料量夠大時，演算法的複雜度表現如何」，並不總是適用每個情境，端看你怎麼使用他。\n參考資料  Wiki: Time complexity Wiki: Big O notation Brilliant: Big O Notation Infinite Loop: Complexity Analysis  ","wordCount":"3157","inLanguage":"en","datePublished":"2018-05-31T23:38:59+08:00","dateModified":"2018-05-31T23:38:59+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://weihanglo.tw/posts/2018/asymptotic-notation/"},"publisher":{"@type":"Organization","name":"Life is a refactoring process without tests","logo":{"@type":"ImageObject","url":"https://weihanglo.tw/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://weihanglo.tw accesskey=h title="Life is a refactoring process without tests (Alt + H)">Life is a refactoring process without tests</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=https://weihanglo.tw/ title=Home>
<span>Home</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
漸進符號 Asymptotic Notation
</h1>
<div class=post-meta><span title="2018-05-31 23:38:59 +0800 +0800">May 31, 2018</span>&nbsp;·&nbsp;7 min
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e7%94%a8%e6%95%b8%e5%ad%b8%e8%a1%a8%e7%a4%ba%e6%bc%94%e7%ae%97%e6%b3%95%e6%95%88%e7%8e%87 aria-label=用數學表示演算法效率>用數學表示演算法效率</a></li>
<li>
<a href=#%e4%bd%95%e8%ac%82%e6%bc%b8%e9%80%b2%e7%ac%a6%e8%99%9f aria-label=何謂漸進符號>何謂漸進符號</a><ul>
<li>
<a href=#obig-o aria-label="\(O\)：Big O">\(O\)：Big O</a></li>
<li>
<a href=#omegabig-omega aria-label="\(\Omega\)：Big Omega">\(\Omega\)：Big Omega</a></li>
<li>
<a href=#thetabig-theta aria-label="\(\Theta\)：Big Theta">\(\Theta\)：Big Theta</a></li></ul>
</li>
<li>
<a href=#%e5%b8%b8%e8%a6%8b%e7%9a%84%e8%a4%87%e9%9b%9c%e5%ba%a6 aria-label=常見的複雜度>常見的複雜度</a></li>
<li>
<a href=#%e4%bd%a0%e5%8f%af%e8%83%bd%e4%b8%8d%e9%81%a9%e5%90%88%e6%bc%b8%e9%80%b2%e7%ac%a6%e8%99%9f aria-label=你可能不適合漸進符號>你可能不適合漸進符號</a></li>
<li>
<a href=#%e5%8f%83%e8%80%83%e8%b3%87%e6%96%99 aria-label=參考資料>參考資料</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><blockquote>
<p>這是個人第一次撰寫 CS 基礎知識的文章，同時也是 <a href=https://weihanglo.tw/rust-algorithm-club>Rust Algorithm Club</a> 基礎概念的首篇文章，目前 Rust Algorithm Club 尚未完工，請各位敬請期待。</p>
</blockquote>
<p><em>（撰於 2018-05-31）</em></p>
<p>日常生活中，你會如何描述處理事情的效率？</p>
<p>「原來她五分鐘內可以吃掉一頭牛！」</p>
<p>「房間這麼小你還能擺一堆雜物？還不快收拾！」</p>
<p>這些描述方法，著重在處理事情的花費時間，或單位空間內的儲存量。描述演算法的效率也如此，就是「測量演算法的執行成本」，例如這個排序法花了 10 秒鐘跑完兩萬筆資料，或是這個模擬演算法很吃資源需要 32 GB 的記憶體。</p>
<p>然而，在不同的機器規格、環境溫濕度、程式語言、實作方式，以及有沒有放乖乖的變異影響下，相同演算法的執行成本常常不一致。為了消弭這些外部因素，讓分析演算法能夠更科學化。科學家抽絲剝繭，發明一個方法：</p>
<p><strong>「統計演算法內所需操作步驟的數目。」</strong></p>
<p>這是最簡單，最粗淺比較不同演算法效率的作法。</p>
<h2 id=用數學表示演算法效率>用數學表示演算法效率<a hidden class=anchor aria-hidden=true href=#用數學表示演算法效率>#</a></h2>
<p>「計算步驟數目」很像中小學的數學題目：某公司有三個能力相異的工程師，有的工程師一天解決一個 bug，有的工程師連續工作後效率大幅滑落。每個工程師的除蟲效率可以畫成「bug 數 - 解決 bug 所需時數」函數，橫軸為待處理的臭蟲數，縱軸為解決臭蟲所需時數，如圖一與表所示。</p>
<table>
<thead>
<tr>
<th>時數</th>
<th>\(\log N\)</th>
<th>\(N\)</th>
<th>\(N \log N\)</th>
</tr>
</thead>
<tbody>
<tr>
<td>\(N=5\)</td>
<td>2.236</td>
<td>5</td>
<td>8.046</td>
</tr>
<tr>
<td>\(N=30\)</td>
<td>5.477</td>
<td>30</td>
<td>102.036</td>
</tr>
</tbody>
</table>
<p><img loading=lazy src=fig1.png alt="Fig. 1">
</p>
<p>不論從圖或表，我們都可以明確看出，當 bug 數目小時，每個工程師耗時差不多；當 bug 數目成長到一定程度時，效率好與效率差的工程師差距就很明顯了。</p>
<p>我們把場景拉回演算法的範疇，再闡明一次。上述的除蟲效率函數關係，可以簡單視為為「輸入資料量 - 運算成本」關係之函數。例如 \(f(x)=x^2+3x+6\)。當輸入資料量增大時，成本也隨之上升，這個用來描述演算法執行成本與輸入資料量之關係的函數，我們稱之為該演算法的「複雜度」。</p>
<h2 id=何謂漸進符號>何謂漸進符號<a hidden class=anchor aria-hidden=true href=#何謂漸進符號>#</a></h2>
<p>了解每個演算法的時間複雜度之後，就能比較何者效率佳。但往往天不從人願，給了我們兩個演算法進行比較。</p>
<p>$$f(x)=\sqrt{\frac{182777}{286}}\pi x^4+5\log_{3}^{26}88x^3-e^{777^{log_2^9}}$$</p>
<p>$$g(x)=3x^6-2x^2$$</p>
<p>「天啊！這樣要怎麼分析執行效率呀！」</p>
<p>為了有統一的加薪標準，我們不能假定產品只會產生特定數量的臭蟲，也不能以單一天的工作表現判定員工能力，我們知道老舊系統有無限多個 bug，因此，優秀的老闆關心的是工程師長期處理「海量臭蟲」，在極限下的<strong>成長趨勢</strong>，這些成長趨勢才是衡量 KPI 的關鍵。再次強調，優秀老闆關心如何榨出是工程師的「極限成長趨勢」，而非一時半刻賣弄學識。</p>
<p>同樣地，有太多因素干擾影響一個演算法的複雜度，假使我們只觀察當輸入資料量 \(n\) 接近無窮大時，演算法的成長趨勢為何，就很接近所謂漸進符號（asymptotic notation）的定義。漸進符號 只關心演算法在極限下的漸進行為，不同的演算法可能使用相同的漸進符號表示。</p>
<p>我們比較兩個簡單函數，\(f(x) = 10x + 29\) 以及 \(g(x) = x^2 + 1\)。從圖二可以看出一開始 \(g(x)\) 的執行時間比 \(f(x)\) 多了不少，但隨著輸入資料量 \(n\) 增多，\(g(x)\) 的執行時間成長愈來愈快速，最後遠遠大於 \(f(x)\)。</p>
<p><img loading=lazy src=fig2.png alt="Fig. 2">
</p>
<p>若以 \(an^2 + bn + c\) 表示複雜度，就是當存在一個 \(a > 0\) 時，一定會有 \(n\) 符合 \(an^2 > bn + c\)，這個差距隨著 \(n\) 越大越明顯，這是因為首項（leading term），也就是帶有最高指數的那一項，隨著 輸入大小改變，執行時間變化幅度較大。因此，可捨去複雜度函數中其他較不重要的次項與常數，留下最大次項，「<strong>透過簡單的函數來表述函數接近極限的行為</strong>」,讓複雜度函數更易理解，這就是「漸進符號」的概念。</p>
<p>這裡介紹常見的幾種漸進符號：</p>
<h3 id=obig-o>\(O\)：Big O<a hidden class=anchor aria-hidden=true href=#obig-o>#</a></h3>
<p>當我們談論演算法複雜度時，通常關心的是演算法「最糟糕的情況下」，「最多」需要執行多久。Big O 就是描述演算法複雜度上界的漸進符號，當一個演算法「實際」的複雜度（或執行成本對輸入資料量函數）為 \(f(n)\) 時，欲以 Big O 描述其複雜度上界時，必須滿足以下定義：</p>
<p>$$f(n) = O(g(n)) \colon {\exists k>0\ \exists n_0\ \forall n>n_0\ |f(n)| \leq k \cdot g(n)}$$</p>
<p>假設有一演算法實際複雜度為 \(f(n) = 3n + 4\)，有一組 \(k = 4;\ g(n) = n;\ n_0 = 4\) 滿足</p>
<p>$$\forall n > 4,\ 0 \leq f(n) = 3n + 4 \leq 4n$$</p>
<p>意思是「\(f(n)\) 的複雜度上界成長趨勢最終不會超過 \(g(n) = 4n\) 」，再代入 \(O(g(n))\)，可得演算法最差複雜度為 \(f(n) = O(n)\)，也就是「該演算法的成長趨勢不會比 \(g(n)\) 來得快」（見圖三）。</p>
<p><img loading=lazy src=fig3.png alt="Fig. 3">
</p>
<p>再多看一個例子，若 \(f(n) = 4n^2 + n\) 有一組 \(k = 5;\ g(n) = n^2;\ n_0 = 5\) 滿足</p>
<p>$$\forall n > 5,\ 0 \leq f(n) = 4n^2 + n \leq 5n^2$$</p>
<p>則此函數的複雜度為 \(f(n) = O(n^2)\)。</p>
<blockquote>
<p>注意：也寫作 \(f(n) \in O(g(n))\)，因為實際上 \(O(g(n))\) 是所以可描述演算法成長趨勢，並滿足上述條件的函數之「集合」。</p>
</blockquote>
<h3 id=omegabig-omega>\(\Omega\)：Big Omega<a hidden class=anchor aria-hidden=true href=#omegabig-omega>#</a></h3>
<p>相較於 Big O 描述演算法成長趨勢的上界，Big Omega 則是對應成長趨勢的「下界」，定義如下：</p>
<p>$$f(n) = \Omega(g(n)) \colon {\exists k>0\ \exists n_0\ \forall n>n_0\ |f(n)| \geq k \cdot g(n)}$$</p>
<p>以 \(f(n) = 3n + 4\) 為例，有一組 \(k = 2;\ g(n) = n;\ n_0 = 0\) 滿足上式，因此這個演算法在輸入資料夠大時，「至少」會達到 \(\Omega(n)\) 的複雜度，也就是「該演算法的成長趨勢不會比 \(g(n)\) 來得慢」。</p>
<h3 id=thetabig-theta>\(\Theta\)：Big Theta<a hidden class=anchor aria-hidden=true href=#thetabig-theta>#</a></h3>
<p>Big Theta 則是 Big O 與 Big Omega 兩個漸進上下界所夾出的範圍，表示該演算法在輸入資料夠大時，最終的複雜度會成長到這個範圍中。其定義如下：</p>
<p>$$f(n) = \Theta(g(n)) \colon {\exists k_1>0\ \exists k_2>0\ \exists n_0\ \forall n>n_0\ k_1 \cdot g(n) \leq |f(n)| \leq k_2 \cdot g(n)}$$</p>
<p>繼續以 \(f(n) = 3n + 4\) 為例，同樣有一組 \(k_1 = 1;\ k_2 = 5;\ g(n) = n;\ n_0 = 2\)，滿足</p>
<p>$$\forall n \geq 2,\ n \leq f(n) = 3n + 4 \leq 5n$$</p>
<p>可得知，\(f(n) = 3n + 4 \in \Theta(n)\)，表示「該演算法的成長趨勢與 \(g(n) = n\) 相同」（見圖四）。</p>
<p><img loading=lazy src=fig4.png alt="Fig. 4">
</p>
<h2 id=常見的複雜度>常見的複雜度<a hidden class=anchor aria-hidden=true href=#常見的複雜度>#</a></h2>
<p>看完了讓人昏昏欲睡的數學定義，現在來認識一些常見的複雜度，從最快最有效率，到最慢最拖台錢的通通一起認識。</p>
<ul>
<li>\(O(1)\)：常數時間，演算法執行時間與資料量毫無瓜葛。例如讀取 array 首個元素。</li>
<li>\(O(\log n)\)：執行時間隨資料量呈對數比例成長。常見的例子是<a href=https://weihanglotw/rust-algorithm-club/searching/binary_search>二元搜索（Binary search）</a>。</li>
<li>\(O(n)\)：執行時間隨資料量呈線性成長，例如在無序的 array 中尋找特定值。</li>
<li>\(O(n \log n)\)：執行時間隨資料量呈線性對數成長，常見的<a href=https://weihanglo.tw/rust-algorithm-club/sorting/mergesort/>合併排序（Mergesort）</a>的複雜度即如斯。</li>
<li>\(O(n^2)\)：執行時間隨資料量呈平方成長，例如一些效率不彰的排序法如<a href=https://weihanglo.tw/rust-algorithm-club/sorting/bubble_sort/>氣泡排序（Bubble sort）</a>。</li>
<li>\(O(n^3)\)：執行時間隨資料量呈立方成長，常見例子為 naïve 實作的矩陣乘法。</li>
<li>\(O(c^n)\)：執行時間隨資料量呈指數成長。</li>
<li>\(O(n!)\)：執行時間隨資料量呈階乘成長，大部分情況下，這是非常差勁的複雜度。</li>
</ul>
<p>若想一窺各種常見演算法的複雜度，可以參考這個最全面的 <a href=http://bigocheatsheet.com/>Big-O Cheat Sheet</a>，圖表非常精美直觀！</p>
<blockquote>
<p>再次強調，漸進符號也可以代表其他執行成本如記憶體空間，並不一定代表執行時間。</p>
</blockquote>
<blockquote>
<p>其他的漸進符號還有 little-o、little-omega 等等，有興趣的朋友可以參考文末的資料。</p>
</blockquote>
<h2 id=你可能不適合漸進符號>你可能不適合漸進符號<a hidden class=anchor aria-hidden=true href=#你可能不適合漸進符號>#</a></h2>
<p>善用漸進符號，可以讓原本複雜艱澀的實際複雜度，簡化至人類容易理解的簡單數學符號，也讓分析演算法效率更為客觀。但實際上，漸進符號省略了常數項與低次項，僅保留最高次項，這種「漸進行為下」的效能表現，在真實世界中，若輸入資料量不夠大，實際複雜度的低次項係數又比高次項大上許多，很可能這個演算法實際上根本沒辦法使用。</p>
<p>另外，漸進符號僅考慮最差與最佳複雜度，沒有考慮到平均複雜度。舉例來說，<a href=https://weihanglo.tw/rust-algorithm-club/sorting/quicksort/>Quicksort</a> 最差複雜度為 \(O(n^2)\)，乍看之下不是很理想，但這種情況非常稀少；其平均複雜度落在 \(O(n \log n)\)，且其係數相對較低，額外開銷少，自然成為最熱門的排序法之一。</p>
<p>還有，漸進符號也沒有考慮到不同語言、平台的基礎操作開銷，例如實作排序法時，有些語言「比較」兩個元素的開銷比「置換」來得大，實作上就需要盡量減少置換元素。同樣的，CPU 快取也非常容易忽略，一些快速的搜尋法很可能因為不是<a href=https://weihanglo.tw/rust-algorithm-club/searching/linear_search/>線性搜尋</a>，沒辦法充分利用 CPU cache，效能不一定理想。</p>
<p>總之，漸進符號只能告訴你「當輸入資料量夠大時，演算法的複雜度表現如何」，並不總是適用每個情境，端看你怎麼使用他。</p>
<h2 id=參考資料>參考資料<a hidden class=anchor aria-hidden=true href=#參考資料>#</a></h2>
<ul>
<li><a href=https://en.wikipedia.org/wiki/Time_complexity>Wiki: Time complexity</a></li>
<li><a href=https://en.wikipedia.org/wiki/Big_O_notation>Wiki: Big O notation</a></li>
<li><a href=https://brilliant.org/wiki/big-o-notation/>Brilliant: Big O Notation</a></li>
<li><a href=http://program-lover.blogspot.com/2008/10/complexity-analysis.html>Infinite Loop: Complexity Analysis</a></li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://weihanglo.tw/tags/algorithms/>Algorithms</a></li>
<li><a href=https://weihanglo.tw/tags/big-o/>Big O</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://weihanglo.tw/posts/2018/4-podcasts-software-engineers-may-love/>
<span class=title>« Prev</span>
<br>
<span>4 Podcasts Software Engineers May Love</span>
</a>
<a class=next href=https://weihanglo.tw/posts/2018/2018-interviews/>
<span class=title>Next »</span>
<br>
<span>2018 前端工程師面試心得</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>CC BY-NC-SA 4.0</span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>