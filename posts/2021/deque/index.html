<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>雙端佇列 Deque | Life is a refactoring process without tests</title>
<meta name=keywords content="Algorithms">
<meta name=description content="本篇從 Rust Algorithm Club 移植，若欲閱讀最新版，請移駕至Rust 演算法俱樂部：雙端佇列 Deque 一文，此文不同步更新。 雙端佇列（double-ended queue">
<meta name=author content>
<link rel=canonical href=https://weihanglo.tw/posts/2021/deque/>
<link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style>
<link rel=icon href=https://weihanglo.tw/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://weihanglo.tw/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://weihanglo.tw/favicon-32x32.png>
<link rel=apple-touch-icon href=https://weihanglo.tw/apple-touch-icon.png>
<link rel=mask-icon href=https://weihanglo.tw/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:!0},{left:'$',right:'$',display:!1},{left:'\\(',right:'\\)',display:!1},{left:'\\[',right:'\\]',display:!0}],throwOnError:!1})})</script>
<meta property="og:title" content="雙端佇列 Deque">
<meta property="og:description" content="本篇從 Rust Algorithm Club 移植，若欲閱讀最新版，請移駕至Rust 演算法俱樂部：雙端佇列 Deque 一文，此文不同步更新。 雙端佇列（double-ended queue">
<meta property="og:type" content="article">
<meta property="og:url" content="https://weihanglo.tw/posts/2021/deque/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-02-16T00:00:00+08:00">
<meta property="article:modified_time" content="2021-02-16T00:00:00+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="雙端佇列 Deque">
<meta name=twitter:description content="本篇從 Rust Algorithm Club 移植，若欲閱讀最新版，請移駕至Rust 演算法俱樂部：雙端佇列 Deque 一文，此文不同步更新。 雙端佇列（double-ended queue">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://weihanglo.tw/posts/"},{"@type":"ListItem","position":3,"name":"雙端佇列 Deque","item":"https://weihanglo.tw/posts/2021/deque/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"雙端佇列 Deque","name":"雙端佇列 Deque","description":"本篇從 Rust Algorithm Club 移植，若欲閱讀最新版，請移駕至Rust 演算法俱樂部：雙端佇列 Deque 一文，此文不同步更新。 雙端佇列（double-ended queue","keywords":["Algorithms"],"articleBody":" 本篇從 Rust Algorithm Club 移植，若欲閱讀最新版，請移駕至Rust 演算法俱樂部：雙端佇列 Deque 一文，此文不同步更新。\n 雙端佇列（double-ended queue，通常縮寫為 deque）是一般化（generalize）的佇列或堆疊。比起佇列只能「先進先出 FIFO」，以及堆疊只有「後進先出 LIFO」，雙端佇列可以從最前端或最末端任意方向，在常數時間複雜度內增刪元素，更為方便。\n雙端佇列常見用動態陣列或是鏈結串列實作，動態陣列的實作會因空間不夠，需要重新配置記憶體，但通常會支援隨機存取（random access）；鏈結串列的實作版本雖無法隨機存取，相對地增刪元素不需記憶體重配置。\n雙端佇列顯著的缺點是：無論以動態陣列或連結串列實作，基本款實作通常無法在 $O(k)$ 時間複雜度的情況下，選定範圍內 k 個元素並取得單一切片（slice）。這肇因於動態陣列的實作通常內部儲存空間經過多次增刪，空間利用會不連續；而用鏈結串列實作者，則因不支援隨機存取而無法達到相應的複雜度。\n 本次實作的程式碼置於在 rust_algorithm_club::collections::Deque API 文件中。\n 架構設計 雙端佇列有個實作重點：可在常數時間從頭尾兩端增刪元素。在資料結構設計上，會儲存分別指向頭尾的兩個指標，長相可能如下：\nstruct Deque { head: usize, tail: usize, storage: SomeStorageType, } 第一直覺肯定是選用雙向鏈結串列可以雙向增刪節點的特性，作為解決方案。不過這裡我們採用動態陣列實作，更精確來說，底層儲存容器同樣是有兩個分別指向頭尾的指標的「環形緩衝區（Ring buffer）」。\n環形緩衝區 環形緩衝區（Ring buffer） 是一個長度大小固定的緩衝區，可以視為頭尾相連的記憶體區塊，上圖雖以環狀呈現，但在計算機架構中儲存方式通常是線性陣列，再搭配指向頭端的 head 與指向尾端的 tail 兩個指標構成。\n環形緩衝區有分兩種，一種是有循環的，緩衝區寫滿了就覆蓋尾端舊的資料，另一種是不會循環，緩衝區會放滿的，後者就是本次實作會用到的，以下將來探討：\n 如何表示環形緩衝區為空 如何表示環形緩衝區已滿 環形緩衝區如何增加元素  這節以 ASCII chart 表示之。\n h: head t: tail x: no data [number]: has data  下面一個容量為 8，尚未有任何元素存入的環形緩衝區，這裡觀察到，若 head 與 tail 指向的儲存單元相同，換句話說兩者索引值相同，則緩衝區為空。\nscenario: empty buffer h t --------------- x x x x x x x x --------------- 再來，從頭端增加一個元素，此時 head 指向的儲存單元會存入元素，並且 head 索引加一。\nscenario: add one data onto head t h --------------- 1 x x x x x x x --------------- 我們再連續加幾個元素，可以觀察到，head 最終指向的儲存單元永遠為空：\nscenario: add more data onto head t h --------------- 1 2 x x x x x x --------------- t h --------------- 1 2 3 x x x x x --------------- t h --------------- 1 2 3 4 x x x x --------------- 再來，我們從尾端增加元素，首先 tail 減一，並在移動過後的 tail 指向的儲存單元放入元素。因為 tail 原本為 0，減一之後為 -1，但索引不該有 -1，所以我們採取類似環繞算術運算（wrapping arithmetic operation）處理整數溢位，因此 tail 索引從 0 變成 7（總共 8 個儲存單元）。\nscenario: add data onto tail h t --------------- 1 2 3 4 x x x 5 ---------------  日常生活中，環繞算術運算可見於汽車儀錶板或是電錶，9999 轉過頭後會自動變成 0000，可以想像成在萬分位進位了，但我們看不到。上述減一也可以想像二進位退一位，但我們看不到，所以從 0b000（0）變成了 0b111（7）。\n 我們從尾端加更多資料到緩衝區：\nscenario: add more data onto tail h t --------------- 1 2 3 4 x x 6 5 --------------- h t --------------- 1 2 3 4 x 7 6 5 -- full --------------- 欸，怎麼加到第七個就停了？\n由於目前僅探討不循環的環形緩衝區，已經規範 head = tail 代表緩衝區為空，如果貿然加上第八個元素，就無法分辨緩衝區是空是滿，恐導致轉盈為空。所以當緩衝區容量減去元素個數為 1 時，換句話說就是當剩餘最後一個空儲存單元時，表示該緩衝區已滿，不能再增加元素。由此推論環形緩衝區永遠會剩下一個沒使用的儲存單元。\n至此，環形緩衝區的特性很符合雙端佇列的需求，總結一下：\n head = tail 時，表示緩衝區為空。 容量僅剩一個儲存單元時，表示緩衝區已滿。 head 永遠指向一個空的儲存單元。 邏輯索引的映射會利用環繞算術運算配合模除運算，將索引值限制在緩衝區範圍內。  第四點很難懂齁？免驚，下面實作範例「邏輯索引映射」段落就會解釋給你聽！\n手動配置記憶體 這一段，我們將為環形緩衝區打造屬於它自己的底層儲存空間。你可能想問，既然環形緩衝區是一個固定長度的陣列，為什麼不直接利用 Rust 標準函式庫的 Vec 呢？因為 Vec 的容量和記憶體配置屬於實作細節，雖然目前是滿了才擴充容量重新配置空間，但難保未來改變，為了更細緻控制記憶體，決定弄髒手，自行配置記憶體。\n ⚠️ 以下範例有 unsafe 程式碼，未經審計，請謹慎使用。\n 首先，宣告一個 RawVec 結構體，儲存了兩個欄位：\n ptr：指向陣列最前端的指標，因為底層陣列會變化，所以是可變裸指標 *mut T。 cap：當前 RawVec 的容量。注意，容量需永遠大於等於元數個數，否則會發生緩衝區溢位。  struct RawVecT { ptr: *mut T, cap: usize, } 接下來，我們要為 RawVec 實作三個方法，完成自我管理記憶體的偉大志向：\n with_capacity：建立指定容量的 RawVec，會在堆疊上配置一塊記憶體。 try_grow：嘗試將 RawVec 的容量加倍，會觸發記憶體的重新配置。 drop：實作 Drop 特徵，會釋放在堆疊上手動配置的記憶體。  先來看 with_capacity：\nimplT RawVecT { // ...  pub fn with_capacity(cap: usize) - Self { let layout = Layout::array::T(cap).unwrap(); // 1  // 2  if layout.size() == 0 { // This is safe for zero sized types. However, be careful when facing  // zero capacity layouts. It must be replaced with an actual pointer  // before operations such as dereference or read/write.  let ptr = ptr::NonNull::dangling().as_ptr(); // 3  Self { ptr, cap: 0 } } else { // This is safe because it conforms to the [safety contracts][1].  //  // [1]: https://doc.rust-lang.org/1.49.0/alloc/alloc/trait.GlobalAlloc.html#safety-1  let ptr = unsafe { alloc(layout) }; // 4  if ptr.is_null() { handle_alloc_error(layout); } Self { ptr: ptr.cast(), cap, } } } }  首先，我們先透過 Layout::array 取得給定長度給定型別的陣列的記憶體佈局，這個佈局包含記憶體對齊（二的倍數的位元組）與佔用記憶體大小等資訊。 再來這個 layout.size() 條件式是因為 alloc 為 unsafe 函式，需遵守其安全條款：不允許配置大小為零的空間。因此，必須判斷實際上需要配置記憶體與否，有兩種情況不需配置：  T 是 Zero Sized Types（ZSTs），也就是不需要空間的型別。 cap 為零，所以不需要容量。   若記憶體佈局所佔空間大小為零，則配置一個 NonNull 的迷途指標。  對 ZST 來說，NonNull 是安全的，ZST 的指標算術操作無論如何加減，都會指向原始的指標位址，所以上層可以零成本的抽象操作容器的各種方法，完全不需要配置額外記憶體區塊。 對非 ZST 但容量為零的記憶體佈局來說，NonNull 不會有危害但要非常小心，只有在容量大於 0 且內容有初始化時，才該允許指標算術，否則可能存取到未初始化的記憶體位址，進而引發未定義行為。   很簡單地呼叫 alloc 讓 Rust 全域預設的配置器幹一塊空間資源來。因為 alloc 發生記憶體配置錯誤時會回傳空指標，所以這裡按照官方建議用 handle_alloc_error 捕捉這個行為，防止空指標被當作合法指標使用。   Rust 1.28 導入 Global allocators 的功能，讓使用者使用 #[global_allocator] 屬性，替標準函式庫註冊全域的記憶體配置器，也因此，上述的 alloc、realloc、dealloc 即將在 allocator_api 穩定後被取代。\n 看完配置記憶體，來看如何手動釋放記憶體。Rust 的 Drop 特徵有 drop() 方法，會在數值不需要時呼叫，類似其他語言的解構函式（destructor）。我們將釋放記憶體的邏輯放在 RawVec::drop 裡面，當 RawVec 不被需要時，就會協助我們釋放手動配置的記憶體。\nimplT Drop for RawVecT { /// Deallocates the underlying memory region by calculating the type layout  /// and number of elements.  ///  /// This only drop the memory block allocated by `RawVec` itself but not  /// dropping the contents. Callers need to drop the contents by themselves.  fn drop(\u0026mut self) { let layout = Layout::array::T(self.cap).unwrap(); // 1  if layout.size()  0 { // This is safe because it conforms to the [safety contracts][1].  //  // [1]: https://doc.rust-lang.org/1.49.0/alloc/alloc/trait.GlobalAlloc.html#safety-2  unsafe { dealloc(self.ptr.cast(), layout) } } } } 實作上，第一步取得當前記憶體佈局，並透過 dealloc 配合指標來釋放記憶體。當然，ZST 或是容量為零的狀況並沒有配置記憶體，額外判斷無需釋放。\n最後，來瞧瞧 try_grow，為了簡化實作，每次呼叫時，記憶體區塊就單純加倍。\nimplT RawVecT { // ...  pub fn try_grow(\u0026mut self) { if mem::size_of::T() == 0 { return; // 1  } if self.cap == 0 { *self = Self::with_capacity(1); // 2  return; } let old_layout = Layout::array::T(self.cap).unwrap(); // 3  let new_cap = self.cap  1; let new_size = old_layout.size() * new_cap; // This is safe because it conforms to the [safety contracts][1].  //  // [1]: https://doc.rust-lang.org/1.49.0/alloc/alloc/trait.GlobalAlloc.html#safety-4  let ptr = unsafe { realloc(self.ptr.cast(), old_layout, new_size) }; if ptr.is_null() { handle_alloc_error(old_layout); } // ...Old allocation is unusable and may be released from here at anytime.  self.ptr = ptr.cast(); // 4  self.cap = new_cap; } }  ZST 的空間不需加倍，直接返回。 原本空間容量為零的狀況，直接配置容量為一的空間。 準備 realloc 需要的參數：容量超過零的，取得舊的記憶體佈局，並乘上翻倍後的容量，算出新的空間大小。這讓之後呼叫 realloc 時符合其安全條款：合法指標、空間大於零、記憶體佈局為該區塊的舊佈局。 呼叫 realloc 之後，原先記憶體區塊可能被釋放，因此不該繼續用舊指標，此以新指標取代之。  終於將手動配置記憶體的邏輯封裝在 RawVec 裡面，外部不需要弄髒手搞記憶體了！\nDeque 有了 RawVec，現在可以將先前缺失的 SomeStorageType 補上，初始化的方法也異常單純。\npub struct DequeT { tail: usize, head: usize, ring_buf: RawVecT, } implT DequeT { pub fn new() - Self { Self { tail: 0, head: 0, ring_buf: RawVec::with_capacity(DEFAULT_CAPACITY), } } } 至此，Deque 結構體的佈局設計告一段落，接下來就是各種方法實作。\n基本操作 身為一個雙端佇列，會有以下符合定義的基本操作：\n new：初始化一個容器。 push_front：在容器最前端新增一個元素。 push_back：在容器最末端新增一個元素。 pop_front：移除在容器最前端的元素。 pop_back：移除在容器最末端的元素。  另外為了提升方便性，也提供了一些方法：\n front：查看容器最前端的元素。 back：查看容器最末端的元素。 len：檢查容器內的元素數目。 is_empty：檢查容器內是否沒有任何元素。 iter、iter_mut、into_iter：產生一個疊代容器內所有元素的疊代器。  因為需要比較動態精細地控制記憶體，少不了一些內部方法：\n is_full：檢查底層環形緩衝區是否滿載。 try_grow：嘗試動態增加底層儲存空間。 wrapping_add、wrapping_sub：確保邏輯索引的增減正確映射到底層實際索引位址。  邏輯索引映射 前一段提及環形緩衝區可以從頭尾增加元素，這一段來說明「如何封裝環形緩衝區內部的物理索引」，讓外部的邏輯索引可映射到內部已儲存合法數值的緩衝區位址。\n再回來看容量為 8 的雙端佇列的例子，已進行一系列操作：\n push_back 1 push_back 2 push_back 3 push_back 4 push_front 5 push_front 6   h t --------------- 1 2 3 4 x x 6 5 --------------- 如果我們要按照順序，從佇列的 tail 到 head 印出所有元素，應該從 tail 開始，逐一增加索引，依序 6 5 1 2 3 4 印出，我們畫上虛擬的元素對應位置：\n~: virtual element h t -- ----------------------- 1 2 3 4 x x 6 5 1 2 3 4 ----------------------- ~ ~ ~ ~ 顯而易見，虛擬元素對應的索引是 8、9、10、11，已經超過緩衝區的長度，可以利用模除運算計算物理索引，將索引固定在一定長度內。目前緩衝區容量為 8，所以將索引全部 模除 8：\n 8 % 8 = 0：對應到 [0] 的元素 1 9 % 8 = 1：對應到 [1] 的元素 2 10 % 8 = 2：對應到 [2] 的元素 3 11 % 8 = 3：對應到 [3] 的元素 4  模除是直觀的作法，但還有更神奇的思路：位元運算（bitwise arithmetic）。只要拿 7 跟這些索引做 \u0026 位元 AND 運算，也能得到相同結果。\n 8 9 10 11 這邊使用 7 有其意義：\n 7 是 $2^3 - 1$，剛好 $2^n - 1$ 在是二進位制中全部位元都會是 1 ，任意數與 $2^n - 1$ 做位元 AND 運算，可以得到低位 n 位中有多少 1，同時捨棄大於 n 的位元。這個特性不偏不倚和模除的結果相同。 還記得環形緩衝區有個特性嗎：容量僅剩一個儲存單元時，表示緩衝區已滿。若能保證環形緩衝區的容量必為 $2^n$，當緩衝區滿時，元素個數定為 $2^n - 1$，完全符合前一點的特性。  綜合以上，只需要保證緩衝區容量是 $2^n$，將邏輯索引映射到實際索引，只要將索引和實際可用容量（$2^n - 1$）做位元 AND 運算即可：\nfn wrap_index(index: usize, size: usize) - usize { debug_assert!(size.is_power_of_two()); index \u0026 (size - 1) } 接下來，就可以推出 wrapping_add 和 wrapping_sub 這兩支正確增減索引的方法：\nimplT DequeT { // ...  fn wrapping_add(\u0026self, index: usize, addend: usize) - usize { wrap_index(index.wrapping_add(addend), self.cap()) } fn wrapping_sub(\u0026self, index: usize, subtrahend: usize) - usize { wrap_index(index.wrapping_sub(subtrahend), self.cap()) } fn cap(\u0026self) - usize { self.ring_buf.cap() } }  上面用環繞算術運算（wrapping arithmetic operation） 可以使開發更方便，例如遇上 index 0 而 subtrahend 1 時，巧妙避開 $0 - 1 = -1$ 但 usize 不能為負的限制，直接環繞回 usize::MAX。\n 值得一提的是，在 Deque::cap 這個簡單的封裝上呼叫了 RawVec::cap，這是新增的方法，旨在提供 ZST 一個很大很大的虛擬容量，但同時保證是 2 的次方：\nimplT RawVecT { // ...  pub fn cap(\u0026self) - usize { if mem::size_of::T() == 0 { 1usize  (mem::size_of::usize() * 8 - 1) } else { self.cap } } } 動態增加記憶體空間 前面提及環形緩衝區是長度固定的陣列，但雙端佇列若必須固定長度就太沒路用，直觀作法就是透過加倍 RawVec 容量，再繼續新增元素。這個想法沒錯，但會遇到一個問題：如何確保邏輯索引在記憶體加倍後依然正確映射到實際索引？這裡舉一個實際案例：\nBefore: h t [o o o o x x o o] Resize: h t [o o o o x x o o | x x x x x x x x] 同樣一個容量為 8 的佇列，觸發了記憶體重新配置，所以記憶體加倍，無奈今非昔比，現在的邏輯索引 tail 無法映射到實際索引，環形緩衝區的「環」已經斷掉。若我們繼續 push_back 往 head 添加元素，就會覆蓋掉 tail 和後面的元素。\nafter 4 push_back: overwritten: ⌀ newly added: _ t h [o o o o o o ⌀ ⌀ | x x x x x x x x] _ _ _ _ 有鑑於此，需要修正將斷掉的環，最簡單的作法就是將緩衝區首個索引到 head 之前的索引這段記憶體空間，複製到新翻倍的空間上，讓 tail 在 head 前面，合法的記憶體區塊再次變得連續：\nBefore: h t [o o o o x x o o] Resize: h t [o o o o x x o o | x x x x x x x x] Copy: t h [x x x x x x o o | o o o o x x x x] _ _ _ _ _ _ _ _ 了解實作的目標後，先定義個容量已滿的方法暖暖身：\nfn is_full(\u0026self) - bool { self.cap() - self.len() == 1 } 然後是 try_grow 的實作：\nfn try_grow(\u0026mut self) { if self.is_full() { let old_cap = self.cap(); // 1  self.ring_buf.try_grow(); // 2  // 3  if self.tail  self.head { // The content of ring buffer won't overlapped, so it's safe to  // call `copy_nonoverlapping`. It's also safe to advance the  // pointer by `old_cap` since the buffer has been doubled.  unsafe { let src = self.ptr(); // 4-1  let dst = self.ptr().add(old_cap); // 4-2  ptr::copy_nonoverlapping(src, dst, self.head); } self.head += old_cap; // 5  } } }  將舊的容量存起來，因為當 ring_buf 容量翻倍後，cap() 返回的容量就會翻倍。 呼叫 RawVec::try_grow() 讓容量翻倍。 在 tail 大於 head 時，代表環在翻倍後會不連續，所以需要複製元素。 這裡用 ptr::copy_nonoverlapping 進行位元複製，此函式語義上與 C 的 memcpy 相同。  取得緩衝區首個索引的位址，作為複製的起始位址。 取擴增後部分的首個索引位址，作為複製的目標位址。 實際呼叫 memcpy ，因為 head 永遠比最後一個元素索引多 1，剛好可作為元素數目。   被複製的元素位移了 old_cap，因此更新 head 映射到正確的 head + old_cap。  我們完成了動態增加容量的方法的同時，也維持邏輯索引映射的正確性。\n 這裡維持索引正確性有稍微簡化，更高效優美的解法請參考標準函式庫 VecDeque::handle_capacity_increase 。\n 查看元素 查看首末兩段的元素非常簡單，不過由於涉及底層儲存空間的指標操作，所以需要寫 Unsafe Rust：\npub fn front(\u0026self) - OptionT { if self.is_empty() { return None; } // This is safe because the offset is wrapped inside valid memory region.  unsafe { Some(\u0026*self.ptr().add(self.tail)) } } pub fn back(\u0026self) - OptionT { if self.is_empty() { return None; } let head = self.wrapping_sub(self.head, 1); // This is safe because the offset is wrapped inside valid memory region.  unsafe { Some(\u0026*self.ptr().add(head)) } } 兩個函式都先判斷雙端佇列是否為空，再做指標位移運算，head - 1 是 back 的指標位移量，而 front 就直接回傳 tail 指向的值。其中 \u0026* 是常見的 Rust 模式，可視為將裸指標「升級」為更安全的引用型別，步驟如下：\n 解引用裸指標，得到底下的裸數值。 建立一個安全的引用，指向裸數值。  這裡再來品嚐 is_empty 和 len 的實作：\npub fn is_empty(\u0026self) - bool { self.len() == 0 } pub fn len(\u0026self) - usize { self.head.wrapping_sub(self.tail) \u0026 (self.cap() - 1) } len 用了環繞算術運算，讓 head - tail 能正確算出兩者的距離，並在用前面提及的「容量 - 1」的 $2^n - 1$ 做位元 AND 運算來捨棄高位。\n增刪元素 來看從頭尾刪除元素的 pop_front 和 pop_back：\npub fn pop_front(\u0026mut self) - OptionT { if self.is_empty() { return None; // 1  } let tail = self.tail; self.tail = self.wrapping_add(self.tail, 1); // 2  // This is safe because the offset is wrapped inside valid memory region.  unsafe { Some(self.ptr().add(tail).read()) } // 3  } pub fn pop_back(\u0026mut self) - OptionT { if self.is_empty() { return None; // 1  } self.head = self.wrapping_sub(self.head, 1); // 2  // This is safe because the offset is wrapped inside valid memory region.  unsafe { Some(self.ptr().add(self.head).read()) } // 3  }  同樣先判斷雙端佇列是否為空。 再來移動到下一個合法的索引上，會是 head - 1 或 tail + 1。 最後是指標位移再讀取，注意，雖然 ptr::read 會複製指標指向的值，但可視為所有權轉移到回傳值上了，這是因為倘若原始 src 指向的資料帶有其他指標，那麼繼續使用 src 就可能導致記憶體安全問題。  再來看增加元素的 push_front 與 push_back：\npub fn push_front(\u0026mut self, elem: T) { self.try_grow(); // 1  self.tail = self.wrapping_sub(self.tail, 1); // 2  // This is safe because the offset is wrapped inside valid memory region.  unsafe { self.ptr().add(self.tail).write(elem) } // 3  } pub fn push_back(\u0026mut self, elem: T) { self.try_grow(); // 1  let head = self.head; self.head = self.wrapping_add(self.head, 1); // 2  // This is safe because the offset is wrapped inside valid memory region.  unsafe { self.ptr().add(head).write(elem) } // 3  }  同樣先判斷雙端佇列是否為空。 再來移動到下一個合法的索引上，會是 head + 1 或 tail - 1。 最後是指標位移再寫入， ptr::write 不會觸發讀取或是 drop 裸指標指向的值，但使用上仍然要確認存取該位址是否合法。  以上就是 Deque 基本操作方法，至此，剩下最後一步「正確釋放記憶體」，雙端佇列基本款就完成了。\n特徵 Rust 提供許多特徵（Trait），實作特徵可以讓資料結構更方便，更符合 Rust 社群的寫作慣例。\nDrop 這是 Deque 最重要的特徵之一，也是完成 Deque 基本款的最後一個必要功能。Drop 會用來釋放儲存在 Deque 裡面元素的資源。實作是將所有元素 pop_back 出來，所有權轉移到 drop 函式內，函式本體執行結束後，就會自動呼叫該元素型別的 drop 並釋放資源。\nimplT Drop for DequeT { fn drop(\u0026mut self) { while let Some(_) = self.pop_back() {} } } 也許你會問「為什麼不在 Deque.ring_buf 的 RawVec 實作 Drop 來釋放其內容的資源？」主因是權責區分，RawVec 僅負責釋放它自行配置的堆疊記憶體，不清楚內容元素該如何釋放記憶體，例如內容可能是 Region-based memory management，一起釋放效率更高，元素各別 mem::drop 反而拖累效率。\n 事實上 Deque::drop 也能更高效，std::colletions::VecDeque::drop 就是直接 drop 兩個指向切片（slice）的指標，而非每個元素各自處理，雖然最後可能殊途同歸，視編譯器最佳化程度而定。\n Iterator 身為容器型別，沒有疊代器簡直不能用，Rust 提供許多疊代器特徵供實作，其中 Iterator 特徵最為基礎且重要，實作 Iterator 特徵需求一個 next 方法，會不斷回傳下一個元素。任何實作 Iterator 特徵的型別，都可以放入 for 迴圈疊代。\n而 Rust 常見的疊代器設計模式包含三個產生疊代器的方法：\n iter()：慣例上回傳會產生不可變引用 \u0026T 的 Iterator。 iter_mut()：慣例上回傳會產出可變引用 \u0026mut T 的 Iterator。 into_iter()：慣例上回傳吃掉所有權 T 的 Iterator ，通常直接實作 IntoIterator 特徵即可，我們在下一段介紹它。  實作 Iterator 需要新的結構體，以儲存疊代的內部狀態：\npub struct Itera, T { head: usize, tail: usize, ring_buf: \u0026'a [T], } pub struct IterMuta, T { head: usize, tail: usize, ring_buf: \u0026'a mut [T], }  Iter：由於定位 Deque 中有元素的合法記憶體區域需要 head 和 tail，因此儲存該兩者，並且儲存底層的環形緩衝區的切片引用，方便存取元素。 IterMut：同 Iter，但改為儲存可變的切片引用。  來看看 Iter 如何實作疊代器：\nimpla, T Iterator for Itera, T { type Item = \u0026'a T; fn next(\u0026mut self) - OptionSelf::Item { if self.tail == self.head { return None; // 1  } let tail = self.tail; // 2  self.tail = wrap_index(self.tail.wrapping_add(1), self.ring_buf.len()); // 3  self.ring_buf.get(tail) // 4  } }  當 tail 等於 head 時，代表環形緩衝區為空，直接回傳 None。 tail 是 Deque 最前端，這裡先將當前的 tail 儲存起來。 再將 Iter 上的 tail 增加 1（不影響原始 Deque），下一次呼叫 next 就會取得下一個元素。 利用第二步儲存的當前 tail，配合 slice::get 直接回傳一個元素。  再來處理 IterMut::next，直觀上將 Iter::next 的 self.ring_buf.get(tail) 改成 get_mut 即可。\nimpla, T Iterator for IterMuta, T { type Item = \u0026'a mut T; fn next(\u0026mut self) - OptionSelf::Item { if self.tail == self.head { return None; } let tail = self.tail; self.tail = wrap_index(self.tail.wrapping_add(1), self.ring_buf.len()); self.ring_buf.get_mut(tail) // Change to `get_mut`  } } 欸！居然編譯失敗了，到底為什麼呢？\nerror[E0495]: cannot infer an appropriate lifetime for autoref due to conflicting requirements -- src/collections/deque/mod.rs:353:23 | 353 | self.ring_buf.get_mut(tail) | ^^^^^^^ | note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 347:5... -- src/collections/deque/mod.rs:347:5 | 347 | fn next(\u0026mut self) - Option{ | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ note: ...so that reference does not outlive borrowed content -- src/collections/deque/mod.rs:353:9 | 353 | self.ring_buf.get_mut(tail) | ^^^^^^^^^^^^^ note: but, the lifetime must be valid for the lifetime `'a` as defined on the impl at 344:6... -- src/collections/deque/mod.rs:344:6 | 344 | implIterator for IterMut{ | ^^ note: ...so that the expression is assignable -- src/collections/deque/mod.rs:353:9 | 353 | self.ring_buf.get_mut(tail) | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ = note: expected `Option` found `Option` 這個編譯錯誤是因為匿名的 \u0026mut self 和 Self::Item 兩者生命週期不匹配。以下把函式簽名的生命週期展開來看：\nfn nextanonymous(\u0026'anonymous mut self) - Optiona mut T { // ...  self.ring_buf // \u0026'anonymous [T]  .get_mut(tail) // Some(\u0026'anonymous mut T)  } 嗯，這不太對，我們知道 Rust 保證「就算 drop 了疊代器本身，產出的元素仍然合法」，產出的元素若為引用絕對不會是迷途引用，例如下面範例：\nlet a = iter.next().unwrap(); let b = iter.next().unwrap(); drop(iter); use_both(a, b); 但編譯器只看型別是否正確，並無法檢查執行期間的 \u0026mut self 內部 ring_buf 和 Self::Item 是否活得一樣久，且由於 Iterator::next 函式簽名上沒有對 \u0026mut self 的生命週期做任何限制，因此無法寫出下列這種預期中的生命週期限制（可視為要求 'b 至少活得跟 'a 一樣長）：\nimpla, T Iterator for IterMuta, T { type Item = \u0026'a mut T; fn nextb: 'a(\u0026'b mut self) - OptionSelf::Item { // ...omit  } } // error[E0195]: lifetime parameters or bounds on method `next` do not match the trait declaration // -- src/collections/deque/mod.rs:347:12 // | // 347 | fn next(\u0026'b mut self) - Option { // | ^^^^^^^^ lifetimes do not match method in trait 當然，我們知道回傳 ring_buf 的 \u0026'a mut T 在生命週期上合法，但編譯器認不出來，所以 unsafe 又要來拯救世界。\nimpla, T Iterator for IterMuta, T { type Item = \u0026'a mut T; fn next(\u0026mut self) - OptionSelf::Item { if self.tail == self.head { return None; } let tail = self.tail; self.tail = wrap_index(self.tail.wrapping_add(1), self.ring_buf.len()); self.ring_buf.get_mut(tail) // Change to `get_mut`  } }  將 ring_buf 轉換成裸指標，因為裸指標無生命週期，所以 \u0026mut self 給的限制不見了。 再把 ptr 指向的 *mut [T] 裸指標轉換成有生命週期的可變引用 \u0026mut [T] 的切片。藉由 Rust 對回傳型別的自動推斷，此切片的實際型別會是 \u0026'a mut [T]。Got it！這就是我們所要的。 老老實實地呼叫 slice::get_mut，完全正確。   這類 An iterator yields borrowing contents from itself 的問題，有個俗名叫做 streaming iterator，可以透過泛型關聯型別（generic associated type a.k.a GAT）解決，但目前 GAT 尚未穩定。詳情可參考這篇介紹 GAT 與 streaming iterator workaroud 的文章。\n  欸，或許你有疑惑，Iter::next 不也同樣有生命週期問題嗎，為什麼沒有報錯呢？這是因為所有 \u0026T 引用都預設實作 Copy 特徵，呼叫 slice::get() 時會自動複製 ring_buf 的引用，因此沒有生命週期的問題，但 \u0026mut T 並沒有實作 Copy 特徵，才會遇上生命週期不符的編譯錯誤。\n IntoIterator 相較於 Interator，IntoIterator 是一個讓容器型別錦上添花的特徵，主要功能是：將一個型別自動轉換為有實作 Iterator 的型別，實作後該型別就可以直接放入 for 迴圈中。\n例如下列用法：\nlet mut d = Deque::new(); d.push_back(1); d.push_back(2); d.push_front(3); d.push_front(4); for elem in \u0026d { println!(\"{:?}\". elem); } for elem in \u0026mut d { *elem *= *elem; } 實作上分三個：\n impl IntoIterator for Deque：將容器轉換成疊代器，並轉移容器和元素的所有權。 implIntoIterator for \u0026'a Deque：將容器不可變引用轉換成不可變元素的疊代器。 implIntoIterator for \u0026'a mut Deque：將容器可變引用轉換成可變元素的疊代器。  先說明後面兩者。以下實作非常簡單，只要根據容器引用可變與否，對應呼叫前一段提及的 Deque::iter 或 Deque::iter_mut 即可，這算是 Rust 容器型別的一貫作法。\nimpla, T IntoIterator for \u0026'a DequeT { type Item = \u0026'a T; type IntoIter = Itera, T; fn into_iter(self) - Self::IntoIter { self.iter() } } impla, T IntoIterator for \u0026'a mut DequeT { type Item = \u0026'a mut T; type IntoIter = IterMuta, T; fn into_iter(self) - Self::IntoIter { self.iter_mut() } } 至於 impl IntoIterator for Deque 和 iter 與 iter_mut 不一樣，會吃所有權，所以需要宣告額外的結構體來儲存其內部狀態，並直接實作 IntoIterator 要求的 into_iter 方法：\npub struct IntoIterT(DequeT); implT IntoIterator for DequeT { type Item = T; type IntoIter = IntoIterT; fn into_iter(self) - Self::IntoIter { IntoIter(self) } } 此疊代方法中，佇列內元素的所有權會轉移，所以不需要跟 Iter 一樣保存切片，可以直接存整個 Deque 作為內部狀態，拿走 Deque 的所有權。\n既然掌控 Deque 所有權，實作疊代器就沒有困難了，直接將所有元素 pop 取出即可。\nimplT Iterator for IntoIterT { type Item = T; fn next(\u0026mut self) - OptionSelf::Item { self.0.pop_front() } } Index and IndexMut 用索引下標 array[index] 取值的語法常見於各大主流語言，Rust 提供 Index 和 IndexMut 兩個特徵來實作這個運算子，讓容器型別更符合人體工學。\n實作方法是利用邏輯索引映射 段落實作的 wrap_index 得出實際索引，再透過指標取值即可。唯一需要注意的是越界存取（out of bound access）可能產生未定義行為，不符合 Rust 對記憶體安全的要求，所以在裸指標存取之前，就要直接 assert! 索引是否在元素數量的安全範圍內，防止越界存取。\nimplT Indexusize for DequeT { type Output = T; fn index(\u0026self, index: usize) - \u0026Self::Output { assert!(index  self.len(), \"Out of bound\"); let index = self.wrapping_add(self.tail, index); // This is safe because the offset is wrapped inside valid memory region.  unsafe { \u0026*self.ptr().add(index) } } } implT IndexMutusize for DequeT { fn index_mut(\u0026mut self, index: usize) - \u0026mut T { assert!(index  self.len(), \"Out of bound\"); let index = self.wrapping_add(self.tail, index); // This is safe because the offset is wrapped inside valid memory region.  unsafe { \u0026mut *self.ptr().add(index) } } } Debug 最後，介紹一下 fmt::Formatter 有許多方便的 debug 格式化輸出的方法，例如 debug_list 可以丟一個疊代器，會轉化成序列般的輸出格式。\nimplT: fmt::Debug fmt::Debug for DequeT { fn fmt(\u0026self, f: \u0026mut fmt::Formatter) - fmt::Result { f.debug_list().entries(self.iter()).finish() } } 當然，如果想要對 RawVec 實作 Debug 特徵，免手寫，可直接用 derive 屬性讓編譯器推導實作。\n#[derive(Debug)] // Add this line to derive Debug trait automatically. struct RawVecT { ptr: *mut T, cap: usize, } 效能 以環形緩衝區為底層儲存容器的雙端序列，各操作複雜度如下:\n   Operation Best case Worst case     push_front(v) $O(1)$ $O(1)$~   push_back(v) $O(1)$ $O(1)$~   pop_front(v) $O(1)$ $O(1)$~   pop_back(v) $O(1)$ $O(1)$~   front $O(1)$ $O(1)$   back $O(1)$ $O(1)$   len $O(1)$ $O(1)$     $n$：資料筆數。\n$v$：資料值。\n~：平攤後的複雜度（amortized）。\n 雙端佇列任何操作都是直接對 head 或 tail 的索引讀寫記憶體，複雜度皆為 $O(1)$，不過因為增減元素需要動態調整儲存空間大小，所以這些方法的時間複雜度需要平攤。\n空間複雜度則是只用了一個環形緩衝區儲存元素，和幾個欄位儲存 tail、head 還有容量，因此額外空間複雜度只有 $O(1)$。\n參考資料  Rust Documentation: VecDeque Rust RawVec Implementation Wiki: Circular buffer Circular Buffer Image by Cburnett CC BY-SA-3.0 via Wikimedia Commons.  ","wordCount":"9386","inLanguage":"en","datePublished":"2021-02-16T00:00:00+08:00","dateModified":"2021-02-16T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://weihanglo.tw/posts/2021/deque/"},"publisher":{"@type":"Organization","name":"Life is a refactoring process without tests","logo":{"@type":"ImageObject","url":"https://weihanglo.tw/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://weihanglo.tw accesskey=h title="Life is a refactoring process without tests (Alt + H)">Life is a refactoring process without tests</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
<li>
<a href=https://weihanglo.tw/ title=Home>
<span>Home</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://weihanglo.tw/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
雙端佇列 Deque
</h1>
<div class=post-meta><span title="2021-02-16 00:00:00 +0800 +0800">February 16, 2021</span>&nbsp;·&nbsp;19 min
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e6%9e%b6%e6%a7%8b%e8%a8%ad%e8%a8%88 aria-label=架構設計>架構設計</a><ul>
<li>
<a href=#%e7%92%b0%e5%bd%a2%e7%b7%a9%e8%a1%9d%e5%8d%80 aria-label=環形緩衝區>環形緩衝區</a></li>
<li>
<a href=#%e6%89%8b%e5%8b%95%e9%85%8d%e7%bd%ae%e8%a8%98%e6%86%b6%e9%ab%94 aria-label=手動配置記憶體>手動配置記憶體</a></li>
<li>
<a href=#deque aria-label=Deque><code>Deque</code></a></li></ul>
</li>
<li>
<a href=#%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c aria-label=基本操作>基本操作</a><ul>
<li>
<a href=#%e9%82%8f%e8%bc%af%e7%b4%a2%e5%bc%95%e6%98%a0%e5%b0%84 aria-label=邏輯索引映射>邏輯索引映射</a></li>
<li>
<a href=#%e5%8b%95%e6%85%8b%e5%a2%9e%e5%8a%a0%e8%a8%98%e6%86%b6%e9%ab%94%e7%a9%ba%e9%96%93 aria-label=動態增加記憶體空間>動態增加記憶體空間</a></li>
<li>
<a href=#%e6%9f%a5%e7%9c%8b%e5%85%83%e7%b4%a0 aria-label=查看元素>查看元素</a></li>
<li>
<a href=#%e5%a2%9e%e5%88%aa%e5%85%83%e7%b4%a0 aria-label=增刪元素>增刪元素</a></li></ul>
</li>
<li>
<a href=#%e7%89%b9%e5%be%b5 aria-label=特徵>特徵</a><ul>
<li>
<a href=#drop aria-label=Drop><code>Drop</code></a></li>
<li>
<a href=#iterator aria-label=Iterator><code>Iterator</code></a></li>
<li>
<a href=#intoiterator aria-label=IntoIterator><code>IntoIterator</code></a></li>
<li>
<a href=#index-and-indexmut aria-label="Index and IndexMut"><code>Index</code> and <code>IndexMut</code></a></li>
<li>
<a href=#debug aria-label=Debug><code>Debug</code></a></li></ul>
</li>
<li>
<a href=#%e6%95%88%e8%83%bd aria-label=效能>效能</a></li>
<li>
<a href=#%e5%8f%83%e8%80%83%e8%b3%87%e6%96%99 aria-label=參考資料>參考資料</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><blockquote>
<p>本篇從 <a href=https://rust-algo.club>Rust Algorithm Club</a> 移植，若欲閱讀最新版，請移駕至<a href=https://rust-algo.club/collections/deque>Rust 演算法俱樂部：雙端佇列 Deque</a> 一文，此文不同步更新。</p>
</blockquote>
<p>雙端佇列（double-ended queue，通常縮寫為 deque）是一般化（generalize）的<a href=https://rust-algo.club/collections/queue>佇列</a>或<a href=https://rust-algo.club/collections/stack>堆疊</a>。比起佇列只能「先進先出 FIFO」，以及堆疊只有「後進先出 LIFO」，雙端佇列可以從最前端或最末端任意方向，在常數時間複雜度內增刪元素，更為方便。</p>
<p>雙端佇列常見用動態陣列或是鏈結串列實作，動態陣列的實作會因空間不夠，需要重新配置記憶體，但通常會支援隨機存取（random access）；鏈結串列的實作版本雖無法隨機存取，相對地增刪元素不需記憶體重配置。</p>
<p>雙端佇列顯著的缺點是：無論以動態陣列或連結串列實作，基本款實作通常無法在 $O(k)$ 時間複雜度的情況下，選定範圍內 k 個元素並取得單一切片（slice）。這肇因於動態陣列的實作通常內部儲存空間經過多次增刪，空間利用會不連續；而用鏈結串列實作者，則因不支援隨機存取而無法達到相應的複雜度。</p>
<blockquote>
<p>本次實作的程式碼置於在 <a href=https://rust-algo.club/doc/rust_algorithm_club/collections/struct.Deque.html><code>rust_algorithm_club::collections::Deque</code></a> API 文件中。</p>
</blockquote>
<h2 id=架構設計>架構設計<a hidden class=anchor aria-hidden=true href=#架構設計>#</a></h2>
<p>雙端佇列有個實作重點：可在<strong>常數時間</strong>從頭尾兩端增刪元素。在資料結構設計上，會儲存分別指向頭尾的兩個指標，長相可能如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Deque</span> {
    head: <span style=color:#66d9ef>usize</span>,
    tail: <span style=color:#66d9ef>usize</span>,
    storage: <span style=color:#a6e22e>SomeStorageType</span>,
}
</code></pre></div><p>第一直覺肯定是選用<a href=https://rust-algo.club/collections/doubly_linked_list>雙向鏈結串列</a>可以雙向增刪節點的特性，作為解決方案。不過這裡我們採用動態陣列實作，更精確來說，底層儲存容器同樣是有兩個分別指向頭尾的指標的「環形緩衝區（Ring buffer）」。</p>
<h3 id=環形緩衝區>環形緩衝區<a hidden class=anchor aria-hidden=true href=#環形緩衝區>#</a></h3>
<p><img loading=lazy src=https://upload.wikimedia.org/wikipedia/commons/thumb/b/b7/Circular_buffer.svg/240px-Circular_buffer.svg.png alt>
</p>
<p><a href=https://en.wikipedia.org/wiki/Circular_buffer>環形緩衝區（Ring buffer）</a> 是一個長度大小固定的緩衝區，可以視為頭尾相連的記憶體區塊，上圖雖以環狀呈現，但在計算機架構中儲存方式通常是線性陣列，再搭配指向頭端的 <code>head</code> 與指向尾端的 <code>tail</code> 兩個指標構成。</p>
<p>環形緩衝區有分兩種，一種是有循環的，緩衝區寫滿了就覆蓋尾端舊的資料，另一種是不會循環，緩衝區會放滿的，後者就是本次實作會用到的，以下將來探討：</p>
<ul>
<li>如何表示環形緩衝區為空</li>
<li>如何表示環形緩衝區已滿</li>
<li>環形緩衝區如何增加元素</li>
</ul>
<p>這節以 ASCII chart 表示之。</p>
<ul>
<li><code>h</code>: head</li>
<li><code>t</code>: tail</li>
<li><code>x</code>: no data</li>
<li><code>[number]</code>: has data</li>
</ul>
<p>下面一個容量為 8，尚未有任何元素存入的環形緩衝區，這裡觀察到，若 head 與 tail 指向的儲存單元相同，換句話說<strong>兩者索引值相同，則緩衝區為空</strong>。</p>
<pre tabindex=0><code>scenario: empty buffer

h
t
---------------
x x x x x x x x
---------------
</code></pre><p>再來，從頭端增加一個元素，此時 head 指向的儲存單元會存入元素，並且 head 索引加一。</p>
<pre tabindex=0><code>scenario: add one data onto head

t h
---------------
1 x x x x x x x
---------------
</code></pre><p>我們再連續加幾個元素，可以觀察到，head 最終指向的儲存單元永遠為空：</p>
<pre tabindex=0><code>scenario: add more data onto head

t   h
---------------
1 2 x x x x x x
---------------

t     h
---------------
1 2 3 x x x x x
---------------

t       h
---------------
1 2 3 4 x x x x
---------------
</code></pre><p>再來，我們從尾端增加元素，首先 tail 減一，並在移動過後的 tail 指向的儲存單元放入元素。因為 tail 原本為 0，減一之後為 -1，但索引不該有 -1，所以我們採取類似環繞算術運算（wrapping arithmetic operation）處理<a href=https://en.wikipedia.org/wiki/Integer_overflow>整數溢位</a>，因此 tail 索引從 0 變成 7（總共 8 個儲存單元）。</p>
<pre tabindex=0><code>scenario: add data onto tail

        h     t
---------------
1 2 3 4 x x x 5
---------------

</code></pre><blockquote>
<p>日常生活中，環繞算術運算可見於汽車儀錶板或是電錶，9999 轉過頭後會自動變成 0000，可以想像成在萬分位進位了，但我們看不到。上述減一也可以想像二進位退一位，但我們看不到，所以從 <code>0b000</code>（0）變成了 <code>0b111</code>（7）。</p>
<img src=https://upload.wikimedia.org/wikipedia/commons/5/53/Odometer_rollover.jpg width=300px>
</blockquote>
<p>我們從尾端加更多資料到緩衝區：</p>
<pre tabindex=0><code>scenario: add more data onto tail

        h   t
---------------
1 2 3 4 x x 6 5
---------------

        h t
---------------
1 2 3 4 x 7 6 5 --&gt; full
---------------
</code></pre><p>欸，怎麼加到第七個就停了？</p>
<p>由於目前僅探討<strong>不循環</strong>的環形緩衝區，已經規範 <code>head = tail</code> 代表緩衝區為空，如果貿然加上第八個元素，就無法分辨緩衝區是空是滿，恐導致轉盈為空。所以當緩衝區容量減去元素個數為 1 時，換句話說就是當剩餘最後一個空儲存單元時，表示該緩衝區已滿，不能再增加元素。由此推論環形緩衝區永遠會剩下一個沒使用的儲存單元。</p>
<p>至此，環形緩衝區的特性很符合雙端佇列的需求，總結一下：</p>
<ol>
<li><code>head = tail</code> 時，表示緩衝區為空。</li>
<li>容量僅剩一個儲存單元時，表示緩衝區已滿。</li>
<li>head 永遠指向一個空的儲存單元。</li>
<li>邏輯索引的映射會利用環繞算術運算配合<a href=https://en.wikipedia.org/wiki/Modulo_operation>模除運算</a>，將索引值限制在緩衝區範圍內。</li>
</ol>
<p>第四點很難懂齁？免驚，下面實作範例「<a href=#%E9%82%8F%E8%BC%AF%E7%B4%A2%E5%BC%95%E6%98%A0%E5%B0%84>邏輯索引映射</a>」段落就會解釋給你聽！</p>
<h3 id=手動配置記憶體>手動配置記憶體<a hidden class=anchor aria-hidden=true href=#手動配置記憶體>#</a></h3>
<p>這一段，我們將為環形緩衝區打造屬於它自己的底層儲存空間。你可能想問，既然環形緩衝區是一個固定長度的陣列，為什麼不直接利用 Rust 標準函式庫的 <code>Vec</code> 呢？因為 <a href=https://doc.rust-lang.org/1.49.0/alloc/vec/struct.Vec.html#capacity-and-reallocation><code>Vec</code> 的容量和記憶體配置</a>屬於實作細節，雖然目前是滿了才擴充容量重新配置空間，但難保未來改變，為了更細緻控制記憶體，決定弄髒手，自行配置記憶體。</p>
<blockquote>
<p>⚠️ 以下範例有 <code>unsafe</code> 程式碼，未經審計，請謹慎使用。</p>
</blockquote>
<p>首先，宣告一個 <code>RawVec</code> 結構體，儲存了兩個欄位：</p>
<ul>
<li><code>ptr</code>：指向陣列最前端的指標，因為底層陣列會變化，所以是可變裸指標 <a href=https://doc.rust-lang.org/1.49.0/std/primitive.pointer.html><code>*mut T</code></a>。</li>
<li><code>cap</code>：當前 <code>RawVec</code> 的容量。注意，容量需永遠大於等於元數個數，否則會發生<a href=https://en.wikipedia.org/wiki/Buffer_overflow>緩衝區溢位</a>。</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>RawVec</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    ptr: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> T,
    cap: <span style=color:#66d9ef>usize</span>,
}
</code></pre></div><p>接下來，我們要為 <code>RawVec</code> 實作三個方法，完成自我管理記憶體的偉大志向：</p>
<ul>
<li><code>with_capacity</code>：建立指定容量的 <code>RawVec</code>，會在堆疊上配置一塊記憶體。</li>
<li><code>try_grow</code>：嘗試將 <code>RawVec</code> 的容量加倍，會觸發記憶體的重新配置。</li>
<li><code>drop</code>：實作 <a href=https://doc.rust-lang.org/1.49.0/core/ops/trait.Drop.html><code>Drop</code></a> 特徵，會釋放在堆疊上手動配置的記憶體。</li>
</ul>
<p>先來看 <code>with_capacity</code>：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> RawVec<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>with_capacity</span>(cap: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#a6e22e>Self</span> {
        <span style=color:#66d9ef>let</span> layout <span style=color:#f92672>=</span> Layout::array::<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(cap).unwrap(); <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>
        <span style=color:#75715e>// 2
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> layout.size() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
            <span style=color:#75715e>// This is safe for zero sized types. However, be careful when facing
</span><span style=color:#75715e></span>            <span style=color:#75715e>// zero capacity layouts. It must be replaced with an actual pointer
</span><span style=color:#75715e></span>            <span style=color:#75715e>// before operations such as dereference or read/write.
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> ptr <span style=color:#f92672>=</span> ptr::NonNull::dangling().as_ptr(); <span style=color:#75715e>// 3
</span><span style=color:#75715e></span>            Self { ptr, cap: <span style=color:#ae81ff>0</span> }
        } <span style=color:#66d9ef>else</span> {
            <span style=color:#75715e>// This is safe because it conforms to the [safety contracts][1].
</span><span style=color:#75715e></span>            <span style=color:#75715e>//
</span><span style=color:#75715e></span>            <span style=color:#75715e>// [1]: https://doc.rust-lang.org/1.49.0/alloc/alloc/trait.GlobalAlloc.html#safety-1
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> ptr <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { alloc(layout) }; <span style=color:#75715e>// 4
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> ptr.is_null() {
                handle_alloc_error(layout);
            }
            Self {
                ptr: <span style=color:#a6e22e>ptr</span>.cast(),
                cap,
            }
        }
    }
}
</code></pre></div><ol>
<li>首先，我們先透過 <a href=https://doc.rust-lang.org/1.49.0/alloc/alloc/struct.Layout.html#method.array><code>Layout::array</code></a> 取得給定長度給定型別的陣列的記憶體佈局，這個佈局包含<a href=https://en.wikipedia.org/wiki/Data_structure_alignment>記憶體對齊</a>（二的倍數的位元組）與佔用記憶體大小等資訊。</li>
<li>再來這個 <code>layout.size()</code> 條件式是因為 <a href=https://doc.rust-lang.org/1.49.0/alloc/alloc/fn.alloc.html><code>alloc</code></a> 為 <code>unsafe</code> 函式，需遵守其安全條款：<a href=https://doc.rust-lang.org/1.49.0/alloc/alloc/trait.GlobalAlloc.html#safety-1>不允許配置大小為零的空間</a>。因此，必須判斷實際上需要配置記憶體與否，有兩種情況不需配置：
<ul>
<li><code>T</code> 是 <a href=https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts>Zero Sized Types（ZSTs）</a>，也就是不需要空間的型別。</li>
<li><code>cap</code> 為零，所以不需要容量。</li>
</ul>
</li>
<li>若記憶體佈局所佔空間大小為零，則配置一個 <a href=https://doc.rust-lang.org/1.49.0/core/ptr/struct.NonNull.html><code>NonNull</code></a> 的迷途指標。
<ul>
<li>對 ZST 來說，<code>NonNull</code> 是安全的，ZST 的指標算術操作無論如何加減，都會指向原始的指標位址，所以上層可以零成本的抽象操作容器的各種方法，完全不需要配置額外記憶體區塊。</li>
<li>對非 ZST 但容量為零的記憶體佈局來說，<code>NonNull</code> 不會有危害但要非常小心，只有在容量大於 0 且內容有初始化時，才該允許指標算術，否則可能存取到未初始化的記憶體位址，進而引發未定義行為。</li>
</ul>
</li>
<li>很簡單地呼叫 <a href=https://doc.rust-lang.org/1.49.0/alloc/alloc/fn.alloc.html><code>alloc</code></a> 讓 Rust 全域預設的配置器幹一塊空間資源來。因為 <code>alloc</code> 發生記憶體配置錯誤時會回傳空指標，所以這裡按照官方建議用 <code>handle_alloc_error</code> 捕捉這個行為，防止空指標被當作合法指標使用。</li>
</ol>
<blockquote>
<p>Rust 1.28 導入 <a href=https://doc.rust-lang.org/edition-guide/rust-2018/platform-and-target-support/global-allocators.html>Global allocators</a> 的功能，讓使用者使用 <a href=https://doc.rust-lang.org/1.49.0/std/alloc/trait.GlobalAlloc.html><code>#[global_allocator]</code></a> 屬性，替標準函式庫註冊全域的記憶體配置器，也因此，上述的 <code>alloc</code>、<code>realloc</code>、<code>dealloc</code> 即將在 <a href=https://github.com/rust-lang/rust/issues/32838>allocator_api</a> 穩定後被取代。</p>
</blockquote>
<p>看完配置記憶體，來看如何手動釋放記憶體。Rust 的 <a href=https://doc.rust-lang.org/1.49.0/core/ops/trait.Drop.html><code>Drop</code></a> 特徵有 <code>drop()</code> 方法，會在數值不需要時呼叫，類似其他語言的解構函式（destructor）。我們將釋放記憶體的邏輯放在 <code>RawVec::drop</code> 裡面，當 <code>RawVec</code> 不被需要時，就會協助我們釋放手動配置的記憶體。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Drop <span style=color:#66d9ef>for</span> RawVec<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#e6db74>/// Deallocates the underlying memory region by calculating the type layout
</span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// and number of elements.
</span><span style=color:#e6db74></span>    <span style=color:#e6db74>///
</span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// This only drop the memory block allocated by `RawVec` itself but not
</span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// dropping the contents. Callers need to drop the contents by themselves.
</span><span style=color:#e6db74></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>drop</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
        <span style=color:#66d9ef>let</span> layout <span style=color:#f92672>=</span> Layout::array::<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(self.cap).unwrap(); <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> layout.size() <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> {
            <span style=color:#75715e>// This is safe because it conforms to the [safety contracts][1].
</span><span style=color:#75715e></span>            <span style=color:#75715e>//
</span><span style=color:#75715e></span>            <span style=color:#75715e>// [1]: https://doc.rust-lang.org/1.49.0/alloc/alloc/trait.GlobalAlloc.html#safety-2
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>unsafe</span> { dealloc(self.ptr.cast(), layout) }
        }
    }
}
</code></pre></div><p>實作上，第一步取得當前記憶體佈局，並透過 <a href=https://doc.rust-lang.org/1.49.0/alloc/alloc/fn.dealloc.html><code>dealloc</code></a> 配合指標來釋放記憶體。當然，ZST 或是容量為零的狀況並沒有配置記憶體，額外判斷無需釋放。</p>
<p>最後，來瞧瞧 <code>try_grow</code>，為了簡化實作，每次呼叫時，記憶體區塊就單純加倍。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> RawVec<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_grow</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
        <span style=color:#66d9ef>if</span> mem::size_of::<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
            <span style=color:#66d9ef>return</span>; <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>        }

        <span style=color:#66d9ef>if</span> self.cap <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
            <span style=color:#f92672>*</span>self <span style=color:#f92672>=</span> Self::with_capacity(<span style=color:#ae81ff>1</span>); <span style=color:#75715e>// 2
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span>;
        }

        <span style=color:#66d9ef>let</span> old_layout <span style=color:#f92672>=</span> Layout::array::<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(self.cap).unwrap(); <span style=color:#75715e>// 3
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> new_cap <span style=color:#f92672>=</span> self.cap <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>;
        <span style=color:#66d9ef>let</span> new_size <span style=color:#f92672>=</span> old_layout.size() <span style=color:#f92672>*</span> new_cap;
        <span style=color:#75715e>// This is safe because it conforms to the [safety contracts][1].
</span><span style=color:#75715e></span>        <span style=color:#75715e>//
</span><span style=color:#75715e></span>        <span style=color:#75715e>// [1]: https://doc.rust-lang.org/1.49.0/alloc/alloc/trait.GlobalAlloc.html#safety-4
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> ptr <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { realloc(self.ptr.cast(), old_layout, new_size) };
        <span style=color:#66d9ef>if</span> ptr.is_null() {
            handle_alloc_error(old_layout);
        }
        <span style=color:#75715e>// ...Old allocation is unusable and may be released from here at anytime.
</span><span style=color:#75715e></span>
        self.ptr <span style=color:#f92672>=</span> ptr.cast(); <span style=color:#75715e>// 4
</span><span style=color:#75715e></span>        self.cap <span style=color:#f92672>=</span> new_cap;
    }
}
</code></pre></div><ol>
<li>ZST 的空間不需加倍，直接返回。</li>
<li>原本空間容量為零的狀況，直接配置容量為一的空間。</li>
<li>準備 <code>realloc</code> 需要的參數：容量超過零的，取得舊的記憶體佈局，並乘上翻倍後的容量，算出新的空間大小。這讓之後呼叫 <code>realloc</code> 時符合其安全條款：合法指標、空間大於零、記憶體佈局為該區塊的舊佈局。</li>
<li>呼叫 <code>realloc</code> 之後，原先記憶體區塊可能被釋放，因此不該繼續用舊指標，此以新指標取代之。</li>
</ol>
<p>終於將手動配置記憶體的邏輯封裝在 <code>RawVec</code> 裡面，外部不需要弄髒手搞記憶體了！</p>
<h3 id=deque><code>Deque</code><a hidden class=anchor aria-hidden=true href=#deque>#</a></h3>
<p>有了 <code>RawVec</code>，現在可以將先前缺失的 <code>SomeStorageType</code> 補上，初始化的方法也異常單純。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Deque</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    tail: <span style=color:#66d9ef>usize</span>,
    head: <span style=color:#66d9ef>usize</span>,
    ring_buf: <span style=color:#a6e22e>RawVec</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>,
}

<span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Deque<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>Self</span> {
        Self {
            tail: <span style=color:#ae81ff>0</span>,
            head: <span style=color:#ae81ff>0</span>,
            ring_buf: <span style=color:#a6e22e>RawVec</span>::with_capacity(DEFAULT_CAPACITY),
        }
    }
}
</code></pre></div><p>至此，<code>Deque</code> 結構體的佈局設計告一段落，接下來就是各種方法實作。</p>
<h2 id=基本操作>基本操作<a hidden class=anchor aria-hidden=true href=#基本操作>#</a></h2>
<p>身為一個雙端佇列，會有以下符合定義的基本操作：</p>
<ul>
<li><code>new</code>：初始化一個容器。</li>
<li><code>push_front</code>：在容器最前端新增一個元素。</li>
<li><code>push_back</code>：在容器最末端新增一個元素。</li>
<li><code>pop_front</code>：移除在容器最前端的元素。</li>
<li><code>pop_back</code>：移除在容器最末端的元素。</li>
</ul>
<p>另外為了提升方便性，也提供了一些方法：</p>
<ul>
<li><code>front</code>：查看容器最前端的元素。</li>
<li><code>back</code>：查看容器最末端的元素。</li>
<li><code>len</code>：檢查容器內的元素數目。</li>
<li><code>is_empty</code>：檢查容器內是否沒有任何元素。</li>
<li><code>iter</code>、<code>iter_mut</code>、<code>into_iter</code>：產生一個疊代容器內所有元素的疊代器。</li>
</ul>
<p>因為需要比較動態精細地控制記憶體，少不了一些內部方法：</p>
<ul>
<li><code>is_full</code>：檢查底層環形緩衝區是否滿載。</li>
<li><code>try_grow</code>：嘗試動態增加底層儲存空間。</li>
<li><code>wrapping_add</code>、<code>wrapping_sub</code>：確保邏輯索引的增減正確映射到底層實際索引位址。</li>
</ul>
<h3 id=邏輯索引映射>邏輯索引映射<a hidden class=anchor aria-hidden=true href=#邏輯索引映射>#</a></h3>
<p><a href=#%E7%92%B0%E5%BD%A2%E7%B7%A9%E8%A1%9D%E5%8D%80>前一段</a>提及環形緩衝區可以從頭尾增加元素，這一段來說明「如何封裝環形緩衝區內部的物理索引」，讓外部的邏輯索引可映射到內部已儲存合法數值的緩衝區位址。</p>
<p>再回來看容量為 8 的雙端佇列的例子，已進行一系列操作：</p>
<ol>
<li>push_back 1</li>
<li>push_back 2</li>
<li>push_back 3</li>
<li>push_back 4</li>
<li>push_front 5</li>
<li>push_front 6</li>
</ol>
<pre tabindex=0><code>        h   t
---------------
1 2 3 4 x x 6 5
---------------
</code></pre><p>如果我們要按照順序，從佇列的 tail 到 head 印出所有元素，應該從 tail 開始，逐一增加索引，依序 6 5 1 2 3 4 印出，我們畫上虛擬的元素對應位置：</p>
<pre tabindex=0><code>~: virtual element

        h   t --&gt;
-----------------------
1 2 3 4 x x 6 5 1 2 3 4
-----------------------
                ~ ~ ~ ~
</code></pre><p>顯而易見，虛擬元素對應的索引是 8、9、10、11，已經超過緩衝區的長度，可以利用<a href=https://en.wikipedia.org/wiki/Modulo_operation>模除運算</a>計算物理索引，將索引固定在一定長度內。目前緩衝區容量為 8，所以將索引全部
模除 8：</p>
<ul>
<li><code>8 % 8 = 0</code>：對應到 [0] 的元素 1</li>
<li><code>9 % 8 = 1</code>：對應到 [1] 的元素 2</li>
<li><code>10 % 8 = 2</code>：對應到 [2] 的元素 3</li>
<li><code>11 % 8 = 3</code>：對應到 [3] 的元素 4</li>
</ul>
<p>模除是直觀的作法，但還有更神奇的思路：位元運算（bitwise arithmetic）。只要拿 7 跟這些索引做 <code>&</code> 位元 AND 運算，也能得到相同結果。</p>
<pre tabindex=0><code>       8        9       10       11 &lt;- Logical

  0b1000   0b1001   0b1010   0b1011
&amp; 0b0111   0b0111   0b0111   0b0111
-----------------------------------
  0b0000   0b0001   0b0010   0b0011
=      0        1        2        3 &lt;- Actual
</code></pre><p>這邊使用 7 有其意義：</p>
<ol>
<li>7 是 $2^3 - 1$，剛好 $2^n - 1$ 在是二進位制中全部位元都會是 1 ，任意數與 $2^n - 1$ 做位元 AND 運算，可以得到低位 n 位中有多少 1，同時捨棄大於 n 的位元。這個特性不偏不倚和模除的結果相同。</li>
<li>還記得環形緩衝區有個特性嗎：<strong>容量僅剩一個儲存單元時，表示緩衝區已滿</strong>。若能保證環形緩衝區的容量必為 $2^n$，當緩衝區滿時，元素個數定為 $2^n - 1$，完全符合前一點的特性。</li>
</ol>
<p>綜合以上，只需要保證緩衝區容量是 $2^n$，將邏輯索引映射到實際索引，只要將索引和實際可用容量（$2^n - 1$）做位元 AND 運算即可：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wrap_index</span>(index: <span style=color:#66d9ef>usize</span>, size: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>usize</span> {
    debug_assert!(size.is_power_of_two());
    index <span style=color:#f92672>&amp;</span> (size <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
}
</code></pre></div><p>接下來，就可以推出 <code>wrapping_add</code> 和 <code>wrapping_sub</code> 這兩支正確增減索引的方法：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Deque<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wrapping_add</span>(<span style=color:#f92672>&amp;</span>self, index: <span style=color:#66d9ef>usize</span>, addend: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>usize</span> {
        wrap_index(index.wrapping_add(addend), self.cap())
    }

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wrapping_sub</span>(<span style=color:#f92672>&amp;</span>self, index: <span style=color:#66d9ef>usize</span>, subtrahend: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>usize</span> {
        wrap_index(index.wrapping_sub(subtrahend), self.cap())
    }

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>cap</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>usize</span> {
        self.ring_buf.cap()
    }
}
</code></pre></div><blockquote>
<p>上面用環繞算術運算（wrapping arithmetic operation） 可以使開發更方便，例如遇上 index 0 而 subtrahend 1 時，巧妙避開 $0 - 1 = -1$ 但 <code>usize</code> 不能為負的限制，直接環繞回 <code>usize::MAX</code>。</p>
</blockquote>
<p>值得一提的是，在 <code>Deque::cap</code> 這個簡單的封裝上呼叫了 <code>RawVec::cap</code>，這是新增的方法，旨在提供 ZST 一個很大很大的虛擬容量，但同時保證是 2 的次方：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> RawVec<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>cap</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>usize</span> {
        <span style=color:#66d9ef>if</span> mem::size_of::<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
            <span style=color:#ae81ff>1</span><span style=color:#66d9ef>usize</span> <span style=color:#f92672>&lt;&lt;</span> (mem::size_of::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>() <span style=color:#f92672>*</span> <span style=color:#ae81ff>8</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
        } <span style=color:#66d9ef>else</span> {
            self.cap
        }
    }
}
</code></pre></div><h3 id=動態增加記憶體空間>動態增加記憶體空間<a hidden class=anchor aria-hidden=true href=#動態增加記憶體空間>#</a></h3>
<p>前面提及環形緩衝區是長度固定的陣列，但雙端佇列若必須固定長度就太沒路用，直觀作法就是透過加倍 <code>RawVec</code> 容量，再繼續新增元素。這個想法沒錯，但會遇到一個問題：如何確保邏輯索引在記憶體加倍後依然正確映射到實際索引？這裡舉一個實際案例：</p>
<pre tabindex=0><code>Before:
         h   t
[o o o o x x o o]

Resize:
         h   t
[o o o o x x o o | x x x x x x x x]
</code></pre><p>同樣一個容量為 8 的佇列，觸發了記憶體重新配置，所以記憶體加倍，無奈今非昔比，現在的邏輯索引 tail 無法映射到實際索引，環形緩衝區的「環」已經斷掉。若我們繼續 <code>push_back</code> 往 head 添加元素，就會覆蓋掉 tail 和後面的元素。</p>
<pre tabindex=0><code>after 4 push_back:

overwritten: ⌀
newly added: _

             t h
[o o o o o o ⌀ ⌀ | x x x x x x x x]
         _ _ _ _
</code></pre><p>有鑑於此，需要修正將斷掉的環，最簡單的作法就是將緩衝區首個索引到 head 之前的索引這段記憶體空間，複製到新翻倍的空間上，讓 tail 在 head 前面，合法的記憶體區塊再次變得連續：</p>
<pre tabindex=0><code>Before:
         h   t
[o o o o x x o o]

Resize:
         h   t
[o o o o x x o o | x x x x x x x x]

Copy:
             t           h
[x x x x x x o o | o o o o x x x x]
 _ _ _ _           _ _ _ _
</code></pre><p>了解實作的目標後，先定義個容量已滿的方法暖暖身：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_full</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>bool</span> {
        self.cap() <span style=color:#f92672>-</span> self.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>
    }
</code></pre></div><p>然後是 <code>try_grow</code> 的實作：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_grow</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
        <span style=color:#66d9ef>if</span> self.is_full() {
            <span style=color:#66d9ef>let</span> old_cap <span style=color:#f92672>=</span> self.cap(); <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>            self.ring_buf.try_grow(); <span style=color:#75715e>// 2
</span><span style=color:#75715e></span>
            <span style=color:#75715e>// 3
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> self.tail <span style=color:#f92672>&gt;</span> self.head {
                <span style=color:#75715e>// The content of ring buffer won&#39;t overlapped, so it&#39;s safe to
</span><span style=color:#75715e></span>                <span style=color:#75715e>// call `copy_nonoverlapping`. It&#39;s also safe to advance the
</span><span style=color:#75715e></span>                <span style=color:#75715e>// pointer by `old_cap` since the buffer has been doubled.
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>unsafe</span> {
                    <span style=color:#66d9ef>let</span> src <span style=color:#f92672>=</span> self.ptr(); <span style=color:#75715e>// 4-1
</span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> dst <span style=color:#f92672>=</span> self.ptr().add(old_cap); <span style=color:#75715e>// 4-2
</span><span style=color:#75715e></span>                    ptr::copy_nonoverlapping(src, dst, self.head);
                }
                self.head <span style=color:#f92672>+=</span> old_cap; <span style=color:#75715e>// 5
</span><span style=color:#75715e></span>            }
        }
    }
</code></pre></div><ol>
<li>將舊的容量存起來，因為當 <code>ring_buf</code> 容量翻倍後，<code>cap()</code> 返回的容量就會翻倍。</li>
<li>呼叫 <code>RawVec::try_grow()</code> 讓容量翻倍。</li>
<li>在 <code>tail</code> 大於 <code>head</code> 時，代表環在翻倍後會不連續，所以需要複製元素。</li>
<li>這裡用 <a href=https://doc.rust-lang.org/1.49.0/std/ptr/fn.copy_nonoverlapping.html><code>ptr::copy_nonoverlapping</code></a> 進行位元複製，此函式語義上與 C 的 <a href=https://en.cppreference.com/w/c/string/byte/memcpy><code>memcpy</code></a> 相同。
<ol>
<li>取得緩衝區首個索引的位址，作為複製的起始位址。</li>
<li>取擴增後部分的首個索引位址，作為複製的目標位址。</li>
<li>實際呼叫 <code>memcpy</code> ，因為 head 永遠比最後一個元素索引多 1，剛好可作為元素數目。</li>
</ol>
</li>
<li>被複製的元素位移了 <code>old_cap</code>，因此更新 <code>head</code> 映射到正確的 <code>head + old_cap</code>。</li>
</ol>
<p>我們完成了動態增加容量的方法的同時，也維持邏輯索引映射的正確性。</p>
<blockquote>
<p>這裡維持索引正確性有稍微簡化，更高效優美的解法請參考標準函式庫 <a href=https://github.com/rust-lang/rust/blob/a118ee2/library/alloc/src/collections/vec_deque/mod.rs#L405-L447><code>VecDeque::handle_capacity_increase</code></a> 。</p>
</blockquote>
<h3 id=查看元素>查看元素<a hidden class=anchor aria-hidden=true href=#查看元素>#</a></h3>
<p>查看首末兩段的元素非常簡單，不過由於涉及底層儲存空間的指標操作，所以需要寫 Unsafe Rust：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>front</span>(<span style=color:#f92672>&amp;</span>self) -&gt; Option<span style=color:#f92672>&lt;&amp;</span>T<span style=color:#f92672>&gt;</span> {
        <span style=color:#66d9ef>if</span> self.is_empty() {
            <span style=color:#66d9ef>return</span> None;
        }
        <span style=color:#75715e>// This is safe because the offset is wrapped inside valid memory region.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>unsafe</span> { Some(<span style=color:#f92672>&amp;*</span>self.ptr().add(self.tail)) }
    }

    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>back</span>(<span style=color:#f92672>&amp;</span>self) -&gt; Option<span style=color:#f92672>&lt;&amp;</span>T<span style=color:#f92672>&gt;</span> {
        <span style=color:#66d9ef>if</span> self.is_empty() {
            <span style=color:#66d9ef>return</span> None;
        }
        <span style=color:#66d9ef>let</span> head <span style=color:#f92672>=</span> self.wrapping_sub(self.head, <span style=color:#ae81ff>1</span>);
        <span style=color:#75715e>// This is safe because the offset is wrapped inside valid memory region.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>unsafe</span> { Some(<span style=color:#f92672>&amp;*</span>self.ptr().add(head)) }
    }
</code></pre></div><p>兩個函式都先判斷雙端佇列是否為空，再做指標位移運算，head - 1 是 <code>back</code> 的指標位移量，而 <code>front</code> 就直接回傳 tail 指向的值。其中 <code>&*</code> 是常見的 Rust 模式，可視為<strong>將裸指標「升級」為更安全的引用型別</strong>，步驟如下：</p>
<ol>
<li>解引用裸指標，得到底下的裸數值。</li>
<li>建立一個安全的引用，指向裸數值。</li>
</ol>
<p>這裡再來品嚐 <code>is_empty</code> 和 <code>len</code> 的實作：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_empty</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>bool</span> {
        self.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
    }

    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>len</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>usize</span> {
        self.head.wrapping_sub(self.tail) <span style=color:#f92672>&amp;</span> (self.cap() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
    }
</code></pre></div><p><code>len</code> 用了環繞算術運算，讓 <code>head - tail</code> 能正確算出兩者的距離，並在用前面提及的「容量 - 1」的 $2^n - 1$ 做位元 AND 運算來捨棄高位。</p>
<h3 id=增刪元素>增刪元素<a hidden class=anchor aria-hidden=true href=#增刪元素>#</a></h3>
<p>來看從頭尾刪除元素的 <code>pop_front</code> 和 <code>pop_back</code>：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>pop_front</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
        <span style=color:#66d9ef>if</span> self.is_empty() {
            <span style=color:#66d9ef>return</span> None; <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>        }

        <span style=color:#66d9ef>let</span> tail <span style=color:#f92672>=</span> self.tail;
        self.tail <span style=color:#f92672>=</span> self.wrapping_add(self.tail, <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// 2
</span><span style=color:#75715e></span>
        <span style=color:#75715e>// This is safe because the offset is wrapped inside valid memory region.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>unsafe</span> { Some(self.ptr().add(tail).read()) } <span style=color:#75715e>// 3
</span><span style=color:#75715e></span>    }

    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>pop_back</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
        <span style=color:#66d9ef>if</span> self.is_empty() {
            <span style=color:#66d9ef>return</span> None; <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>        }

        self.head <span style=color:#f92672>=</span> self.wrapping_sub(self.head, <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// 2
</span><span style=color:#75715e></span>
        <span style=color:#75715e>// This is safe because the offset is wrapped inside valid memory region.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>unsafe</span> { Some(self.ptr().add(self.head).read()) } <span style=color:#75715e>// 3
</span><span style=color:#75715e></span>    }
</code></pre></div><ol>
<li>同樣先判斷雙端佇列是否為空。</li>
<li>再來移動到下一個合法的索引上，會是 head - 1 或 tail + 1。</li>
<li>最後是指標位移再讀取，注意，雖然 <a href=https://doc.rust-lang.org/1.49.0/core/ptr/fn.read.html><code>ptr::read</code></a> 會複製指標指向的值，但可視為所有權轉移到回傳值上了，這是因為倘若原始 <code>src</code> 指向的資料帶有其他指標，那麼繼續使用 <code>src</code> 就可能導致記憶體安全問題。</li>
</ol>
<p>再來看增加元素的 <code>push_front</code> 與 <code>push_back</code>：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>push_front</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, elem: <span style=color:#a6e22e>T</span>) {
        self.try_grow(); <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>        self.tail <span style=color:#f92672>=</span> self.wrapping_sub(self.tail, <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// 2
</span><span style=color:#75715e></span>
        <span style=color:#75715e>// This is safe because the offset is wrapped inside valid memory region.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>unsafe</span> { self.ptr().add(self.tail).write(elem) } <span style=color:#75715e>// 3
</span><span style=color:#75715e></span>    }

    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>push_back</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, elem: <span style=color:#a6e22e>T</span>) {
        self.try_grow(); <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> head <span style=color:#f92672>=</span> self.head;
        self.head <span style=color:#f92672>=</span> self.wrapping_add(self.head, <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// 2
</span><span style=color:#75715e></span>
        <span style=color:#75715e>// This is safe because the offset is wrapped inside valid memory region.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>unsafe</span> { self.ptr().add(head).write(elem) } <span style=color:#75715e>// 3
</span><span style=color:#75715e></span>    }
</code></pre></div><ol>
<li>同樣先判斷雙端佇列是否為空。</li>
<li>再來移動到下一個合法的索引上，會是 head + 1 或 tail - 1。</li>
<li>最後是指標位移再寫入， <a href=https://doc.rust-lang.org/1.49.0/core/ptr/fn.write.html><code>ptr::write</code></a> 不會觸發讀取或是 drop 裸指標指向的值，但使用上仍然要確認存取該位址是否合法。</li>
</ol>
<p>以上就是 <code>Deque</code> 基本操作方法，至此，剩下最後一步「<a href=#drop>正確釋放記憶體</a>」，雙端佇列基本款就完成了。</p>
<h2 id=特徵>特徵<a hidden class=anchor aria-hidden=true href=#特徵>#</a></h2>
<p>Rust 提供許多特徵（Trait），實作特徵可以讓資料結構更方便，更符合 Rust 社群的寫作慣例。</p>
<h3 id=drop><code>Drop</code><a hidden class=anchor aria-hidden=true href=#drop>#</a></h3>
<p>這是 <code>Deque</code> 最重要的特徵之一，也是完成 <code>Deque</code> 基本款的最後一個必要功能。<code>Drop</code> 會用來釋放儲存在 <code>Deque</code> 裡面元素的資源。實作是將所有元素 <code>pop_back</code> 出來，所有權轉移到 <code>drop</code> 函式內，函式本體執行結束後，就會自動呼叫該元素型別的 <code>drop</code> 並釋放資源。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Drop <span style=color:#66d9ef>for</span> Deque<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>drop</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
        <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(_) <span style=color:#f92672>=</span> self.pop_back() {}
    }
}
</code></pre></div><p>也許你會問「為什麼不在 <code>Deque.ring_buf</code> 的 <code>RawVec</code> 實作 <code>Drop</code> 來釋放其內容的資源？」主因是權責區分，<code>RawVec</code> 僅負責釋放它自行配置的堆疊記憶體，不清楚內容元素該如何釋放記憶體，例如內容可能是 <a href=https://en.wikipedia.org/wiki/Region-based_memory_management>Region-based memory management</a>，一起釋放效率更高，元素各別 <code>mem::drop</code> 反而拖累效率。</p>
<blockquote>
<p>事實上 <code>Deque::drop</code> 也能更高效，<a href=https://github.com/rust-lang/rust/blob/a118ee2/library/alloc/src/collections/vec_deque/mod.rs#L117-L139><code>std::colletions::VecDeque::drop</code></a> 就是直接 drop 兩個指向切片（slice）的指標，而非每個元素各自處理，雖然最後可能殊途同歸，視編譯器最佳化程度而定。</p>
</blockquote>
<h3 id=iterator><code>Iterator</code><a hidden class=anchor aria-hidden=true href=#iterator>#</a></h3>
<p>身為容器型別，沒有疊代器簡直不能用，Rust 提供許多疊代器特徵供實作，其中 <a href=https://doc.rust-lang.org/1.49.0/core/iter/trait.Iterator.html><code>Iterator</code></a> 特徵最為基礎且重要，實作 <code>Iterator</code> 特徵需求一個 <code>next</code> 方法，會不斷回傳下一個元素。任何實作 <code>Iterator</code> 特徵的型別，都可以放入 for 迴圈疊代。</p>
<p>而 Rust 常見的疊代器設計模式包含三個產生疊代器的方法：</p>
<ul>
<li><code>iter()</code>：慣例上回傳會產生不可變引用 <code>&T</code> 的 <code>Iterator</code>。</li>
<li><code>iter_mut()</code>：慣例上回傳會產出可變引用 <code>&mut T</code> 的 <code>Iterator</code>。</li>
<li><code>into_iter()</code>：慣例上回傳吃掉所有權 <code>T</code> 的 <code>Iterator</code> ，通常直接實作 <code>IntoIterator</code> 特徵即可，我們在<a href=#intoiterator>下一段</a>介紹它。</li>
</ul>
<p>實作 <code>Iterator</code> 需要新的結構體，以儲存疊代的內部狀態：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Iter</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>a</span>, T<span style=color:#f92672>&gt;</span> {
    head: <span style=color:#66d9ef>usize</span>,
    tail: <span style=color:#66d9ef>usize</span>,
    ring_buf: <span style=color:#66d9ef>&amp;</span><span style=color:#f92672>&#39;</span><span style=color:#a6e22e>a</span> [T],
}

<span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>IterMut</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>a</span>, T<span style=color:#f92672>&gt;</span> {
    head: <span style=color:#66d9ef>usize</span>,
    tail: <span style=color:#66d9ef>usize</span>,
    ring_buf: <span style=color:#66d9ef>&amp;</span><span style=color:#f92672>&#39;</span><span style=color:#a6e22e>a</span> <span style=color:#a6e22e>mut</span> [T],
}
</code></pre></div><ul>
<li><code>Iter</code>：由於定位 <code>Deque</code> 中有元素的合法記憶體區域需要 <code>head</code> 和 <code>tail</code>，因此儲存該兩者，並且儲存底層的環形緩衝區的切片引用，方便存取元素。</li>
<li><code>IterMut</code>：同 <code>Iter</code>，但改為儲存可變的切片引用。</li>
</ul>
<p>來看看 <code>Iter</code> 如何實作疊代器：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>a</span>, T<span style=color:#f92672>&gt;</span> Iterator <span style=color:#66d9ef>for</span> Iter<span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>a</span>, T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;&#39;</span><span style=color:#a6e22e>a</span> T;

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>Self::Item<span style=color:#f92672>&gt;</span> {
        <span style=color:#66d9ef>if</span> self.tail <span style=color:#f92672>==</span> self.head {
            <span style=color:#66d9ef>return</span> None; <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>        }
        <span style=color:#66d9ef>let</span> tail <span style=color:#f92672>=</span> self.tail; <span style=color:#75715e>// 2
</span><span style=color:#75715e></span>        self.tail <span style=color:#f92672>=</span> wrap_index(self.tail.wrapping_add(<span style=color:#ae81ff>1</span>), self.ring_buf.len()); <span style=color:#75715e>// 3
</span><span style=color:#75715e></span>        self.ring_buf.get(tail) <span style=color:#75715e>// 4
</span><span style=color:#75715e></span>    }
}
</code></pre></div><ol>
<li>當 tail 等於 head 時，代表環形緩衝區為空，直接回傳 <code>None</code>。</li>
<li>tail 是 <code>Deque</code> 最前端，這裡先將當前的 tail 儲存起來。</li>
<li>再將 Iter 上的 tail 增加 1（不影響原始 Deque），下一次呼叫 <code>next</code> 就會取得下一個元素。</li>
<li>利用第二步儲存的當前 tail，配合 <code>slice::get</code> 直接回傳一個元素。</li>
</ol>
<p>再來處理 <code>IterMut::next</code>，直觀上將 <code>Iter::next</code> 的 <code>self.ring_buf.get(tail)</code> 改成 <code>get_mut</code> 即可。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>a</span>, T<span style=color:#f92672>&gt;</span> Iterator <span style=color:#66d9ef>for</span> IterMut<span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>a</span>, T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;&#39;</span><span style=color:#a6e22e>a</span> <span style=color:#66d9ef>mut</span> T;

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>Self::Item<span style=color:#f92672>&gt;</span> {
        <span style=color:#66d9ef>if</span> self.tail <span style=color:#f92672>==</span> self.head {
            <span style=color:#66d9ef>return</span> None;
        }
        <span style=color:#66d9ef>let</span> tail <span style=color:#f92672>=</span> self.tail;
        self.tail <span style=color:#f92672>=</span> wrap_index(self.tail.wrapping_add(<span style=color:#ae81ff>1</span>), self.ring_buf.len());
        self.ring_buf.get_mut(tail) <span style=color:#75715e>// Change to `get_mut`
</span><span style=color:#75715e></span>    }
}
</code></pre></div><p>欸！居然編譯失敗了，到底為什麼呢？</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console>error[E0495]: cannot infer an appropriate lifetime for autoref due to conflicting requirements
   --&gt; src/collections/deque/mod.rs:353:23
    |
353 |         self.ring_buf.get_mut(tail)
    |                       ^^^^^^^
    |
note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 347:5...
   --&gt; src/collections/deque/mod.rs:347:5
    |
347 |     fn next(&amp;mut self) -&gt; Option&lt;&amp;&#39;a mut T&gt; {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: ...so that reference does not outlive borrowed content
   --&gt; src/collections/deque/mod.rs:353:9
    |
353 |         self.ring_buf.get_mut(tail)
    |         ^^^^^^^^^^^^^
note: but, the lifetime must be valid for the lifetime `&#39;a` as defined on the impl at 344:6...
   --&gt; src/collections/deque/mod.rs:344:6
    |
344 | impl&lt;&#39;a, T&gt; Iterator for IterMut&lt;&#39;a, T&gt; {
    |      ^^
note: ...so that the expression is assignable
   --&gt; src/collections/deque/mod.rs:353:9
    |
353 |         self.ring_buf.get_mut(tail)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: expected `Option&lt;&amp;&#39;a mut T&gt;`
               found `Option&lt;&amp;mut T&gt;`
</code></pre></div><p>這個編譯錯誤是因為匿名的 <code>&mut self</code> 和 <code>Self::Item</code> 兩者生命週期不匹配。以下把函式簽名的生命週期展開來看：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>anonymous</span><span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;&#39;</span><span style=color:#a6e22e>anonymous</span> <span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;&amp;&#39;</span><span style=color:#a6e22e>a</span> <span style=color:#66d9ef>mut</span> T<span style=color:#f92672>&gt;</span> {
        <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>        self.ring_buf <span style=color:#75715e>// &amp;&#39;anonymous [T]
</span><span style=color:#75715e></span>            .get_mut(tail) <span style=color:#75715e>// Some(&amp;&#39;anonymous mut T)
</span><span style=color:#75715e></span>    }
</code></pre></div><p>嗯，這不太對，我們知道 Rust 保證「就算 drop 了疊代器本身，產出的元素仍然合法」，產出的元素若為引用絕對<a href=https://users.rust-lang.org/t/iterator-lifetime-error-only-when-using-a-mutable-reference/50460/6>不會是迷途引用</a>，例如下面範例：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> iter.next().unwrap();
<span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> iter.next().unwrap();
drop(iter);
use_both(a, b);
</code></pre></div><p>但編譯器只看型別是否正確，並無法檢查執行期間的 <code>&mut self</code> 內部 <code>ring_buf</code> 和 <code>Self::Item</code> 是否活得一樣久，且由於 <code>Iterator::next</code> 函式簽名上沒有對 <code>&mut self</code> 的生命週期做任何限制，因此無法寫出下列這種預期中的生命週期限制（可視為要求 <code>'b</code> 至少活得跟 <code>'a</code> 一樣長）：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>a</span>, T<span style=color:#f92672>&gt;</span> Iterator <span style=color:#66d9ef>for</span> IterMut<span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>a</span>, T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;&#39;</span><span style=color:#a6e22e>a</span> <span style=color:#66d9ef>mut</span> T;

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>b</span>: <span style=color:#f92672>&#39;</span><span style=color:#a6e22e>a</span><span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;&#39;</span><span style=color:#a6e22e>b</span> <span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>Self::Item<span style=color:#f92672>&gt;</span> {
        <span style=color:#75715e>// ...omit
</span><span style=color:#75715e></span>    }
}

<span style=color:#75715e>// error[E0195]: lifetime parameters or bounds on method `next` do not match the trait declaration
</span><span style=color:#75715e>//    --&gt; src/collections/deque/mod.rs:347:12
</span><span style=color:#75715e>//     |
</span><span style=color:#75715e>// 347 |     fn next&lt;&#39;b: &#39;a&gt;(&amp;&#39;b mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span style=color:#75715e>//     |            ^^^^^^^^ lifetimes do not match method in trait
</span></code></pre></div><p>當然，我們知道回傳 <code>ring_buf</code> 的 <code>&'a mut T</code> 在生命週期上合法，但編譯器認不出來，所以 unsafe 又要來拯救世界。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>a</span>, T<span style=color:#f92672>&gt;</span> Iterator <span style=color:#66d9ef>for</span> IterMut<span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>a</span>, T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;&#39;</span><span style=color:#a6e22e>a</span> <span style=color:#66d9ef>mut</span> T;

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>Self::Item<span style=color:#f92672>&gt;</span> {
        <span style=color:#66d9ef>if</span> self.tail <span style=color:#f92672>==</span> self.head {
            <span style=color:#66d9ef>return</span> None;
        }
        <span style=color:#66d9ef>let</span> tail <span style=color:#f92672>=</span> self.tail;
        self.tail <span style=color:#f92672>=</span> wrap_index(self.tail.wrapping_add(<span style=color:#ae81ff>1</span>), self.ring_buf.len());
        self.ring_buf.get_mut(tail) <span style=color:#75715e>// Change to `get_mut`
</span><span style=color:#75715e></span>    }
}
</code></pre></div><ol>
<li>將 <code>ring_buf</code> 轉換成裸指標，因為裸指標無生命週期，所以 <code>&mut self</code> 給的限制不見了。</li>
<li>再把 <code>ptr</code> 指向的 <code>*mut [T]</code> 裸指標轉換成有生命週期的可變引用 <code>&mut [T]</code> 的切片。藉由 Rust 對回傳型別的自動推斷，此切片的實際型別會是 <code>&'a mut [T]</code>。Got it！這就是我們所要的。</li>
<li>老老實實地呼叫 <code>slice::get_mut</code>，完全正確。</li>
</ol>
<blockquote>
<p>這類 <em>An iterator yields borrowing contents from it<code>self</code></em> 的問題，有個俗名叫做 <em>streaming iterator</em>，可以透過<strong>泛型關聯型別</strong>（generic associated type a.k.a GAT）解決，但目前 GAT 尚未穩定。詳情可參考這篇介紹 <a href=https://lukaskalbertodt.github.io/2018/08/03/solving-the-generalized-streaming-iterator-problem-without-gats.html>GAT 與 streaming iterator workaroud</a> 的文章。</p>
</blockquote>
<blockquote>
<p>欸，或許你有疑惑，<code>Iter::next</code> 不也同樣有生命週期問題嗎，為什麼沒有報錯呢？這是因為<a href=https://doc.rust-lang.org/1.49.0/core/marker/trait.Copy.html#impl-Copy-130>所有 <code>&T</code> 引用都預設實作 Copy 特徵</a>，呼叫 <code>slice::get()</code> 時會<strong>自動複製</strong> <code>ring_buf</code> 的引用，因此沒有生命週期的問題，但 <code>&mut T</code> 並沒有實作 Copy 特徵，才會遇上生命週期不符的編譯錯誤。</p>
</blockquote>
<h3 id=intoiterator><code>IntoIterator</code><a hidden class=anchor aria-hidden=true href=#intoiterator>#</a></h3>
<p>相較於 <code>Interator</code>，<a href=https://doc.rust-lang.org/1.49.0/core/iter/trait.IntoIterator.html><code>IntoIterator</code></a> 是一個讓容器型別錦上添花的特徵，主要功能是：將一個型別自動轉換為有實作 <code>Iterator</code> 的型別，實作後該型別就可以直接放入 for 迴圈中。</p>
<p>例如下列用法：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> d <span style=color:#f92672>=</span> Deque::new();
d.push_back(<span style=color:#ae81ff>1</span>);
d.push_back(<span style=color:#ae81ff>2</span>);
d.push_front(<span style=color:#ae81ff>3</span>);
d.push_front(<span style=color:#ae81ff>4</span>);

<span style=color:#66d9ef>for</span> elem <span style=color:#66d9ef>in</span> <span style=color:#f92672>&amp;</span>d {
    println!(<span style=color:#e6db74>&#34;{:?}&#34;</span>. elem);
}

<span style=color:#66d9ef>for</span> elem <span style=color:#66d9ef>in</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> d {
    <span style=color:#f92672>*</span>elem <span style=color:#f92672>*=</span> <span style=color:#f92672>*</span>elem;
}
</code></pre></div><p>實作上分三個：</p>
<ul>
<li><code>impl&lt;T> IntoIterator for Deque&lt;T></code>：將容器轉換成疊代器，並轉移容器和元素的所有權。</li>
<li><code>impl&lt;'a, T> IntoIterator for &'a Deque&lt;T></code>：將容器不可變引用轉換成不可變元素的疊代器。</li>
<li><code>impl&lt;'a, T> IntoIterator for &'a mut Deque&lt;T></code>：將容器可變引用轉換成可變元素的疊代器。</li>
</ul>
<p>先說明後面兩者。以下實作非常簡單，只要根據容器引用可變與否，對應呼叫前一段提及的 <code>Deque::iter</code> 或 <code>Deque::iter_mut</code> 即可，這算是 Rust 容器型別的一貫作法。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>a</span>, T<span style=color:#f92672>&gt;</span> IntoIterator <span style=color:#66d9ef>for</span> <span style=color:#f92672>&amp;&#39;</span><span style=color:#a6e22e>a</span> Deque<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;&#39;</span><span style=color:#a6e22e>a</span> T;
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>IntoIter</span> <span style=color:#f92672>=</span> Iter<span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>a</span>, T<span style=color:#f92672>&gt;</span>;

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>into_iter</span>(self) -&gt; <span style=color:#a6e22e>Self</span>::IntoIter {
        self.iter()
    }
}

<span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>a</span>, T<span style=color:#f92672>&gt;</span> IntoIterator <span style=color:#66d9ef>for</span> <span style=color:#f92672>&amp;&#39;</span><span style=color:#a6e22e>a</span> <span style=color:#66d9ef>mut</span> Deque<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;&#39;</span><span style=color:#a6e22e>a</span> <span style=color:#66d9ef>mut</span> T;
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>IntoIter</span> <span style=color:#f92672>=</span> IterMut<span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>a</span>, T<span style=color:#f92672>&gt;</span>;

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>into_iter</span>(self) -&gt; <span style=color:#a6e22e>Self</span>::IntoIter {
        self.iter_mut()
    }
}
</code></pre></div><p>至於 <code>impl&lt;T> IntoIterator for Deque&lt;T></code> 和 <code>iter</code> 與 <code>iter_mut</code> 不一樣，會吃所有權，所以需要宣告額外的結構體來儲存其內部狀態，並直接實作 <code>IntoIterator</code> 要求的 <code>into_iter</code> 方法：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>IntoIter</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(Deque<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>);

<span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> IntoIterator <span style=color:#66d9ef>for</span> Deque<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> T;
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>IntoIter</span> <span style=color:#f92672>=</span> IntoIter<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>;

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>into_iter</span>(self) -&gt; <span style=color:#a6e22e>Self</span>::IntoIter {
        IntoIter(self)
    }
}
</code></pre></div><p>此疊代方法中，佇列內元素的所有權會轉移，所以不需要跟 <code>Iter</code> 一樣保存切片，可以直接存整個 <code>Deque</code> 作為內部狀態，拿走 <code>Deque</code> 的所有權。</p>
<p>既然掌控 <code>Deque</code> 所有權，實作疊代器就沒有困難了，直接將所有元素 pop 取出即可。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Iterator <span style=color:#66d9ef>for</span> IntoIter<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> T;

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>Self::Item<span style=color:#f92672>&gt;</span> {
        self.<span style=color:#ae81ff>0.</span>pop_front()
    }
}
</code></pre></div><h3 id=index-and-indexmut><code>Index</code> and <code>IndexMut</code><a hidden class=anchor aria-hidden=true href=#index-and-indexmut>#</a></h3>
<p>用索引下標 <code>array[index]</code> 取值的語法常見於各大主流語言，Rust 提供 <a href=https://doc.rust-lang.org/1.49.0/core/ops/trait.Index.html><code>Index</code></a> 和 <a href=https://doc.rust-lang.org/1.49.0/core/ops/trait.IndexMut.html><code>IndexMut</code></a> 兩個特徵來實作這個運算子，讓容器型別更符合人體工學。</p>
<p>實作方法是利用<a href=#%E9%82%8F%E8%BC%AF%E7%B4%A2%E5%BC%95%E6%98%A0%E5%B0%84>邏輯索引映射</a> 段落實作的 <code>wrap_index</code> 得出實際索引，再透過指標取值即可。唯一需要注意的是越界存取（out of bound access）可能產生未定義行為，不符合 Rust 對記憶體安全的要求，所以在裸指標存取之前，就要直接 <code>assert!</code> 索引是否在元素數量的安全範圍內，防止越界存取。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Index<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Deque<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Output</span> <span style=color:#f92672>=</span> T;

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>index</span>(<span style=color:#f92672>&amp;</span>self, index: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Self</span>::Output {
        assert!(index <span style=color:#f92672>&lt;</span> self.len(), <span style=color:#e6db74>&#34;Out of bound&#34;</span>);
        <span style=color:#66d9ef>let</span> index <span style=color:#f92672>=</span> self.wrapping_add(self.tail, index);
        <span style=color:#75715e>// This is safe because the offset is wrapped inside valid memory region.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>unsafe</span> { <span style=color:#f92672>&amp;*</span>self.ptr().add(index) }
    }
}

<span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> IndexMut<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Deque<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>index_mut</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, index: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> T {
        assert!(index <span style=color:#f92672>&lt;</span> self.len(), <span style=color:#e6db74>&#34;Out of bound&#34;</span>);
        <span style=color:#66d9ef>let</span> index <span style=color:#f92672>=</span> self.wrapping_add(self.tail, index);
        <span style=color:#75715e>// This is safe because the offset is wrapped inside valid memory region.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>unsafe</span> { <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> <span style=color:#f92672>*</span>self.ptr().add(index) }
    }
}
</code></pre></div><h3 id=debug><code>Debug</code><a hidden class=anchor aria-hidden=true href=#debug>#</a></h3>
<p>最後，介紹一下 <code>fmt::Formatter</code> 有許多方便的 debug 格式化輸出的方法，例如 <a href=https://doc.rust-lang.org/1.49.0/alloc/fmt/struct.Formatter.html#method.debug_list><code>debug_list</code></a> 可以丟一個疊代器，會轉化成序列般的輸出格式。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T: <span style=color:#a6e22e>fmt</span>::Debug<span style=color:#f92672>&gt;</span> fmt::Debug <span style=color:#66d9ef>for</span> Deque<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fmt</span>(<span style=color:#f92672>&amp;</span>self, f: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> fmt::Formatter) -&gt; <span style=color:#a6e22e>fmt</span>::Result {
        f.debug_list().entries(self.iter()).finish()
    }
}
</code></pre></div><p>當然，如果想要對 <code>RawVec</code> 實作 <code>Debug</code> 特徵，免手寫，可直接用 <code>derive</code> 屬性讓<a href=https://doc.rust-lang.org/stable/book/appendix-03-derivable-traits.html#debug-for-programmer-output>編譯器推導實作</a>。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>#[derive(Debug)]</span> <span style=color:#75715e>// Add this line to derive Debug trait automatically.
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>RawVec</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    ptr: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> T,
    cap: <span style=color:#66d9ef>usize</span>,
}
</code></pre></div><h2 id=效能>效能<a hidden class=anchor aria-hidden=true href=#效能>#</a></h2>
<p>以環形緩衝區為底層儲存容器的雙端序列，各操作複雜度如下:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Best case</th>
<th>Worst case</th>
</tr>
</thead>
<tbody>
<tr>
<td>push_front(v)</td>
<td>$O(1)$</td>
<td>$O(1)$~</td>
</tr>
<tr>
<td>push_back(v)</td>
<td>$O(1)$</td>
<td>$O(1)$~</td>
</tr>
<tr>
<td>pop_front(v)</td>
<td>$O(1)$</td>
<td>$O(1)$~</td>
</tr>
<tr>
<td>pop_back(v)</td>
<td>$O(1)$</td>
<td>$O(1)$~</td>
</tr>
<tr>
<td>front</td>
<td>$O(1)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>back</td>
<td>$O(1)$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>len</td>
<td>$O(1)$</td>
<td>$O(1)$</td>
</tr>
</tbody>
</table>
<blockquote>
<p>$n$：資料筆數。<br>
$v$：資料值。<br>
<strong>~</strong>：平攤後的複雜度（amortized）。</p>
</blockquote>
<p>雙端佇列任何操作都是直接對 head 或 tail 的索引讀寫記憶體，複雜度皆為 $O(1)$，不過因為增減元素需要動態調整儲存空間大小，所以這些方法的時間複雜度需要平攤。</p>
<p>空間複雜度則是只用了一個環形緩衝區儲存元素，和幾個欄位儲存 tail、head 還有容量，因此額外空間複雜度只有 $O(1)$。</p>
<h2 id=參考資料>參考資料<a hidden class=anchor aria-hidden=true href=#參考資料>#</a></h2>
<ul>
<li><a href=https://doc.rust-lang.org/stable/std/collections/vec_deque/struct.VecDeque.html>Rust Documentation: <code>VecDeque</code></a></li>
<li><a href=https://github.com/rust-lang/rust/blob/ff6ee2a/library/alloc/src/raw_vec.rs>Rust <code>RawVec</code> Implementation</a></li>
<li><a href=https://en.wikipedia.org/wiki/Circular_buffer>Wiki: Circular buffer</a></li>
<li>Circular Buffer Image by Cburnett <a href=https://creativecommons.org/licenses/by-sa/3.0/>CC BY-SA-3.0</a> via Wikimedia Commons.</li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://weihanglo.tw/tags/algorithms/>Algorithms</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://weihanglo.tw/posts/2022/make-the-world-better-even-you-arent-a-super-hero/>
<span class=title>« Prev</span>
<br>
<span>不必是眾星拱月那個月 也能替世界增添光芒</span>
</a>
<a class=next href=https://weihanglo.tw/posts/2020/rust-2020-tooling-ecosystem/>
<span class=title>Next »</span>
<br>
<span>我眼中的 Rust 2020：生態工具發展</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>CC BY-NC-SA 4.0</span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>