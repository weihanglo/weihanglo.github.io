<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="本篇從 Rust Algorithm Club 移植，若欲閱讀最新版，請移駕至Rust 演算法俱樂部：雙端佇列 Deque 一文，此文不同步更新。
 雙端佇列（double-ended queue，通常縮寫為 deque）是一般化（generalize）的佇列或堆疊。比起佇列只能「先進先出 FIFO」，以及堆疊只有「後進先出 LIFO」，雙端佇列可以從最前端或最末端任意方向，在常數時間複雜度內增刪元素，更為方便。
雙端佇列常見用動態陣列或是鏈結串列實作，動態陣列的實作會因空間不夠，需要重新配置記憶體，但通常會支援隨機存取（random access）；鏈結串列的實作版本雖無法隨機存取，相對地增刪元素不需記憶體重配置。
雙端佇列顯著的缺點是：無論以動態陣列或連結串列實作，基本款實作通常無法在 $O(k)$ 時間複雜度的情況下，選定範圍內 k 個元素並取得單一切片（slice）。這肇因於動態陣列的實作通常內部儲存空間經過多次增刪，空間利用會不連續；而用鏈結串列實作者，則因不支援隨機存取而無法達到相應的複雜度。
 本次實作的程式碼置於在 rust_algorithm_club::collections::Deque API 文件中。
 架構設計 雙端佇列有個實作重點：可在常數時間從頭尾兩端增刪元素。在資料結構設計上，會儲存分別指向頭尾的兩個指標，長相可能如下：
struct Deque { head: usize, tail: usize, storage: SomeStorageType, } 第一直覺肯定是選用雙向鏈結串列可以雙向增刪節點的特性，作為解決方案。不過這裡我們採用動態陣列實作，更精確來說，底層儲存容器同樣是有兩個分別指向頭尾的指標的「環形緩衝區（Ring buffer）」。
環形緩衝區 環形緩衝區（Ring buffer） 是一個長度大小固定的緩衝區，可以視為頭尾相連的記憶體區塊，上圖雖以環狀呈現，但在計算機架構中儲存方式通常是線性陣列，再搭配指向頭端的 head 與指向尾端的 tail 兩個指標構成。
環形緩衝區有分兩種，一種是有循環的，緩衝區寫滿了就覆蓋尾端舊的資料，另一種是不會循環，緩衝區會放滿的，後者就是本次實作會用到的，以下將來探討：
 如何表示環形緩衝區為空 如何表示環形緩衝區已滿 環形緩衝區如何增加元素  這節以 ASCII chart 表示之。
 h: head t: tail x: no data [number]: has data  下面一個容量為 8，尚未有任何元素存入的環形緩衝區，這裡觀察到，若 head 與 tail 指向的儲存單元相同，換句話說兩者索引值相同，則緩衝區為空。"><meta name=theme-color content="#ffcd00"><meta property="og:title" content="雙端佇列 Deque • Weihang Lo"><meta property="og:description" content="本篇從 Rust Algorithm Club 移植，若欲閱讀最新版，請移駕至Rust 演算法俱樂部：雙端佇列 Deque 一文，此文不同步更新。
 雙端佇列（double-ended queue，通常縮寫為 deque）是一般化（generalize）的佇列或堆疊。比起佇列只能「先進先出 FIFO」，以及堆疊只有「後進先出 LIFO」，雙端佇列可以從最前端或最末端任意方向，在常數時間複雜度內增刪元素，更為方便。
雙端佇列常見用動態陣列或是鏈結串列實作，動態陣列的實作會因空間不夠，需要重新配置記憶體，但通常會支援隨機存取（random access）；鏈結串列的實作版本雖無法隨機存取，相對地增刪元素不需記憶體重配置。
雙端佇列顯著的缺點是：無論以動態陣列或連結串列實作，基本款實作通常無法在 $O(k)$ 時間複雜度的情況下，選定範圍內 k 個元素並取得單一切片（slice）。這肇因於動態陣列的實作通常內部儲存空間經過多次增刪，空間利用會不連續；而用鏈結串列實作者，則因不支援隨機存取而無法達到相應的複雜度。
 本次實作的程式碼置於在 rust_algorithm_club::collections::Deque API 文件中。
 架構設計 雙端佇列有個實作重點：可在常數時間從頭尾兩端增刪元素。在資料結構設計上，會儲存分別指向頭尾的兩個指標，長相可能如下：
struct Deque { head: usize, tail: usize, storage: SomeStorageType, } 第一直覺肯定是選用雙向鏈結串列可以雙向增刪節點的特性，作為解決方案。不過這裡我們採用動態陣列實作，更精確來說，底層儲存容器同樣是有兩個分別指向頭尾的指標的「環形緩衝區（Ring buffer）」。
環形緩衝區 環形緩衝區（Ring buffer） 是一個長度大小固定的緩衝區，可以視為頭尾相連的記憶體區塊，上圖雖以環狀呈現，但在計算機架構中儲存方式通常是線性陣列，再搭配指向頭端的 head 與指向尾端的 tail 兩個指標構成。
環形緩衝區有分兩種，一種是有循環的，緩衝區寫滿了就覆蓋尾端舊的資料，另一種是不會循環，緩衝區會放滿的，後者就是本次實作會用到的，以下將來探討：
 如何表示環形緩衝區為空 如何表示環形緩衝區已滿 環形緩衝區如何增加元素  這節以 ASCII chart 表示之。
 h: head t: tail x: no data [number]: has data  下面一個容量為 8，尚未有任何元素存入的環形緩衝區，這裡觀察到，若 head 與 tail 指向的儲存單元相同，換句話說兩者索引值相同，則緩衝區為空。"><meta property="og:url" content="https://weihanglo.tw/posts/2021/deque/"><meta property="og:site_name" content="Weihang Lo"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:tag" content="Algorithms"><meta property="article:published_time" content="2021-02-16T00:00:00+08:00"><meta property="article:modified_time" content="2021-02-16T00:00:00+08:00"><meta name=twitter:card content="summary"><meta name=generator content="Hugo 0.74.3"><title>雙端佇列 Deque • Weihang Lo</title><link rel=canonical href=https://weihanglo.tw/posts/2021/deque/><link rel=icon href=/favicon.ico><link rel=stylesheet href=/assets/css/main.ab98e12b.css><link rel=stylesheet href=/css/custom.css><style>:root{--color-accent:#ffcd00}</style></head><body class="page type-posts"><div class=site><a class=screen-reader-text href=#content>Skip to Content</a><div class=main><nav id=main-menu class="menu main-menu" aria-label="Main Menu"><div class=container><ul><li class=item><a href=/>Home</a></li><li class=item><a href=/posts/>Posts</a></li><li class=item><a href=/tags/>Tags</a></li><li class=item><a href=/about/>About</a></li></ul></div></nav><div class=header-widgets><div class=container></div></div><header id=header class="header site-header"><div class="container sep-after"><div class=header-info><p class="site-title title">Weihang Lo</p><p class="desc site-desc"></p></div></div></header><main id=content><article lang=en class=entry><header class="header entry-header"><div class="container sep-after"><div class=header-info><h1 class=title>雙端佇列 Deque</h1></div><div class=entry-meta><span class=posted-on><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg><span class=screen-reader-text>Posted on</span>
<time class=entry-date datetime=2021-02-16T00:00:00+08:00>2021, Feb 16</time></span>
<span class=reading-time><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 15 15"/></svg>13 mins read</span></div></div></header><div class="container entry-content"><blockquote><p>本篇從 <a href=https://rust-algo.club>Rust Algorithm Club</a> 移植，若欲閱讀最新版，請移駕至<a href=https://rust-algo.club/collections/deque>Rust 演算法俱樂部：雙端佇列 Deque</a> 一文，此文不同步更新。</p></blockquote><p>雙端佇列（double-ended queue，通常縮寫為 deque）是一般化（generalize）的<a href=https://rust-algo.club/collections/queue>佇列</a>或<a href=https://rust-algo.club/collections/stack>堆疊</a>。比起佇列只能「先進先出 FIFO」，以及堆疊只有「後進先出 LIFO」，雙端佇列可以從最前端或最末端任意方向，在常數時間複雜度內增刪元素，更為方便。</p><p>雙端佇列常見用動態陣列或是鏈結串列實作，動態陣列的實作會因空間不夠，需要重新配置記憶體，但通常會支援隨機存取（random access）；鏈結串列的實作版本雖無法隨機存取，相對地增刪元素不需記憶體重配置。</p><p>雙端佇列顯著的缺點是：無論以動態陣列或連結串列實作，基本款實作通常無法在 $O(k)$ 時間複雜度的情況下，選定範圍內 k 個元素並取得單一切片（slice）。這肇因於動態陣列的實作通常內部儲存空間經過多次增刪，空間利用會不連續；而用鏈結串列實作者，則因不支援隨機存取而無法達到相應的複雜度。</p><blockquote><p>本次實作的程式碼置於在 <a href=https://rust-algo.club/doc/rust_algorithm_club/collections/struct.Deque.html><code>rust_algorithm_club::collections::Deque</code></a> API 文件中。</p></blockquote><h2 id=架構設計>架構設計</h2><p>雙端佇列有個實作重點：可在<strong>常數時間</strong>從頭尾兩端增刪元素。在資料結構設計上，會儲存分別指向頭尾的兩個指標，長相可能如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Deque</span> {
    head: <span style=color:#66d9ef>usize</span>,
    tail: <span style=color:#66d9ef>usize</span>,
    storage: <span style=color:#a6e22e>SomeStorageType</span>,
}
</code></pre></div><p>第一直覺肯定是選用<a href=https://rust-algo.club/collections/doubly_linked_list>雙向鏈結串列</a>可以雙向增刪節點的特性，作為解決方案。不過這裡我們採用動態陣列實作，更精確來說，底層儲存容器同樣是有兩個分別指向頭尾的指標的「環形緩衝區（Ring buffer）」。</p><h3 id=環形緩衝區>環形緩衝區</h3><p><img src=https://upload.wikimedia.org/wikipedia/commons/thumb/b/b7/Circular_buffer.svg/240px-Circular_buffer.svg.png alt></p><p><a href=https://en.wikipedia.org/wiki/Circular_buffer>環形緩衝區（Ring buffer）</a> 是一個長度大小固定的緩衝區，可以視為頭尾相連的記憶體區塊，上圖雖以環狀呈現，但在計算機架構中儲存方式通常是線性陣列，再搭配指向頭端的 <code>head</code> 與指向尾端的 <code>tail</code> 兩個指標構成。</p><p>環形緩衝區有分兩種，一種是有循環的，緩衝區寫滿了就覆蓋尾端舊的資料，另一種是不會循環，緩衝區會放滿的，後者就是本次實作會用到的，以下將來探討：</p><ul><li>如何表示環形緩衝區為空</li><li>如何表示環形緩衝區已滿</li><li>環形緩衝區如何增加元素</li></ul><p>這節以 ASCII chart 表示之。</p><ul><li><code>h</code>: head</li><li><code>t</code>: tail</li><li><code>x</code>: no data</li><li><code>[number]</code>: has data</li></ul><p>下面一個容量為 8，尚未有任何元素存入的環形緩衝區，這裡觀察到，若 head 與 tail 指向的儲存單元相同，換句話說<strong>兩者索引值相同，則緩衝區為空</strong>。</p><pre><code>scenario: empty buffer

h
t
---------------
x x x x x x x x
---------------
</code></pre><p>再來，從頭端增加一個元素，此時 head 指向的儲存單元會存入元素，並且 head 索引加一。</p><pre><code>scenario: add one data onto head

t h
---------------
1 x x x x x x x
---------------
</code></pre><p>我們再連續加幾個元素，可以觀察到，head 最終指向的儲存單元永遠為空：</p><pre><code>scenario: add more data onto head

t   h
---------------
1 2 x x x x x x
---------------

t     h
---------------
1 2 3 x x x x x
---------------

t       h
---------------
1 2 3 4 x x x x
---------------
</code></pre><p>再來，我們從尾端增加元素，首先 tail 減一，並在移動過後的 tail 指向的儲存單元放入元素。因為 tail 原本為 0，減一之後為 -1，但索引不該有 -1，所以我們採取類似環繞算術運算（wrapping arithmetic operation）處理<a href=https://en.wikipedia.org/wiki/Integer_overflow>整數溢位</a>，因此 tail 索引從 0 變成 7（總共 8 個儲存單元）。</p><pre><code>scenario: add data onto tail

        h     t
---------------
1 2 3 4 x x x 5
---------------

</code></pre><blockquote><p>日常生活中，環繞算術運算可見於汽車儀錶板或是電錶，9999 轉過頭後會自動變成 0000，可以想像成在萬分位進位了，但我們看不到。上述減一也可以想像二進位退一位，但我們看不到，所以從 <code>0b000</code>（0）變成了 <code>0b111</code>（7）。</p></blockquote><p>我們從尾端加更多資料到緩衝區：</p><pre><code>scenario: add more data onto tail

        h   t
---------------
1 2 3 4 x x 6 5
---------------

        h t
---------------
1 2 3 4 x 7 6 5 --&gt; full
---------------
</code></pre><p>欸，怎麼加到第七個就停了？</p><p>由於目前僅探討<strong>不循環</strong>的環形緩衝區，已經規範 <code>head = tail</code> 代表緩衝區為空，如果貿然加上第八個元素，就無法分辨緩衝區是空是滿，恐導致轉盈為空。所以當緩衝區容量減去元素個數為 1 時，換句話說就是當剩餘最後一個空儲存單元時，表示該緩衝區已滿，不能再增加元素。由此推論環形緩衝區永遠會剩下一個沒使用的儲存單元。</p><p>至此，環形緩衝區的特性很符合雙端佇列的需求，總結一下：</p><ol><li><code>head = tail</code> 時，表示緩衝區為空。</li><li>容量僅剩一個儲存單元時，表示緩衝區已滿。</li><li>head 永遠指向一個空的儲存單元。</li><li>邏輯索引的映射會利用環繞算術運算配合<a href=https://en.wikipedia.org/wiki/Modulo_operation>模除運算</a>，將索引值限制在緩衝區範圍內。</li></ol><p>第四點很難懂齁？免驚，下面實作範例「<a href=#%E9%82%8F%E8%BC%AF%E7%B4%A2%E5%BC%95%E6%98%A0%E5%B0%84>邏輯索引映射</a>」段落就會解釋給你聽！</p><h3 id=手動配置記憶體>手動配置記憶體</h3><p>這一段，我們將為環形緩衝區打造屬於它自己的底層儲存空間。你可能想問，既然環形緩衝區是一個固定長度的陣列，為什麼不直接利用 Rust 標準函式庫的 <code>Vec</code> 呢？因為 <a href=https://doc.rust-lang.org/1.49.0/alloc/vec/struct.Vec.html#capacity-and-reallocation><code>Vec</code> 的容量和記憶體配置</a>屬於實作細節，雖然目前是滿了才擴充容量重新配置空間，但難保未來改變，為了更細緻控制記憶體，決定弄髒手，自行配置記憶體。</p><blockquote><p>⚠️ 以下範例有 <code>unsafe</code> 程式碼，未經審計，請謹慎使用。</p></blockquote><p>首先，宣告一個 <code>RawVec</code> 結構體，儲存了兩個欄位：</p><ul><li><code>ptr</code>：指向陣列最前端的指標，因為底層陣列會變化，所以是可變裸指標 <a href=https://doc.rust-lang.org/1.49.0/std/primitive.pointer.html><code>*mut T</code></a>。</li><li><code>cap</code>：當前 <code>RawVec</code> 的容量。注意，容量需永遠大於等於元數個數，否則會發生<a href=https://en.wikipedia.org/wiki/Buffer_overflow>緩衝區溢位</a>。</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>RawVec</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    ptr: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> T,
    cap: <span style=color:#66d9ef>usize</span>,
}
</code></pre></div><p>接下來，我們要為 <code>RawVec</code> 實作三個方法，完成自我管理記憶體的偉大志向：</p><ul><li><code>with_capacity</code>：建立指定容量的 <code>RawVec</code>，會在堆疊上配置一塊記憶體。</li><li><code>try_grow</code>：嘗試將 <code>RawVec</code> 的容量加倍，會觸發記憶體的重新配置。</li><li><code>drop</code>：實作 <a href=https://doc.rust-lang.org/1.49.0/core/ops/trait.Drop.html><code>Drop</code></a> 特徵，會釋放在堆疊上手動配置的記憶體。</li></ul><p>先來看 <code>with_capacity</code>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> RawVec<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>with_capacity</span>(cap: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#a6e22e>Self</span> {
        <span style=color:#66d9ef>let</span> layout <span style=color:#f92672>=</span> Layout::array::<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(cap).unwrap(); <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>
        <span style=color:#75715e>// 2
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> layout.size() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
            <span style=color:#75715e>// This is safe for zero sized types. However, be careful when facing
</span><span style=color:#75715e></span>            <span style=color:#75715e>// zero capacity layouts. It must be replaced with an actual pointer
</span><span style=color:#75715e></span>            <span style=color:#75715e>// before operations such as dereference or read/write.
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> ptr <span style=color:#f92672>=</span> ptr::NonNull::dangling().as_ptr(); <span style=color:#75715e>// 3
</span><span style=color:#75715e></span>            Self { ptr, cap: <span style=color:#ae81ff>0</span> }
        } <span style=color:#66d9ef>else</span> {
            <span style=color:#75715e>// This is safe because it conforms to the [safety contracts][1].
</span><span style=color:#75715e></span>            <span style=color:#75715e>//
</span><span style=color:#75715e></span>            <span style=color:#75715e>// [1]: https://doc.rust-lang.org/1.49.0/alloc/alloc/trait.GlobalAlloc.html#safety-1
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> ptr <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { alloc(layout) }; <span style=color:#75715e>// 4
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> ptr.is_null() {
                handle_alloc_error(layout);
            }
            Self {
                ptr: <span style=color:#a6e22e>ptr</span>.cast(),
                cap,
            }
        }
    }
}
</code></pre></div><ol><li>首先，我們先透過 <a href=https://doc.rust-lang.org/1.49.0/alloc/alloc/struct.Layout.html#method.array><code>Layout::array</code></a> 取得給定長度給定型別的陣列的記憶體佈局，這個佈局包含<a href=https://en.wikipedia.org/wiki/Data_structure_alignment>記憶體對齊</a>（二的倍數的位元組）與佔用記憶體大小等資訊。</li><li>再來這個 <code>layout.size()</code> 條件式是因為 <a href=https://doc.rust-lang.org/1.49.0/alloc/alloc/fn.alloc.html><code>alloc</code></a> 為 <code>unsafe</code> 函式，需遵守其安全條款：<a href=https://doc.rust-lang.org/1.49.0/alloc/alloc/trait.GlobalAlloc.html#safety-1>不允許配置大小為零的空間</a>。因此，必須判斷實際上需要配置記憶體與否，有兩種情況不需配置：<ul><li><code>T</code> 是 <a href=https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts>Zero Sized Types（ZSTs）</a>，也就是不需要空間的型別。</li><li><code>cap</code> 為零，所以不需要容量。</li></ul></li><li>若記憶體佈局所佔空間大小為零，則配置一個 <a href=https://doc.rust-lang.org/1.49.0/core/ptr/struct.NonNull.html><code>NonNull</code></a> 的迷途指標。<ul><li>對 ZST 來說，<code>NonNull</code> 是安全的，ZST 的指標算術操作無論如何加減，都會指向原始的指標位址，所以上層可以零成本的抽象操作容器的各種方法，完全不需要配置額外記憶體區塊。</li><li>對非 ZST 但容量為零的記憶體佈局來說，<code>NonNull</code> 不會有危害但要非常小心，只有在容量大於 0 且內容有初始化時，才該允許指標算術，否則可能存取到未初始化的記憶體位址，進而引發未定義行為。</li></ul></li><li>很簡單地呼叫 <a href=https://doc.rust-lang.org/1.49.0/alloc/alloc/fn.alloc.html><code>alloc</code></a> 讓 Rust 全域預設的配置器幹一塊空間資源來。因為 <code>alloc</code> 發生記憶體配置錯誤時會回傳空指標，所以這裡按照官方建議用 <code>handle_alloc_error</code> 捕捉這個行為，防止空指標被當作合法指標使用。</li></ol><blockquote><p>Rust 1.28 導入 <a href=https://doc.rust-lang.org/edition-guide/rust-2018/platform-and-target-support/global-allocators.html>Global allocators</a> 的功能，讓使用者使用 <a href=https://doc.rust-lang.org/1.49.0/std/alloc/trait.GlobalAlloc.html><code>#[global_allocator]</code></a> 屬性，替標準函式庫註冊全域的記憶體配置器，也因此，上述的 <code>alloc</code>、<code>realloc</code>、<code>dealloc</code> 即將在 <a href=https://github.com/rust-lang/rust/issues/32838>allocator_api</a> 穩定後被取代。</p></blockquote><p>看完配置記憶體，來看如何手動釋放記憶體。Rust 的 <a href=https://doc.rust-lang.org/1.49.0/core/ops/trait.Drop.html><code>Drop</code></a> 特徵有 <code>drop()</code> 方法，會在數值不需要時呼叫，類似其他語言的解構函式（destructor）。我們將釋放記憶體的邏輯放在 <code>RawVec::drop</code> 裡面，當 <code>RawVec</code> 不被需要時，就會協助我們釋放手動配置的記憶體。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Drop <span style=color:#66d9ef>for</span> RawVec<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#e6db74>/// Deallocates the underlying memory region by calculating the type layout
</span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// and number of elements.
</span><span style=color:#e6db74></span>    <span style=color:#e6db74>///
</span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// This only drop the memory block allocated by `RawVec` itself but not
</span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// dropping the contents. Callers need to drop the contents by themselves.
</span><span style=color:#e6db74></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>drop</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
        <span style=color:#66d9ef>let</span> layout <span style=color:#f92672>=</span> Layout::array::<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(self.cap).unwrap(); <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> layout.size() <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> {
            <span style=color:#75715e>// This is safe because it conforms to the [safety contracts][1].
</span><span style=color:#75715e></span>            <span style=color:#75715e>//
</span><span style=color:#75715e></span>            <span style=color:#75715e>// [1]: https://doc.rust-lang.org/1.49.0/alloc/alloc/trait.GlobalAlloc.html#safety-2
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>unsafe</span> { dealloc(self.ptr.cast(), layout) }
        }
    }
}
</code></pre></div><p>實作上，第一步取得當前記憶體佈局，並透過 <a href=https://doc.rust-lang.org/1.49.0/alloc/alloc/fn.dealloc.html><code>dealloc</code></a> 配合指標來釋放記憶體。當然，ZST 或是容量為零的狀況並沒有配置記憶體，額外判斷無需釋放。</p><p>最後，來瞧瞧 <code>try_grow</code>，為了簡化實作，每次呼叫時，記憶體區塊就單純加倍。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> RawVec<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_grow</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
        <span style=color:#66d9ef>if</span> mem::size_of::<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
            <span style=color:#66d9ef>return</span>; <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>        }

        <span style=color:#66d9ef>if</span> self.cap <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
            <span style=color:#f92672>*</span>self <span style=color:#f92672>=</span> Self::with_capacity(<span style=color:#ae81ff>1</span>); <span style=color:#75715e>// 2
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span>;
        }

        <span style=color:#66d9ef>let</span> old_layout <span style=color:#f92672>=</span> Layout::array::<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(self.cap).unwrap(); <span style=color:#75715e>// 3
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> new_cap <span style=color:#f92672>=</span> self.cap <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>;
        <span style=color:#66d9ef>let</span> new_size <span style=color:#f92672>=</span> old_layout.size() <span style=color:#f92672>*</span> new_cap;
        <span style=color:#75715e>// This is safe because it conforms to the [safety contracts][1].
</span><span style=color:#75715e></span>        <span style=color:#75715e>//
</span><span style=color:#75715e></span>        <span style=color:#75715e>// [1]: https://doc.rust-lang.org/1.49.0/alloc/alloc/trait.GlobalAlloc.html#safety-4
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> ptr <span style=color:#f92672>=</span> <span style=color:#66d9ef>unsafe</span> { realloc(self.ptr.cast(), old_layout, new_size) };
        <span style=color:#66d9ef>if</span> ptr.is_null() {
            handle_alloc_error(old_layout);
        }
        <span style=color:#75715e>// ...Old allocation is unusable and may be released from here at anytime.
</span><span style=color:#75715e></span>
        self.ptr <span style=color:#f92672>=</span> ptr.cast(); <span style=color:#75715e>// 4
</span><span style=color:#75715e></span>        self.cap <span style=color:#f92672>=</span> new_cap;
    }
}
</code></pre></div><ol><li>ZST 的空間不需加倍，直接返回。</li><li>原本空間容量為零的狀況，直接配置容量為一的空間。</li><li>準備 <code>realloc</code> 需要的參數：容量超過零的，取得舊的記憶體佈局，並乘上翻倍後的容量，算出新的空間大小。這讓之後呼叫 <code>realloc</code> 時符合其安全條款：合法指標、空間大於零、記憶體佈局為該區塊的舊佈局。</li><li>呼叫 <code>realloc</code> 之後，原先記憶體區塊可能被釋放，因此不該繼續用舊指標，此以新指標取代之。</li></ol><p>終於將手動配置記憶體的邏輯封裝在 <code>RawVec</code> 裡面，外部不需要弄髒手搞記憶體了！</p><h3 id=deque><code>Deque</code></h3><p>有了 <code>RawVec</code>，現在可以將先前缺失的 <code>SomeStorageType</code> 補上，初始化的方法也異常單純。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Deque</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    tail: <span style=color:#66d9ef>usize</span>,
    head: <span style=color:#66d9ef>usize</span>,
    ring_buf: <span style=color:#a6e22e>RawVec</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>,
}

<span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Deque<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>() -&gt; <span style=color:#a6e22e>Self</span> {
        Self {
            tail: <span style=color:#ae81ff>0</span>,
            head: <span style=color:#ae81ff>0</span>,
            ring_buf: <span style=color:#a6e22e>RawVec</span>::with_capacity(DEFAULT_CAPACITY),
        }
    }
}
</code></pre></div><p>至此，<code>Deque</code> 結構體的佈局設計告一段落，接下來就是各種方法實作。</p><h2 id=基本操作>基本操作</h2><p>身為一個雙端佇列，會有以下符合定義的基本操作：</p><ul><li><code>new</code>：初始化一個容器。</li><li><code>push_front</code>：在容器最前端新增一個元素。</li><li><code>push_back</code>：在容器最末端新增一個元素。</li><li><code>pop_front</code>：移除在容器最前端的元素。</li><li><code>pop_back</code>：移除在容器最末端的元素。</li></ul><p>另外為了提升方便性，也提供了一些方法：</p><ul><li><code>front</code>：查看容器最前端的元素。</li><li><code>back</code>：查看容器最末端的元素。</li><li><code>len</code>：檢查容器內的元素數目。</li><li><code>is_empty</code>：檢查容器內是否沒有任何元素。</li><li><code>iter</code>、<code>iter_mut</code>、<code>into_iter</code>：產生一個疊代容器內所有元素的疊代器。</li></ul><p>因為需要比較動態精細地控制記憶體，少不了一些內部方法：</p><ul><li><code>is_full</code>：檢查底層環形緩衝區是否滿載。</li><li><code>try_grow</code>：嘗試動態增加底層儲存空間。</li><li><code>wrapping_add</code>、<code>wrapping_sub</code>：確保邏輯索引的增減正確映射到底層實際索引位址。</li></ul><h3 id=邏輯索引映射>邏輯索引映射</h3><p><a href=#%E7%92%B0%E5%BD%A2%E7%B7%A9%E8%A1%9D%E5%8D%80>前一段</a>提及環形緩衝區可以從頭尾增加元素，這一段來說明「如何封裝環形緩衝區內部的物理索引」，讓外部的邏輯索引可映射到內部已儲存合法數值的緩衝區位址。</p><p>再回來看容量為 8 的雙端佇列的例子，已進行一系列操作：</p><ol><li>push_back 1</li><li>push_back 2</li><li>push_back 3</li><li>push_back 4</li><li>push_front 5</li><li>push_front 6</li></ol><pre><code>        h   t
---------------
1 2 3 4 x x 6 5
---------------
</code></pre><p>如果我們要按照順序，從佇列的 tail 到 head 印出所有元素，應該從 tail 開始，逐一增加索引，依序 6 5 1 2 3 4 印出，我們畫上虛擬的元素對應位置：</p><pre><code>~: virtual element

        h   t --&gt;
-----------------------
1 2 3 4 x x 6 5 1 2 3 4
-----------------------
                ~ ~ ~ ~
</code></pre><p>顯而易見，虛擬元素對應的索引是 8、9、10、11，已經超過緩衝區的長度，可以利用<a href=https://en.wikipedia.org/wiki/Modulo_operation>模除運算</a>計算物理索引，將索引固定在一定長度內。目前緩衝區容量為 8，所以將索引全部
模除 8：</p><ul><li><code>8 % 8 = 0</code>：對應到 [0] 的元素 1</li><li><code>9 % 8 = 1</code>：對應到 [1] 的元素 2</li><li><code>10 % 8 = 2</code>：對應到 [2] 的元素 3</li><li><code>11 % 8 = 3</code>：對應到 [3] 的元素 4</li></ul><p>模除是直觀的作法，但還有更神奇的思路：位元運算（bitwise arithmetic）。只要拿 7 跟這些索引做 <code>&</code> 位元 AND 運算，也能得到相同結果。</p><pre><code>       8        9       10       11 &lt;- Logical

  0b1000   0b1001   0b1010   0b1011
&amp; 0b0111   0b0111   0b0111   0b0111
-----------------------------------
  0b0000   0b0001   0b0010   0b0011
=      0        1        2        3 &lt;- Actual
</code></pre><p>這邊使用 7 有其意義：</p><ol><li>7 是 $2^3 - 1$，剛好 $2^n - 1$ 在是二進位制中全部位元都會是 1 ，任意數與 $2^n - 1$ 做位元 AND 運算，可以得到低位 n 位中有多少 1，同時捨棄大於 n 的位元。這個特性不偏不倚和模除的結果相同。</li><li>還記得環形緩衝區有個特性嗎：<strong>容量僅剩一個儲存單元時，表示緩衝區已滿</strong>。若能保證環形緩衝區的容量必為 $2^n$，當緩衝區滿時，元素個數定為 $2^n - 1$，完全符合前一點的特性。</li></ol><p>綜合以上，只需要保證緩衝區容量是 $2^n$，將邏輯索引映射到實際索引，只要將索引和實際可用容量（$2^n - 1$）做位元 AND 運算即可：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wrap_index</span>(index: <span style=color:#66d9ef>usize</span>, size: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>usize</span> {
    debug_assert<span style=color:#f92672>!</span>(size.is_power_of_two());
    index <span style=color:#f92672>&amp;</span> (size <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
}
</code></pre></div><p>接下來，就可以推出 <code>wrapping_add</code> 和 <code>wrapping_sub</code> 這兩支正確增減索引的方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Deque<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wrapping_add</span>(<span style=color:#f92672>&amp;</span>self, index: <span style=color:#66d9ef>usize</span>, addend: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>usize</span> {
        wrap_index(index.wrapping_add(addend), self.cap())
    }

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>wrapping_sub</span>(<span style=color:#f92672>&amp;</span>self, index: <span style=color:#66d9ef>usize</span>, subtrahend: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>usize</span> {
        wrap_index(index.wrapping_sub(subtrahend), self.cap())
    }

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>cap</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>usize</span> {
        self.ring_buf.cap()
    }
}
</code></pre></div><blockquote><p>上面用環繞算術運算（wrapping arithmetic operation） 可以使開發更方便，例如遇上 index 0 而 subtrahend 1 時，巧妙避開 $0 - 1 = -1$ 但 <code>usize</code> 不能為負的限制，直接環繞回 <code>usize::MAX</code>。</p></blockquote><p>值得一提的是，在 <code>Deque::cap</code> 這個簡單的封裝上呼叫了 <code>RawVec::cap</code>，這是新增的方法，旨在提供 ZST 一個很大很大的虛擬容量，但同時保證是 2 的次方：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> RawVec<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>cap</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>usize</span> {
        <span style=color:#66d9ef>if</span> mem::size_of::<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
            <span style=color:#ae81ff>1</span><span style=color:#66d9ef>usize</span> <span style=color:#f92672>&lt;&lt;</span> (mem::size_of::<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span>() <span style=color:#f92672>*</span> <span style=color:#ae81ff>8</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
        } <span style=color:#66d9ef>else</span> {
            self.cap
        }
    }
}
</code></pre></div><h3 id=動態增加記憶體空間>動態增加記憶體空間</h3><p>前面提及環形緩衝區是長度固定的陣列，但雙端佇列若必須固定長度就太沒路用，直觀作法就是透過加倍 <code>RawVec</code> 容量，再繼續新增元素。這個想法沒錯，但會遇到一個問題：如何確保邏輯索引在記憶體加倍後依然正確映射到實際索引？這裡舉一個實際案例：</p><pre><code>Before:
         h   t
[o o o o x x o o]

Resize:
         h   t
[o o o o x x o o | x x x x x x x x]
</code></pre><p>同樣一個容量為 8 的佇列，觸發了記憶體重新配置，所以記憶體加倍，無奈今非昔比，現在的邏輯索引 tail 無法映射到實際索引，環形緩衝區的「環」已經斷掉。若我們繼續 <code>push_back</code> 往 head 添加元素，就會覆蓋掉 tail 和後面的元素。</p><pre><code>after 4 push_back:

overwritten: ⌀
newly added: _

             t h
[o o o o o o ⌀ ⌀ | x x x x x x x x]
         _ _ _ _
</code></pre><p>有鑑於此，需要修正將斷掉的環，最簡單的作法就是將緩衝區首個索引到 head 之前的索引這段記憶體空間，複製到新翻倍的空間上，讓 tail 在 head 前面，合法的記憶體區塊再次變得連續：</p><pre><code>Before:
         h   t
[o o o o x x o o]

Resize:
         h   t
[o o o o x x o o | x x x x x x x x]

Copy:
             t           h
[x x x x x x o o | o o o o x x x x]
 _ _ _ _           _ _ _ _
</code></pre><p>了解實作的目標後，先定義個容量已滿的方法暖暖身：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_full</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>bool</span> {
        self.cap() <span style=color:#f92672>-</span> self.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>
    }
</code></pre></div><p>然後是 <code>try_grow</code> 的實作：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_grow</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
        <span style=color:#66d9ef>if</span> self.is_full() {
            <span style=color:#66d9ef>let</span> old_cap <span style=color:#f92672>=</span> self.cap(); <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>            self.ring_buf.try_grow(); <span style=color:#75715e>// 2
</span><span style=color:#75715e></span>
            <span style=color:#75715e>// 3
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> self.tail <span style=color:#f92672>&gt;</span> self.head {
                <span style=color:#75715e>// The content of ring buffer won&#39;t overlapped, so it&#39;s safe to
</span><span style=color:#75715e></span>                <span style=color:#75715e>// call `copy_nonoverlapping`. It&#39;s also safe to advance the
</span><span style=color:#75715e></span>                <span style=color:#75715e>// pointer by `old_cap` since the buffer has been doubled.
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>unsafe</span> {
                    <span style=color:#66d9ef>let</span> src <span style=color:#f92672>=</span> self.ptr(); <span style=color:#75715e>// 4-1
</span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> dst <span style=color:#f92672>=</span> self.ptr().add(old_cap); <span style=color:#75715e>// 4-2
</span><span style=color:#75715e></span>                    ptr::copy_nonoverlapping(src, dst, self.head);
                }
                self.head <span style=color:#f92672>+=</span> old_cap; <span style=color:#75715e>// 5
</span><span style=color:#75715e></span>            }
        }
    }
</code></pre></div><ol><li>將舊的容量存起來，因為當 <code>ring_buf</code> 容量翻倍後，<code>cap()</code> 返回的容量就會翻倍。</li><li>呼叫 <code>RawVec::try_grow()</code> 讓容量翻倍。</li><li>在 <code>tail</code> 大於 <code>head</code> 時，代表環在翻倍後會不連續，所以需要複製元素。</li><li>這裡用 <a href=https://doc.rust-lang.org/1.49.0/std/ptr/fn.copy_nonoverlapping.html><code>ptr::copy_nonoverlapping</code></a> 進行位元複製，此函式語義上與 C 的 <a href=https://en.cppreference.com/w/c/string/byte/memcpy><code>memcpy</code></a> 相同。<ol><li>取得緩衝區首個索引的位址，作為複製的起始位址。</li><li>取擴增後部分的首個索引位址，作為複製的目標位址。</li><li>實際呼叫 <code>memcpy</code> ，因為 head 永遠比最後一個元素索引多 1，剛好可作為元素數目。</li></ol></li><li>被複製的元素位移了 <code>old_cap</code>，因此更新 <code>head</code> 映射到正確的 <code>head + old_cap</code>。</li></ol><p>我們完成了動態增加容量的方法的同時，也維持邏輯索引映射的正確性。</p><blockquote><p>這裡維持索引正確性有稍微簡化，更高效優美的解法請參考標準函式庫 <a href=https://github.com/rust-lang/rust/blob/a118ee2/library/alloc/src/collections/vec_deque/mod.rs#L405-L447><code>VecDeque::handle_capacity_increase</code></a> 。</p></blockquote><h3 id=查看元素>查看元素</h3><p>查看首末兩段的元素非常簡單，不過由於涉及底層儲存空間的指標操作，所以需要寫 Unsafe Rust：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>front</span>(<span style=color:#f92672>&amp;</span>self) -&gt; Option<span style=color:#f92672>&lt;&amp;</span>T<span style=color:#f92672>&gt;</span> {
        <span style=color:#66d9ef>if</span> self.is_empty() {
            <span style=color:#66d9ef>return</span> None;
        }
        <span style=color:#75715e>// This is safe because the offset is wrapped inside valid memory region.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>unsafe</span> { Some(<span style=color:#f92672>&amp;*</span>self.ptr().add(self.tail)) }
    }

    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>back</span>(<span style=color:#f92672>&amp;</span>self) -&gt; Option<span style=color:#f92672>&lt;&amp;</span>T<span style=color:#f92672>&gt;</span> {
        <span style=color:#66d9ef>if</span> self.is_empty() {
            <span style=color:#66d9ef>return</span> None;
        }
        <span style=color:#66d9ef>let</span> head <span style=color:#f92672>=</span> self.wrapping_sub(self.head, <span style=color:#ae81ff>1</span>);
        <span style=color:#75715e>// This is safe because the offset is wrapped inside valid memory region.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>unsafe</span> { Some(<span style=color:#f92672>&amp;*</span>self.ptr().add(head)) }
    }
</code></pre></div><p>兩個函式都先判斷雙端佇列是否為空，再做指標位移運算，head - 1 是 <code>back</code> 的指標位移量，而 <code>front</code> 就直接回傳 tail 指向的值。其中 <code>&*</code> 是常見的 Rust 模式，可視為<strong>將裸指標「升級」為更安全的引用型別</strong>，步驟如下：</p><ol><li>解引用裸指標，得到底下的裸數值。</li><li>建立一個安全的引用，指向裸數值。</li></ol><p>這裡再來品嚐 <code>is_empty</code> 和 <code>len</code> 的實作：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>is_empty</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>bool</span> {
        self.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
    }

    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>len</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>usize</span> {
        self.head.wrapping_sub(self.tail) <span style=color:#f92672>&amp;</span> (self.cap() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
    }
</code></pre></div><p><code>len</code> 用了環繞算術運算，讓 <code>head - tail</code> 能正確算出兩者的距離，並在用前面提及的「容量 - 1」的 $2^n - 1$ 做位元 AND 運算來捨棄高位。</p><h3 id=增刪元素>增刪元素</h3><p>來看從頭尾刪除元素的 <code>pop_front</code> 和 <code>pop_back</code>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>pop_front</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
        <span style=color:#66d9ef>if</span> self.is_empty() {
            <span style=color:#66d9ef>return</span> None; <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>        }

        <span style=color:#66d9ef>let</span> tail <span style=color:#f92672>=</span> self.tail;
        self.tail <span style=color:#f92672>=</span> self.wrapping_add(self.tail, <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// 2
</span><span style=color:#75715e></span>
        <span style=color:#75715e>// This is safe because the offset is wrapped inside valid memory region.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>unsafe</span> { Some(self.ptr().add(tail).read()) } <span style=color:#75715e>// 3
</span><span style=color:#75715e></span>    }

    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>pop_back</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
        <span style=color:#66d9ef>if</span> self.is_empty() {
            <span style=color:#66d9ef>return</span> None; <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>        }

        self.head <span style=color:#f92672>=</span> self.wrapping_sub(self.head, <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// 2
</span><span style=color:#75715e></span>
        <span style=color:#75715e>// This is safe because the offset is wrapped inside valid memory region.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>unsafe</span> { Some(self.ptr().add(self.head).read()) } <span style=color:#75715e>// 3
</span><span style=color:#75715e></span>    }
</code></pre></div><ol><li>同樣先判斷雙端佇列是否為空。</li><li>再來移動到下一個合法的索引上，會是 head - 1 或 tail + 1。</li><li>最後是指標位移再讀取，注意，雖然 <a href=https://doc.rust-lang.org/1.49.0/core/ptr/fn.read.html><code>ptr::read</code></a> 會複製指標指向的值，但可視為所有權轉移到回傳值上了，這是因為倘若原始 <code>src</code> 指向的資料帶有其他指標，那麼繼續使用 <code>src</code> 就可能導致記憶體安全問題。</li></ol><p>再來看增加元素的 <code>push_front</code> 與 <code>push_back</code>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>push_front</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, elem: <span style=color:#a6e22e>T</span>) {
        self.try_grow(); <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>        self.tail <span style=color:#f92672>=</span> self.wrapping_sub(self.tail, <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// 2
</span><span style=color:#75715e></span>
        <span style=color:#75715e>// This is safe because the offset is wrapped inside valid memory region.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>unsafe</span> { self.ptr().add(self.tail).write(elem) } <span style=color:#75715e>// 3
</span><span style=color:#75715e></span>    }

    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>push_back</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, elem: <span style=color:#a6e22e>T</span>) {
        self.try_grow(); <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> head <span style=color:#f92672>=</span> self.head;
        self.head <span style=color:#f92672>=</span> self.wrapping_add(self.head, <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// 2
</span><span style=color:#75715e></span>
        <span style=color:#75715e>// This is safe because the offset is wrapped inside valid memory region.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>unsafe</span> { self.ptr().add(head).write(elem) } <span style=color:#75715e>// 3
</span><span style=color:#75715e></span>    }
</code></pre></div><ol><li>同樣先判斷雙端佇列是否為空。</li><li>再來移動到下一個合法的索引上，會是 head + 1 或 tail - 1。</li><li>最後是指標位移再寫入， <a href=https://doc.rust-lang.org/1.49.0/core/ptr/fn.write.html><code>ptr::write</code></a> 不會觸發讀取或是 drop 裸指標指向的值，但使用上仍然要確認存取該位址是否合法。</li></ol><p>以上就是 <code>Deque</code> 基本操作方法，至此，剩下最後一步「<a href=#drop>正確釋放記憶體</a>」，雙端佇列基本款就完成了。</p><h2 id=特徵>特徵</h2><p>Rust 提供許多特徵（Trait），實作特徵可以讓資料結構更方便，更符合 Rust 社群的寫作慣例。</p><h3 id=drop><code>Drop</code></h3><p>這是 <code>Deque</code> 最重要的特徵之一，也是完成 <code>Deque</code> 基本款的最後一個必要功能。<code>Drop</code> 會用來釋放儲存在 <code>Deque</code> 裡面元素的資源。實作是將所有元素 <code>pop_back</code> 出來，所有權轉移到 <code>drop</code> 函式內，函式本體執行結束後，就會自動呼叫該元素型別的 <code>drop</code> 並釋放資源。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Drop <span style=color:#66d9ef>for</span> Deque<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>drop</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
        <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(_) <span style=color:#f92672>=</span> self.pop_back() {}
    }
}
</code></pre></div><p>也許你會問「為什麼不在 <code>Deque.ring_buf</code> 的 <code>RawVec</code> 實作 <code>Drop</code> 來釋放其內容的資源？」主因是權責區分，<code>RawVec</code> 僅負責釋放它自行配置的堆疊記憶體，不清楚內容元素該如何釋放記憶體，例如內容可能是 <a href=https://en.wikipedia.org/wiki/Region-based_memory_management>Region-based memory management</a>，一起釋放效率更高，元素各別 <code>mem::drop</code> 反而拖累效率。</p><blockquote><p>事實上 <code>Deque::drop</code> 也能更高效，<a href=https://github.com/rust-lang/rust/blob/a118ee2/library/alloc/src/collections/vec_deque/mod.rs#L117-L139><code>std::colletions::VecDeque::drop</code></a> 就是直接 drop 兩個指向切片（slice）的指標，而非每個元素各自處理，雖然最後可能殊途同歸，視編譯器最佳化程度而定。</p></blockquote><h3 id=iterator><code>Iterator</code></h3><p>身為容器型別，沒有疊代器簡直不能用，Rust 提供許多疊代器特徵供實作，其中 <a href=https://doc.rust-lang.org/1.49.0/core/iter/trait.Iterator.html><code>Iterator</code></a> 特徵最為基礎且重要，實作 <code>Iterator</code> 特徵需求一個 <code>next</code> 方法，會不斷回傳下一個元素。任何實作 <code>Iterator</code> 特徵的型別，都可以放入 for 迴圈疊代。</p><p>而 Rust 常見的疊代器設計模式包含三個產生疊代器的方法：</p><ul><li><code>iter()</code>：慣例上回傳會產生不可變引用 <code>&T</code> 的 <code>Iterator</code>。</li><li><code>iter_mut()</code>：慣例上回傳會產出可變引用 <code>&mut T</code> 的 <code>Iterator</code>。</li><li><code>into_iter()</code>：慣例上回傳吃掉所有權 <code>T</code> 的 <code>Iterator</code> ，通常直接實作 <code>IntoIterator</code> 特徵即可，我們在<a href=#intoiterator>下一段</a>介紹它。</li></ul><p>實作 <code>Iterator</code> 需要新的結構體，以儲存疊代的內部狀態：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Iter</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span> {
    head: <span style=color:#66d9ef>usize</span>,
    tail: <span style=color:#66d9ef>usize</span>,
    ring_buf: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> [T],
}

<span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>IterMut</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span> {
    head: <span style=color:#66d9ef>usize</span>,
    tail: <span style=color:#66d9ef>usize</span>,
    ring_buf: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>mut</span> [T],
}
</code></pre></div><ul><li><code>Iter</code>：由於定位 <code>Deque</code> 中有元素的合法記憶體區域需要 <code>head</code> 和 <code>tail</code>，因此儲存該兩者，並且儲存底層的環形緩衝區的切片引用，方便存取元素。</li><li><code>IterMut</code>：同 <code>Iter</code>，但改為儲存可變的切片引用。</li></ul><p>來看看 <code>Iter</code> 如何實作疊代器：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span> Iterator <span style=color:#66d9ef>for</span> Iter<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;a</span> T;

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>Self::Item<span style=color:#f92672>&gt;</span> {
        <span style=color:#66d9ef>if</span> self.tail <span style=color:#f92672>==</span> self.head {
            <span style=color:#66d9ef>return</span> None; <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>        }
        <span style=color:#66d9ef>let</span> tail <span style=color:#f92672>=</span> self.tail; <span style=color:#75715e>// 2
</span><span style=color:#75715e></span>        self.tail <span style=color:#f92672>=</span> wrap_index(self.tail.wrapping_add(<span style=color:#ae81ff>1</span>), self.ring_buf.len()); <span style=color:#75715e>// 3
</span><span style=color:#75715e></span>        self.ring_buf.get(tail) <span style=color:#75715e>// 4
</span><span style=color:#75715e></span>    }
}
</code></pre></div><ol><li>當 tail 等於 head 時，代表環形緩衝區為空，直接回傳 <code>None</code>。</li><li>tail 是 <code>Deque</code> 最前端，這裡先將當前的 tail 儲存起來。</li><li>再將 Iter 上的 tail 增加 1（不影響原始 Deque），下一次呼叫 <code>next</code> 就會取得下一個元素。</li><li>利用第二步儲存的當前 tail，配合 <code>slice::get</code> 直接回傳一個元素。</li></ol><p>再來處理 <code>IterMut::next</code>，直觀上將 <code>Iter::next</code> 的 <code>self.ring_buf.get(tail)</code> 改成 <code>get_mut</code> 即可。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span> Iterator <span style=color:#66d9ef>for</span> IterMut<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>mut</span> T;

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>Self::Item<span style=color:#f92672>&gt;</span> {
        <span style=color:#66d9ef>if</span> self.tail <span style=color:#f92672>==</span> self.head {
            <span style=color:#66d9ef>return</span> None;
        }
        <span style=color:#66d9ef>let</span> tail <span style=color:#f92672>=</span> self.tail;
        self.tail <span style=color:#f92672>=</span> wrap_index(self.tail.wrapping_add(<span style=color:#ae81ff>1</span>), self.ring_buf.len());
        self.ring_buf.get_mut(tail) <span style=color:#75715e>// Change to `get_mut`
</span><span style=color:#75715e></span>    }
}
</code></pre></div><p>欸！居然編譯失敗了，到底為什麼呢？</p><pre><code class=language-console data-lang=console>error[E0495]: cannot infer an appropriate lifetime for autoref due to conflicting requirements
   --&gt; src/collections/deque/mod.rs:353:23
    |
353 |         self.ring_buf.get_mut(tail)
    |                       ^^^^^^^
    |
note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 347:5...
   --&gt; src/collections/deque/mod.rs:347:5
    |
347 |     fn next(&amp;mut self) -&gt; Option&lt;&amp;'a mut T&gt; {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: ...so that reference does not outlive borrowed content
   --&gt; src/collections/deque/mod.rs:353:9
    |
353 |         self.ring_buf.get_mut(tail)
    |         ^^^^^^^^^^^^^
note: but, the lifetime must be valid for the lifetime `'a` as defined on the impl at 344:6...
   --&gt; src/collections/deque/mod.rs:344:6
    |
344 | impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    |      ^^
note: ...so that the expression is assignable
   --&gt; src/collections/deque/mod.rs:353:9
    |
353 |         self.ring_buf.get_mut(tail)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: expected `Option&lt;&amp;'a mut T&gt;`
               found `Option&lt;&amp;mut T&gt;`
</code></pre><p>這個編譯錯誤是因為匿名的 <code>&mut self</code> 和 <code>Self::Item</code> 兩者生命週期不匹配。以下把函式簽名的生命週期展開來看：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;anonymous</span><span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;anonymous</span> <span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>mut</span> T<span style=color:#f92672>&gt;</span> {
        <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>        self.ring_buf <span style=color:#75715e>// &amp;&#39;anonymous [T]
</span><span style=color:#75715e></span>            .get_mut(tail) <span style=color:#75715e>// Some(&amp;&#39;anonymous mut T)
</span><span style=color:#75715e></span>    }
</code></pre></div><p>嗯，這不太對，我們知道 Rust 保證「就算 drop 了疊代器本身，產出的元素仍然合法」，產出的元素若為引用絕對<a href=https://users.rust-lang.org/t/iterator-lifetime-error-only-when-using-a-mutable-reference/50460/6>不會是迷途引用</a>，例如下面範例：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> iter.next().unwrap();
<span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> iter.next().unwrap();
drop(iter);
use_both(a, b);
</code></pre></div><p>但編譯器只看型別是否正確，並無法檢查執行期間的 <code>&mut self</code> 內部 <code>ring_buf</code> 和 <code>Self::Item</code> 是否活得一樣久，且由於 <code>Iterator::next</code> 函式簽名上沒有對 <code>&mut self</code> 的生命週期做任何限制，因此無法寫出下列這種預期中的生命週期限制（可視為要求 <code>'b</code> 至少活得跟 <code>'a</code> 一樣長）：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span> Iterator <span style=color:#66d9ef>for</span> IterMut<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>mut</span> T;

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;b</span>: <span style=color:#a6e22e>&#39;a</span><span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;b</span> <span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>Self::Item<span style=color:#f92672>&gt;</span> {
        <span style=color:#75715e>// ...omit
</span><span style=color:#75715e></span>    }
}

<span style=color:#75715e>// error[E0195]: lifetime parameters or bounds on method `next` do not match the trait declaration
</span><span style=color:#75715e>//    --&gt; src/collections/deque/mod.rs:347:12
</span><span style=color:#75715e>//     |
</span><span style=color:#75715e>// 347 |     fn next&lt;&#39;b: &#39;a&gt;(&amp;&#39;b mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span style=color:#75715e>//     |            ^^^^^^^^ lifetimes do not match method in trait
</span></code></pre></div><p>當然，我們知道回傳 <code>ring_buf</code> 的 <code>&'a mut T</code> 在生命週期上合法，但編譯器認不出來，所以 unsafe 又要來拯救世界。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span> Iterator <span style=color:#66d9ef>for</span> IterMut<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>mut</span> T;

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>Self::Item<span style=color:#f92672>&gt;</span> {
        <span style=color:#66d9ef>if</span> self.tail <span style=color:#f92672>==</span> self.head {
            <span style=color:#66d9ef>return</span> None;
        }
        <span style=color:#66d9ef>let</span> tail <span style=color:#f92672>=</span> self.tail;
        self.tail <span style=color:#f92672>=</span> wrap_index(self.tail.wrapping_add(<span style=color:#ae81ff>1</span>), self.ring_buf.len());
        self.ring_buf.get_mut(tail) <span style=color:#75715e>// Change to `get_mut`
</span><span style=color:#75715e></span>    }
}
</code></pre></div><ol><li>將 <code>ring_buf</code> 轉換成裸指標，因為裸指標無生命週期，所以 <code>&mut self</code> 給的限制不見了。</li><li>再把 <code>ptr</code> 指向的 <code>*mut [T]</code> 裸指標轉換成有生命週期的可變引用 <code>&mut [T]</code> 的切片。藉由 Rust 對回傳型別的自動推斷，此切片的實際型別會是 <code>&'a mut [T]</code>。Got it！這就是我們所要的。</li><li>老老實實地呼叫 <code>slice::get_mut</code>，完全正確。</li></ol><blockquote><p>這類 <em>An iterator yields borrowing contents from it<code>self</code></em> 的問題，有個俗名叫做 <em>streaming iterator</em>，可以透過<strong>泛型關聯型別</strong>（generic associated type a.k.a GAT）解決，但目前 GAT 尚未穩定。詳情可參考這篇介紹 <a href=https://lukaskalbertodt.github.io/2018/08/03/solving-the-generalized-streaming-iterator-problem-without-gats.html>GAT 與 streaming iterator workaroud</a> 的文章。</p></blockquote><blockquote><p>欸，或許你有疑惑，<code>Iter::next</code> 不也同樣有生命週期問題嗎，為什麼沒有報錯呢？這是因為<a href=https://doc.rust-lang.org/1.49.0/core/marker/trait.Copy.html#impl-Copy-130>所有 <code>&T</code> 引用都預設實作 Copy 特徵</a>，呼叫 <code>slice::get()</code> 時會<strong>自動複製</strong> <code>ring_buf</code> 的引用，因此沒有生命週期的問題，但 <code>&mut T</code> 並沒有實作 Copy 特徵，才會遇上生命週期不符的編譯錯誤。</p></blockquote><h3 id=intoiterator><code>IntoIterator</code></h3><p>相較於 <code>Interator</code>，<a href=https://doc.rust-lang.org/1.49.0/core/iter/trait.IntoIterator.html><code>IntoIterator</code></a> 是一個讓容器型別錦上添花的特徵，主要功能是：將一個型別自動轉換為有實作 <code>Iterator</code> 的型別，實作後該型別就可以直接放入 for 迴圈中。</p><p>例如下列用法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> d <span style=color:#f92672>=</span> Deque::new();
d.push_back(<span style=color:#ae81ff>1</span>);
d.push_back(<span style=color:#ae81ff>2</span>);
d.push_front(<span style=color:#ae81ff>3</span>);
d.push_front(<span style=color:#ae81ff>4</span>);

<span style=color:#66d9ef>for</span> elem <span style=color:#66d9ef>in</span> <span style=color:#f92672>&amp;</span>d {
    println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;{:?}&#34;</span>. elem);
}

<span style=color:#66d9ef>for</span> elem <span style=color:#66d9ef>in</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> d {
    <span style=color:#f92672>*</span>elem <span style=color:#f92672>*=</span> <span style=color:#f92672>*</span>elem;
}
</code></pre></div><p>實作上分三個：</p><ul><li><code>impl&lt;T> IntoIterator for Deque&lt;T></code>：將容器轉換成疊代器，並轉移容器和元素的所有權。</li><li><code>impl&lt;'a, T> IntoIterator for &'a Deque&lt;T></code>：將容器不可變引用轉換成不可變元素的疊代器。</li><li><code>impl&lt;'a, T> IntoIterator for &'a mut Deque&lt;T></code>：將容器可變引用轉換成可變元素的疊代器。</li></ul><p>先說明後面兩者。以下實作非常簡單，只要根據容器引用可變與否，對應呼叫前一段提及的 <code>Deque::iter</code> 或 <code>Deque::iter_mut</code> 即可，這算是 Rust 容器型別的一貫作法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span> IntoIterator <span style=color:#66d9ef>for</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;a</span> Deque<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;a</span> T;
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>IntoIter</span> <span style=color:#f92672>=</span> Iter<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span>;

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>into_iter</span>(self) -&gt; <span style=color:#a6e22e>Self</span>::IntoIter {
        self.iter()
    }
}

<span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span> IntoIterator <span style=color:#66d9ef>for</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>mut</span> Deque<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;a</span> <span style=color:#66d9ef>mut</span> T;
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>IntoIter</span> <span style=color:#f92672>=</span> IterMut<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;a</span>, T<span style=color:#f92672>&gt;</span>;

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>into_iter</span>(self) -&gt; <span style=color:#a6e22e>Self</span>::IntoIter {
        self.iter_mut()
    }
}
</code></pre></div><p>至於 <code>impl&lt;T> IntoIterator for Deque&lt;T></code> 和 <code>iter</code> 與 <code>iter_mut</code> 不一樣，會吃所有權，所以需要宣告額外的結構體來儲存其內部狀態，並直接實作 <code>IntoIterator</code> 要求的 <code>into_iter</code> 方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>IntoIter</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(Deque<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>);

<span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> IntoIterator <span style=color:#66d9ef>for</span> Deque<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> T;
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>IntoIter</span> <span style=color:#f92672>=</span> IntoIter<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>;

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>into_iter</span>(self) -&gt; <span style=color:#a6e22e>Self</span>::IntoIter {
        IntoIter(self)
    }
}
</code></pre></div><p>此疊代方法中，佇列內元素的所有權會轉移，所以不需要跟 <code>Iter</code> 一樣保存切片，可以直接存整個 <code>Deque</code> 作為內部狀態，拿走 <code>Deque</code> 的所有權。</p><p>既然掌控 <code>Deque</code> 所有權，實作疊代器就沒有困難了，直接將所有元素 pop 取出即可。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Iterator <span style=color:#66d9ef>for</span> IntoIter<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> T;

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>Self::Item<span style=color:#f92672>&gt;</span> {
        self.<span style=color:#ae81ff>0.</span>pop_front()
    }
}
</code></pre></div><h3 id=index-and-indexmut><code>Index</code> and <code>IndexMut</code></h3><p>用索引下標 <code>array[index]</code> 取值的語法常見於各大主流語言，Rust 提供 <a href=https://doc.rust-lang.org/1.49.0/core/ops/trait.Index.html><code>Index</code></a> 和 <a href=https://doc.rust-lang.org/1.49.0/core/ops/trait.IndexMut.html><code>IndexMut</code></a> 兩個特徵來實作這個運算子，讓容器型別更符合人體工學。</p><p>實作方法是利用<a href=#%E9%82%8F%E8%BC%AF%E7%B4%A2%E5%BC%95%E6%98%A0%E5%B0%84>邏輯索引映射</a> 段落實作的 <code>wrap_index</code> 得出實際索引，再透過指標取值即可。唯一需要注意的是越界存取（out of bound access）可能產生未定義行為，不符合 Rust 對記憶體安全的要求，所以在裸指標存取之前，就要直接 <code>assert!</code> 索引是否在元素數量的安全範圍內，防止越界存取。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Index<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Deque<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Output</span> <span style=color:#f92672>=</span> T;

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>index</span>(<span style=color:#f92672>&amp;</span>self, index: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>Self</span>::Output {
        assert<span style=color:#f92672>!</span>(index <span style=color:#f92672>&lt;</span> self.len(), <span style=color:#e6db74>&#34;Out of bound&#34;</span>);
        <span style=color:#66d9ef>let</span> index <span style=color:#f92672>=</span> self.wrapping_add(self.tail, index);
        <span style=color:#75715e>// This is safe because the offset is wrapped inside valid memory region.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>unsafe</span> { <span style=color:#f92672>&amp;*</span>self.ptr().add(index) }
    }
}

<span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> IndexMut<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>usize</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Deque<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>index_mut</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, index: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> T {
        assert<span style=color:#f92672>!</span>(index <span style=color:#f92672>&lt;</span> self.len(), <span style=color:#e6db74>&#34;Out of bound&#34;</span>);
        <span style=color:#66d9ef>let</span> index <span style=color:#f92672>=</span> self.wrapping_add(self.tail, index);
        <span style=color:#75715e>// This is safe because the offset is wrapped inside valid memory region.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>unsafe</span> { <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> <span style=color:#f92672>*</span>self.ptr().add(index) }
    }
}
</code></pre></div><h3 id=debug><code>Debug</code></h3><p>最後，介紹一下 <code>fmt::Formatter</code> 有許多方便的 debug 格式化輸出的方法，例如 <a href=https://doc.rust-lang.org/1.49.0/alloc/fmt/struct.Formatter.html#method.debug_list><code>debug_list</code></a> 可以丟一個疊代器，會轉化成序列般的輸出格式。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T: <span style=color:#a6e22e>fmt</span>::Debug<span style=color:#f92672>&gt;</span> fmt::Debug <span style=color:#66d9ef>for</span> Deque<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fmt</span>(<span style=color:#f92672>&amp;</span>self, f: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> fmt::Formatter) -&gt; <span style=color:#a6e22e>fmt</span>::Result {
        f.debug_list().entries(self.iter()).finish()
    }
}
</code></pre></div><p>當然，如果想要對 <code>RawVec</code> 實作 <code>Debug</code> 特徵，免手寫，可直接用 <code>derive</code> 屬性讓<a href=https://doc.rust-lang.org/stable/book/appendix-03-derivable-traits.html#debug-for-programmer-output>編譯器推導實作</a>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>#[derive(Debug)]</span> <span style=color:#75715e>// Add this line to derive Debug trait automatically.
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>RawVec</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
    ptr: <span style=color:#f92672>*</span><span style=color:#66d9ef>mut</span> T,
    cap: <span style=color:#66d9ef>usize</span>,
}
</code></pre></div><h2 id=效能>效能</h2><p>以環形緩衝區為底層儲存容器的雙端序列，各操作複雜度如下:</p><table><thead><tr><th>Operation</th><th>Best case</th><th>Worst case</th></tr></thead><tbody><tr><td>push_front(v)</td><td>$O(1)$</td><td>$O(1)$~</td></tr><tr><td>push_back(v)</td><td>$O(1)$</td><td>$O(1)$~</td></tr><tr><td>pop_front(v)</td><td>$O(1)$</td><td>$O(1)$~</td></tr><tr><td>pop_back(v)</td><td>$O(1)$</td><td>$O(1)$~</td></tr><tr><td>front</td><td>$O(1)$</td><td>$O(1)$</td></tr><tr><td>back</td><td>$O(1)$</td><td>$O(1)$</td></tr><tr><td>len</td><td>$O(1)$</td><td>$O(1)$</td></tr></tbody></table><blockquote><p>$n$：資料筆數。<br>$v$：資料值。<br><strong>~</strong>：平攤後的複雜度（amortized）。</p></blockquote><p>雙端佇列任何操作都是直接對 head 或 tail 的索引讀寫記憶體，複雜度皆為 $O(1)$，不過因為增減元素需要動態調整儲存空間大小，所以這些方法的時間複雜度需要平攤。</p><p>空間複雜度則是只用了一個環形緩衝區儲存元素，和幾個欄位儲存 tail、head 還有容量，因此額外空間複雜度只有 $O(1)$。</p><h2 id=參考資料>參考資料</h2><ul><li><a href=https://doc.rust-lang.org/stable/std/collections/vec_deque/struct.VecDeque.html>Rust Documentation: <code>VecDeque</code></a></li><li><a href=https://github.com/rust-lang/rust/blob/ff6ee2a/library/alloc/src/raw_vec.rs>Rust <code>RawVec</code> Implementation</a></li><li><a href=https://en.wikipedia.org/wiki/Circular_buffer>Wiki: Circular buffer</a></li><li>Circular Buffer Image by Cburnett <a href=https://creativecommons.org/licenses/by-sa/3.0/>CC BY-SA-3.0</a> via Wikimedia Commons.</li></ul></div><footer class=entry-footer><div class="container sep-before"><div class=tags><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2H12l8.59 8.59A2 2 0 0120.59 13.41z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=screen-reader-text>Tags: </span><a class=tag href=/tags/algorithms/>Algorithms</a></div></div><div style=text-align:center;padding-top:2em><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/><img src=https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png alt=cc-by-nc-sa-4></a></div></footer></article><nav class=entry-nav><div class=container><div class="prev-entry sep-before"><a href=/posts/2020/rust-2020-tooling-ecosystem/><span aria-hidden=true><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="20" y1="12" x2="4" y2="12"/><polyline points="10 18 4 12 10 6"/></svg>Previous</span>
<span class=screen-reader-text>Previous post: </span>我眼中的 Rust 2020：生態工具發展</a></div></div></nav></main><footer id=footer class=footer><div class="container sep-before"><section class="widget widget-social_menu sep-after"><nav aria-label="Social Menu"><ul><li><a href=https://github.com/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Github account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li><a href=https://facebook.com/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Facebook account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M18 2h-3a5 5 0 00-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 011-1h3z"/></svg></a></li><li><a href=https://twitter.com/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Twitter account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><title>Twitter icon</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></li><li><a href=https://linkedin.com/in/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Linkedin account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></li><li><a href=https://t.me/weihanglo target=_blank rel=noopener><span class=screen-reader-text>Open Telegram account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><title>Telegram icon</title><path d="M23.91 3.79 20.3 20.84c-.25 1.21-.98 1.5-2 .94l-5.5-4.07-2.66 2.57c-.3.3-.55.56-1.1.56-.72.0-.6-.27-.84-.95L6.3 13.7l-5.45-1.7c-1.18-.35-1.19-1.16.26-1.75l21.26-8.2c.97-.43 1.9.24 1.53 1.73z"/></svg></a></li></ul></nav></section><div class=copyright><p>&copy; 2017-2021 Weihang Lo</p></div></div></footer></div></div><script>window.__assets_js_src="/assets/js/"</script><script src=/assets/js/main.c3bcf2df.js></script><script src=/js/custom.js></script><link rel=stylesheet href=//unpkg.com/katex/dist/katex.min.css><script src=//unpkg.com/katex/dist/katex.min.js></script><script src=//unpkg.com/katex/dist/contrib/auto-render.min.js></script><script type=text/javascript>renderMathInElement(document.querySelector('.entry-content'),{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":false,"left":"$","right":"$"}]});</script></body></html>