<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Home on Weihang Lo</title><link>https://weihanglo.tw/</link><description>Recent content in Home on Weihang Lo</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 16 Feb 2021 00:00:00 +0800</lastBuildDate><atom:link href="https://weihanglo.tw/index.xml" rel="self" type="application/rss+xml"/><item><title>雙端佇列 Deque</title><link>https://weihanglo.tw/posts/2021/deque/</link><pubDate>Tue, 16 Feb 2021 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2021/deque/</guid><description>本篇從 Rust Algorithm Club 移植，若欲閱讀最新版，請移駕至Rust 演算法俱樂部：雙端佇列 Deque 一文，此文不同步更新。
雙端佇列（double-ended queue，通常縮寫為 deque）是一般化（generalize）的佇列或堆疊。比起佇列只能「先進先出 FIFO」，以及堆疊只有「後進先出 LIFO」，雙端佇列可以從最前端或最末端任意方向，在常數時間複雜度內增刪元素，更為方便。
雙端佇列常見用動態陣列或是鏈結串列實作，動態陣列的實作會因空間不夠，需要重新配置記憶體，但通常會支援隨機存取（random access）；鏈結串列的實作版本雖無法隨機存取，相對地增刪元素不需記憶體重配置。
雙端佇列顯著的缺點是：無論以動態陣列或連結串列實作，基本款實作通常無法在 $O(k)$ 時間複雜度的情況下，選定範圍內 k 個元素並取得單一切片（slice）。這肇因於動態陣列的實作通常內部儲存空間經過多次增刪，空間利用會不連續；而用鏈結串列實作者，則因不支援隨機存取而無法達到相應的複雜度。
本次實作的程式碼置於在 rust_algorithm_club::collections::Deque API 文件中。
架構設計 雙端佇列有個實作重點：可在常數時間從頭尾兩端增刪元素。在資料結構設計上，會儲存分別指向頭尾的兩個指標，長相可能如下：
struct Deque { head: usize, tail: usize, storage: SomeStorageType, } 第一直覺肯定是選用雙向鏈結串列可以雙向增刪節點的特性，作為解決方案。不過這裡我們採用動態陣列實作，更精確來說，底層儲存容器同樣是有兩個分別指向頭尾的指標的「環形緩衝區（Ring buffer）」。
環形緩衝區 環形緩衝區（Ring buffer） 是一個長度大小固定的緩衝區，可以視為頭尾相連的記憶體區塊，上圖雖以環狀呈現，但在計算機架構中儲存方式通常是線性陣列，再搭配指向頭端的 head 與指向尾端的 tail 兩個指標構成。
環形緩衝區有分兩種，一種是有循環的，緩衝區寫滿了就覆蓋尾端舊的資料，另一種是不會循環，緩衝區會放滿的，後者就是本次實作會用到的，以下將來探討：
如何表示環形緩衝區為空 如何表示環形緩衝區已滿 環形緩衝區如何增加元素 這節以 ASCII chart 表示之。
h: head t: tail x: no data [number]: has data 下面一個容量為 8，尚未有任何元素存入的環形緩衝區，這裡觀察到，若 head 與 tail 指向的儲存單元相同，換句話說兩者索引值相同，則緩衝區為空。</description></item><item><title>我眼中的 Rust 2020：生態工具發展</title><link>https://weihanglo.tw/posts/2020/rust-2020-tooling-ecosystem/</link><pubDate>Sun, 01 Nov 2020 08:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/rust-2020-tooling-ecosystem/</guid><description>最近越來越多人想要學 Rust，也有一些朋友來諮詢 Rust 相關的生態，這裡稍微囉嗦一下我眼中的 Rust 2020 吧。
如果沒有拖稿的話，文章應該會分三篇，表列如下：
Rust 生態工具發展 有多少函式庫，都在發展什麼輪子 IDE 和 Debugger、測試和開發工具支援程度 Cross-Compilation、Distribution 工具支援程度 與其他語言的 Interpolation 穩定性與 Compatibility Rust 業界採用情形 Rust 開源社群運作與生態 本篇將會介紹 「Rust 生態工具發展」。
註零：本文會有大量連結，歡迎點進去。
註一：本文是於 2020-09-19 和朋友討論的文字整理，所以會和「好讀文章」有點差距，請見諒。
註二：本文和 Rust 官方的 Call for blogs 2020 無關，主要是回顧 2020 這年 Rust 在我眼中如何存在。
與其他語言的 Interpolation 我先從「與其他語言的 Interpolation」來說：
Rust 其實一開始的定位就是 system programming language，沒有 GC，沒有 runtime（或 minimal runtime），所以跟 C 溝通非常容易，社群也有很多工具可以自動產生 header 給 C call 或是從 C lib 建立給 Rust 用的 FFI 的工具，很多社群選擇用 Rust 包裹一層 C code 就是因為 Rust 相對有許多安全檢查（預設 move semantic + object lifetime 檢查），讓 C 的 library 可稍微 robust 一點，至少 caller 這端不用自己 free 有 boundary check 不會 buffer overflow。</description></item><item><title>布隆過濾器 Bloom Filter</title><link>https://weihanglo.tw/posts/2020/bloom-filter/</link><pubDate>Fri, 28 Aug 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/bloom-filter/</guid><description>本篇從 Rust Algorithm Club 移植，若欲閱讀最新版，請移駕至Rust 演算法俱樂部：布隆過濾器 Bloom Filter 一文，此文不同步更新。
Bloom filter 是一種機率資料結構（probabilistic data structure），類似於集合，常用於需快速驗證成員是否「可能存在」或是「絕對不存在」在容器中，亦即有機會出現假陽性（false positive），但絕不會有假陰性（false negative）。
Bloom filter 的優勢是：
類似集合，可在 $O(1)$ 時間複雜度驗證成員是否存在，卻僅需相對少的儲存空間。 承上，在 0.1% 錯誤率下儲存一百萬個元素僅需 1.71 MiB。 非常容易實作的機率資料結構，僅需多次雜湊。 Bloom filter 則有以下短處：
經典款 Bloom filter 容器大小固定（fixed-size），無法動態調整儲存空間。 可能給出假陽性答案：回報存在但實際不存在，且錯誤隨數量變多上升。 自身不儲存成員資料，需要有額外的儲存資料方案。 只能新增成員，但不能移除成員（可透過變形解決）。 若輸入資料集本身離散，接近隨機存取，無法充分利用 CPU cache。 承上，因為隨機存取，不利於延伸到記憶體以外的外部儲存裝置。 Bloom filter 常見應用場景為：
資料庫利用 Bloom filter 中減少實際存取 disk 的 IO 開銷。 Chromium 瀏覽器驗證大量惡意連結。 Medium 避免推薦已推薦過的文章。 小知識：bloom 是開花之意，但 Bloom filter 和開花沒任何關係，只因發明人姓氏為 Bloom</description></item><item><title>WWW 0x17: 再見 weekly</title><link>https://weihanglo.tw/posts/2020/www-0x17/</link><pubDate>Fri, 17 Jul 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x17/</guid><description>這裡是 WWW 第貳拾參期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
Weekly 無限期停刊 很遺憾要在此宣布 Wow Weihang Weekly 將無限期停刊，這一期沒意外會是最後一期，其實很訝異自己可以堅持半年每個禮拜都出三篇文章摘要，但至今週刊已經逐漸脫離初衷。當初想寫週刊主要有兩個原因：咀嚼自己所見並分享，還有當作資料庫供未來查詢。我覺得 WWW 一直有達到分享的功效，但卻僅僅止於「摘要」，而且若當週事務繁忙，就連摘要都看起來像是摘要機器人產生出來的，這種純手工的事情，我覺得不需要人類介入，這是第一個停刊理由。
第二個則是週刊很難供自己日後查詢使用，你只能在週刊標題和標籤上下文章，了不起之後做一個站內全文搜尋，但這樣都太過繁瑣，我希望有一個心智圖或是關係圖的呈現方式將我所學串連起來，並提供給其他人參考我怎麼連結每個概念，但週刊的形式真的力有未逮，放棄這條路可能是個不錯的選擇。
相信我們會再相見的。
兩個不錯的 Rust 入門學習資源 最近越來越多人對 Rust 產生興趣，這裡就來推薦除了 TRPL 以外，可以快速上手（其實不行）的學習資源：
Rust 程式設計語言（正體中文版）：其實就是 TRPL 的翻譯版，是 Rust Taiwan 社群近期嘔心理解的作品，有任何問題請到 GitHub Repo 回應或直接寄送GitHub 站內郵件給我。 A half-hour to learn Rust：一個我覺得 blog post 幹話很多的 Rustacean 寫的三十分鐘學習 Rust（結果預計閱讀時間顯示 51 分鐘 😂），範例程式碼超多，很適合熟透其他語言的開發者閱讀，會發現 Rust 語法其實非常現代（當然還有可愛的 Turbofish)，在還沒進入 lifetime 前完全可以快速掌握 XD Tour of Rust：向 A Tour of Go 致敬的專案，Rust 版本涵蓋的主題非常全面，static/dynamic dispatch 都講了，其實已經超越入門了。但不得不說 Go 版本讀取速度快不少，而且自己魔改的 Ferris 有夠醜。總歸一句還是很值得作為入門讀物，尤其是有 Playground 很方便。 Multitenancy Webinar: Better walls make better tenants Google 的人來講怎麼做 Kubernetes 的 multi-tenancy，基本上是透過 namespace 切分 tenancy，就可以做到在同一個 cluster 內「共享資源」和「限制資源」。這篇演講完整複習了 namespace resource limit、limit range，到 pod security policy 和 network policy 種種和 multi-tenancy 相關的設定，可為抱佛腳大全。</description></item><item><title>WWW 0x16: JWT、分散式 ID 生成、k8s 安全性</title><link>https://weihanglo.tw/posts/2020/www-0x16/</link><pubDate>Sat, 20 Jun 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x16/</guid><description>這裡是 WWW 第貳拾貳期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
Kubernetes Blog: 11 Ways (Not) to Get Hacked 管理 Kubernetes 就和管理 VM 一樣，一定會遇到各種安全性問題，這篇文章提出 11 種可以增加安全性的小撇步，順便分享 @hwchiu 整理的中文版，資訊更多更完整，感恩惜福。
JWT 是否適合 session mechanism 最近翻到 The Ultimate Guide to handling JWTs on frontend clients 這篇小巧精緻的 JWT 身分驗證教學，流程圖簡明易懂，內容包括：
JWT 的結構：header.payload.signature JWT 會儲存在 client-side，不適合儲存敏感資料 JWT 不適合放在 browser storage，容易被 XSS（所以推薦 in-memory） 由於 JWT 本身無狀態，誰幹走都能奪權，請保持 JWT 過期時間不會太長，文中案例是 15 分鐘 鑑於過期比較快，請配合 HttpOnly 的 cookie 的 refresh token 來更新 JWT（但 XSS 還是有點不安全） Revoke all login sessions 可以簡單透過 refresh token 達成：刪除該使用者的所有 refresh token 就行 Server-side rendering 和 JWT + refresh token 如何整合：JWT 會存在 SSR server 上，refresh token 則是每個 page request 都會產生新的 token 有趣的是，留言提出許多 JWT 與這篇文章的實作總總問題，像是：</description></item><item><title>WWW 0x15: 你懂資料庫嗎</title><link>https://weihanglo.tw/posts/2020/www-0x15/</link><pubDate>Sat, 13 Jun 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x15/</guid><description>這裡是 WWW 第貳拾壹期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
The Best Medium-Hard Data Analyst SQL Interview Questions 作者總結自己的面試和工作經驗，整理出 Data Analyst 和 Data Scientist 的 SQL 面試題，著重在 self-join 和 window function 的相關練習。雖然 SQL 能力不是應徵資料分析職位的關鍵因子，我覺得反而是資訊工作者不可或缺的基本能力，從行銷、產品經理到工程師都應該要會 SQL DQL（Data Query Language），才能從報表、產品或系統看出洞見 。
Anxiety in product development 本文透過幾個行為觀察，分析是否掉入 anxiety driven development 的無限迴圈，這裡來個超譯摘要：
害怕輸輸去： 怕失去市佔、怕失去顧客、跟著競爭對手的 feature 跑，導致產品開發看似 agile 其實更不穩定，總是晚一個世代，將創新扼殺在時間漩渦。 一心只想贏： Unique Selling Proposition（UCP）可以理解為產品在市場上的生態區位，可以說是「獨特賣點」，利用 UCP 是好事，但以價格創造的 UCP 最羸弱，最沒使用者忠誠，最容易被其他人宰割。 並非發光的都是金子： 著急業務落後者容易短視近利，這種短期勝利可能只是短暫消除焦慮感，卻讓整個團隊陷入愁雲慘霧，回饋感漸低，特別是在專案尾聲想偷渡 feature 而不是留 buffer。 掌舵： 主要是說退一步並勾勒出真實的展望，並以此影響策略，（對不起這已超出我能理解的範圍，請自行看原文） 不可能的承諾： 焦慮讓你想要找回掌控權？你會開始將流程官僚化，寫下每個 ticket 細節與需求，這反而嚴重打擊各位的動機。 脫離官僚： 信任帶來新幸福，信任你的市場研究和策略，信任你的團隊的專業和洞見，讓他們自行成為一個有機體。 Things I Wished More Developers Knew About Databases 世界上大多數的開發者都碰過資料庫，但其實對資料庫一知半解，常常各種掉資料或是 deadlock。來自 Google 的 @rakyll 列出一些和資料庫相關常見的誤解和經驗，其實每個主題都可以獨立寫篇文章，以下稍微摘要：</description></item><item><title>WWW 0x14: Structured concurrency is promising</title><link>https://weihanglo.tw/posts/2020/www-0x14/</link><pubDate>Sat, 06 Jun 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x14/</guid><description>這裡是 WWW 第貳拾期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
Oxidizing the technical interview 非常瞎搞的一篇 Rust 面試文，面試者要求解演算法題，被面試者開始手寫 libcore 的 trait 再用 compile time const fn 做到 O(1) runtime。內文更提及 no_core 也就是不導入 libcore，本來以為是開玩笑，，沒想到還真有 no_core 的 feature，太可怕了。
MongoDB Retryable Reads and Writes 最近在做 MongoDB zero downtime 遷移與升級，本來以為已經萬無一失，卻還是在 reconfig 切換 primary 時遇到not master and slaveOk=false 這種錯誤，導致部分使用者 HTTP request status 500，推斷發生原因如下：
A server 為 primary client 與 A server 建立 TCP 連線 其他 server 選為 primary，A server 切換為 secondary， client 沿用舊連線連到 A server，發生 not master and slaveOk=false 錯誤 根據 client spec，這種錯誤會透過 retryReads 和 retryWrites 重試，而且這些功能在 MongoDB 4.</description></item><item><title>WWW 0x13: 據說網路釣魚比海釣容易成功</title><link>https://weihanglo.tw/posts/2020/www-0x13/</link><pubDate>Sat, 30 May 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x13/</guid><description>這裡是 WWW 第拾玖期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
B!tch to Boss 這應該是我看過最有趣的 addons，而且還是 Mozilla 官方出品，儘管無法有效減少 internet troll，至少一直有人叫你老闆就是爽。
Great job, Mozilla!
關於 Microsoft 的幾個 Rust 新聞與專案 最近除了 AWS 在找 Rust SDK 和 lambda 的職缺，微軟也不斷在 Rust 有所著墨，簡單介紹兩個專案新聞:
Microsoft: Why we used programming language Rust over Go for WebAssembly on Kubernetes app：微軟最初開源 Helm 的 Deis Lab 最近嘗試使用 Rust 開發一個 kubelet 叫做 krustlet，專門用來跑 WebAssembly app Microsoft: Our Rust programming language Windows runtime library is now in preview：微軟官方寫了一個 WinRT 的 Rust library，正在 preview stage，可以用 Rust 開發 UWP 了，官方技術部落格甚至有踩地雷的 demo！ To test its security mid-pandemic, GitLab tried phishing its own work-from-home staff.</description></item><item><title>WWW 0x12: Oxidized Chromium?</title><link>https://weihanglo.tw/posts/2020/www-0x12/</link><pubDate>Sat, 23 May 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x12/</guid><description>這裡是 WWW 第拾捌期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
10 Ways to Shoot Yourself in the Foot with Kubernetes, #9 Will Surprise You - Laurent Bernaille Datadog 的工程師分享十個在正式環境踩到的 K8s 坑，這邊簡單條列標題，有興趣的請直接看影片：
永遠是 DNS 的鍋 Job 沒開始，Image 又 pull 失敗惹 我不能 kubectl 了：apiserver 被 DDOS 而且 OOM killed 新 node 不能 schedule pod log volume 成長了十倍：都是一堆 audit logs 我的 pod 怎麼沒有漲到 replicas 數量 120 node 的 Cassandra cluster 爆了 Deploy 的 heartbeat 越來越慢 Runtime 壞了（寫壞的 readinessProbe、效能問題） 優雅地關閉你的 pod RedisJSON - a JSON data type for Redis Redis 可以和 NGINX 一樣支援 load 各種外掛 modules，而且 Redis 官方（RedisLabs）甚至做了可以在 Redis 裡面操作 JSON 的 RedisJSON。</description></item><item><title>WWW 0x11: 庫存文章已用罄</title><link>https://weihanglo.tw/posts/2020/www-0x11/</link><pubDate>Sat, 16 May 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x11/</guid><description>這裡是 WWW 第拾柒期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
Optimizing Kubernetes Resource Requests/Limits for Cost-Efficiency and Latency / Henning Jacobs 如何設定 K8s Pod 的資源最低需求 containers.resources.requests 和最高限制 containers.resources.limits 一直是門藝術，最低需求影響 scheduler 如何安排 pod，最高限制，尤其是 memory，可能會有 OOM kill 把 pod 殺死。
@hjabocs 分享了幾個作法：
測來測去發現停用 CPU CFS 的 latency 最小 要記得你的 node 會被 system、kubelet，還有 container runtime 佔去部分資源 😨 用 Admission Controller 設定和 requests 一樣的 limit，防止 overcommit 知道你的 pod 的 container-aware limit，例如 JVM 就是 maxheap，node cluster 就是你設定的 process number 用他的本人寫的 K8s Resouce Report 來看冗余資源可以幫你省下多少美金 可以設定一些 priorityclass 很低的 pod 作為 buffer capacity，讓資源不足時他們可以先被踢掉應急，再慢慢等 Cluster autoscaler 來 privision 新 node 又在老王賣瓜推銷自己寫的 downscaler，離峰時間自動關機省錢 Rust Logo is a Bike Chainring!</description></item><item><title>WWW 0x10: 重構不是病，寫起來要人命</title><link>https://weihanglo.tw/posts/2020/www-0x10/</link><pubDate>Sat, 09 May 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x10/</guid><description>這裡是 WWW 第拾陸期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
Graceful shutdown in Kubernetes is not always trivial 對不起，分享一篇 medium 付費牆的文章。重點節錄：
讓你的 app delay 一些時間再停止接收 connection 如果你沒辦法控制 app（code 不是你寫的），可加 preStop hook 來控制 如果加了沒用，請去看該 app 如何處理各種 Signal 請測試，請分析，不要盲目寫完就當作自己做好 graceful shutdown 三篇文章了解 TiDB 技术内幕 - 说计算 由於開源資料庫系統 TiDB 為中國人研發，中文撰寫的文件非常多，這篇主要介紹 SQL 的 relation model 如何映射到 Key-Value model，處理 index 和 unique index 也不相同。很有趣，值得一讀（TiDB/TiKV 的 source code 也是 😂）。
Rewriting the heart of our sync engine Dropbox 重寫整個電腦版的同步引擎 Nucleus，花了四年時間，節錄些（其實不是節錄）有趣發現：</description></item><item><title>WWW 0x0F: 工程師唯一需要知道的數字是伴侶生日</title><link>https://weihanglo.tw/posts/2020/www-0x0f/</link><pubDate>Sat, 02 May 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x0f/</guid><description>這裡是 WWW 第拾伍期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
Latency Numbers Every Programmer Should Know 最近替公司服務做 autoscaling，需要各種伺服器數據，好來順便做 cache 和最佳化 API，剛好讀到這篇「程式設計師都應知道的延遲數字」，心裡有個概念，大概就可以抓到服務什麼地方可能需要加強了。
Visual chart provided by ayshen
Shopee 的分布式数据库实践之路 內容比較分散的「漫談」，主要闡述蝦皮使用知名分散式資料庫 TiDB 的各種姿勢和場景。幾個有趣的點：
觀察： 原本 1000 sharding 的把表分片，改成 TiDB 同一張表，結果某個佔 90% read op 的 latency 大到會把 TiDB cluster 卡死，最後把這個效能吃緊的 read cache 在 Redis 上才解決。
感想： 省了 sharding 的管理規劃成本，多了 Redis cache 的成本，不過這層 cache 個人覺得遲早的事。
觀察： 蝦皮寫了自己的 Binlog middleware 來解析 binlog，在儲存到 Kafka 或 Redis。
感想： 感覺這種 operation log 當作事件處理的流程漸漸成為標準配備，像 MongoDB 直接提供 Change Streams 統一介面很方便，能夠以更接近資料的面向訂閱資料流當然更好。</description></item><item><title>WWW 0x0E: 親愛的，我把快取都放你腦中了</title><link>https://weihanglo.tw/posts/2020/www-0x0e/</link><pubDate>Sat, 25 Apr 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x0e/</guid><description>If you cloud end Covid-19 by sacrificing a JavaScript framework, which one would you choose and why Angular?
— @dabit3 2020.4.19
這裡是 WWW 第拾肆期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
Apple just killed Offline Web Apps while purporting to protect your privacy: why that’s A Bad Thing and why you should care 標題很聳動但無誤，Apple 決定幫 Safari 給所有 storage 加上一個**「七天沒進站就刪掉」**的限制，不負責任猜測是 app 營收不好。
Copyrighting all the melodies to avoid accidental infringement All the Music LLC 是一間懷抱夢想的公司，他們將旋律視為有限的數學排列組合，而數學是既有事實，所以沒有著作權，然後再利用程式組合不同音高的音符，每秒產生三十萬不同旋律的 midi，放在 public domain，進而保障音樂創作者不會被來路不明的著作權蟑螂吿到死。</description></item><item><title>WWW 0x0D: 已達上限</title><link>https://weihanglo.tw/posts/2020/www-0x0d/</link><pubDate>Sat, 18 Apr 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x0d/</guid><description>欸，工時系統禁止報加班！？
— Weihang Lo 2020.4
這裡是 WWW 第拾參期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
The Facts: Mozilla’s DNS over HTTPs (DoH) 西元二零二零年二月二十五日起，Firefox 預設開啟了 DNS over HTTPS（DoH）的功能，這會導致：
原本裸奔的 DNS query 可以透過 HTTPS 加密，不會再被看光光 DNS 隱私資料從被 ISP 幹走變成被 Cloudflare/NextDNS 或其他 DoH 供應商幹走 因為不會走你家的 internal DNS service，有些解析會壞掉 👋 你不會再看見色情守門員 DoH 算是一個容易起爭議的功能，例如：
Firefox DoH 預設是 Cloudflare 讓 OpenBSD 的 Firefox 版預設直接關閉 DoH Chrome 的行為則是如果 DNS provider 有支援 DoH 才自動開啟，爭議點在很多人都用 8.8.8.8 那還不是一定會走 Google 的 DoH 英國 ISP 商們票選 Mozilla 為 2019 年度網路惡棍，因為「DoH 阻撓網路監管，網路會成犯罪溫床」，帥 DoH 造成 DNS server 從集中在 ISP 變成集中在大型 DoH 網路公司 還是可以理解一下為什麼 Firefox 要預設 DoH，至於是否開啟就看個人囉。</description></item><item><title>WWW 0x0C: 未具名</title><link>https://weihanglo.tw/posts/2020/www-0x0c/</link><pubDate>Sat, 11 Apr 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x0c/</guid><description>既然疫情嚴重，連假就在家加班吧！
— Weihang Lo 2020.4
這裡是 WWW 第拾貳期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
Words Are Hard - An Essay on Communicating With Non-Programmers 以直白的口吻，分享和不同背景的人講解技術的法則。節錄重點如下：
避免用過多行話 放尊重點，不要擺出紆尊降貴的姿態 給技術解釋加些人性生動的類比 視覺化圖表比口語更易理解 承認自己不熟，但可花時間研究 願我們一起打破工程師古怪又難溝通的刻板印象。
The Raft Consensus Algorithm 最近嘗試貢獻 TiKV，順便複習一下 Raft 共識演算法 Raft 主要訴求是 Understandability，因為 Paxos 太複雜（無誤），Raft 的 server 分為三個 state：
follower：所有非 leader 的 server 都是 follower leader：所有 client request 都會送到 leader，一個 Raft group 理論上只有一個 leader candidate：達到 election timeout 的 follower 會把自己提升為 candidate，並向其他 server 發出訊息：「請 promote 我當 leader」 而 Raft 主要有兩個的步驟：</description></item><item><title>WWW 0x0B: 個資被偷和管理 DNS 紀錄，孰難孰易</title><link>https://weihanglo.tw/posts/2020/www-0x0b/</link><pubDate>Sat, 04 Apr 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x0b/</guid><description>Zoom 很讚，host 可以看你有沒有認真
— Zoom: Attendee attention tracking
這裡是 WWW 第拾壹期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
What future does the captical of Japan carry? Note: 東京不算是日本的「法定」首都
這份簡報講解 Rust 最流行的非同步框架 Tokio 運作原理，透過圖像化的流程說明 future 如何於 Tokio 互動中被 poll 和 waken，非常直觀易理解，比敝人在 COSCUP 2019 的簡報 Our Future in Rust 好太多了。
Using Zoom? Here are the privacy issues you need to be aware of 因為疫情緣故，最近 Zoom 很夯，剛好有篇文章寫到 Zoom 有很多噁心有趣的 feature：
host 可以看參與者專不專心，超過 30 喵沒在看 zoom 就會 alert 會存一份聊天紀錄給 host，但沒說 private message 會不會給 host 宣稱蒐集名字、實體位置、email、電話、公司和職稱但不會拿去賣，只會用在「business purposes」 推薦有空看看這篇文章，尤其是「How you can protect your data」一節。</description></item><item><title>WWW 0x0A: 嗯，你這塊 0xDEADBEEF</title><link>https://weihanglo.tw/posts/2020/www-0x0a/</link><pubDate>Sat, 28 Mar 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x0a/</guid><description>A programmer had a problem. He thought to himself, &amp;ldquo;I know, I&amp;rsquo;ll solve it with threads!&amp;rdquo;. has Now problems. two he
— Davidlohr Bueso
這裡是 WWW 第拾期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
The Missing Semester of Your CS Education 這是近期看過最實用導向的大學課程了！由 MIT 博士生授課，但不教死板又混亂的計算機科學，而是貼近開發者，異常實際的工具和技巧。
雖然內容對部分業界人士來說可能略淺，例如 metaprogramming 居然是在講 build system 和 makefile，不過學資訊的學生不一定熟稔，非常適合作為進入業界前先修的「失落的課程」。我自己印象最深刻的是「 &amp;hellip;if you start a command with a leading space it won’t be added to you shell history. 」真的是嚇歪我的毛，推薦大家翻翻看看。
順便提一下 JonHoo 是我有認真在看的 live-coder。嗯，應該猜的到他寫什麼語言</description></item><item><title>Kuberenetes Autoscaling 相關知識小整理</title><link>https://weihanglo.tw/posts/2020/k8s-autoscaling/</link><pubDate>Mon, 23 Mar 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/k8s-autoscaling/</guid><description>K8s 有好用的 autoscaling 功能，但你知道除了 pod 之外，node 也可以 auto scaling 嗎？帥，你知道就不用分享了啊 🚬
本文以重點整理的方式，先介紹目前常見的 Autoscaler，再介紹一些防止 pod 被亂殺的 config。
（撰於 2020-03-23，基於 Kubernetes 1.17，但 Api Versions 太多請自行查閱手冊）
讓我們歡迎第一位 Autoscaler 出場！
Cluster Autoscaler（CA） 負責調整 node-pool 的 node size scaling，屬於 cluster level autoscaler。
白話文：開新機器，關沒路用的機器 😈
Scale-up： 有 pod 的狀態是 unschedulable 時 Scale-down： 觀察 pod 總共的 memory/CPU request 是否 &amp;lt; 50%（非真實的 resource utilization）+ 沒有其他 pod/node 的條件限制 可設定 min/maxi poolsize（GKE），自己管理的叢集可以設定更多參數 會參照 PriorityClass 來調控 pod，但就是僅僅設立一條貧窮截止線，當前是 -10 ，autoscaler 不會因為低於此線的 pod 而去 scale-up，需要 scale-down 也不會理會 node 裡面是否有這種 pod 部分設定設不好會讓 CA 沒辦法 scaling CA 要關 node 然後 evict pod 時違反 pod affinity/anti-affinity 和 PodDisruptionBudget 在 node 加上 annotation 可防止被 scale down：&amp;quot;cluster-autoscaler.</description></item><item><title>WWW 0x09: 到底要不要擔心 blocking</title><link>https://weihanglo.tw/posts/2020/www-0x09/</link><pubDate>Sat, 21 Mar 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x09/</guid><description>A programmer had a problem. He thought to himself, &amp;ldquo;I know, I&amp;rsquo;ll solve it with threads!&amp;rdquo;. has Now problems. two he
— Davidlohr Bueso
這裡是 WWW 第玖期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
Stop worrying about blocking: the new async-std runtime, inspired by Go async-std 是 Rust 非同步生態中兩雄之一，欲與 tokio 爭天下。這次的實驗性更新受到 Go 語言啟發，實作了新的 scheduler，主要特點有：
更快更好更自適應 自動偵測 blocking task 並將其卸載到其他執行緒，避免阻塞 使用者可在 async context 內呼叫 blocking task 而不阻塞 要點重申：你不需函式是 blocking 還是 non-blockging，全丟到 async 裡面呼叫吧！async-std 的 runtime 會偵測，然後幫你解決一切。</description></item><item><title>WWW 0x08: 你的 Helm chart 安全嗎</title><link>https://weihanglo.tw/posts/2020/www-0x08/</link><pubDate>Sat, 14 Mar 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x08/</guid><description>organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations.
&amp;ndash; M. Conway
這裡是 WWW 第捌期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
My FOSS Story 這篇文章是 Rust 社群非常有名的 Andrew Gallant (@burntsushi) 所撰，講述了他自身與 FOSS 的糾葛。文章裡面許多篇幅在描述 FOSS 中的負面事情，不過這也是開源社群較少提及和處理的一塊。這篇文章也可以視為是 burntsushi 針對最近 Rust 社群最大的 web framework Actix 的作者退出開源界的有感而發。節錄一些我覺得可以帶著走的實用想法：
設立界線：開源即政治，網路上就是有一堆酸民，就算沒有，也有太多太多 issue 和 PR 壓得我們喘不過氣，把開源工作和個人生活切割開來，設立界線和停損點，自己的活自己安排。 遵循「比例原則」：如果提出一個問題卻僅寥寥幾行，就用寥寥幾行回覆吧。 問題重現：良好的問題回報能搭配簡單重現方式最棒，如果沒辦法，那就帶著作者一起 debug 吧！ 作者最後雖然表列許多負面行為，但也說了 FOSS 仍然有許多有趣的經驗和美好。信任為開源之本，希望這篇文章能帶給 FOSS 界打滾的我們更多啟發。
Uncharted territory – discovering vulnerabilities in public Helm Charts ⚠️⚠️⚠️ 你的 Helm chart 安全嗎 ⚠️⚠️⚠️</description></item><item><title>WWW 0x07: 為什麼薯餅要炸兩次</title><link>https://weihanglo.tw/posts/2020/www-0x07/</link><pubDate>Sat, 07 Mar 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x07/</guid><description>這裡是 WWW 第柒期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
Why is Rust the Most Loved Programming Language? 又到了推坑 Rust 的時間！這次，Intellij Rust 和 Rust Analyzer 的作者想聊聊為什麼 Rust 值得「最受喜愛的程式語言」的稱號，節錄我覺得蠻有共鳴的點：
Intellij Rust：用 Kotlin 寫的 Jetbrains IDE Rust Plugin Rust Analyzer：新一代的 Rust IDE language server Keyword First Syntax：搜尋 foo 函式只要文字搜尋 fn foo 就解決，有利於一般人開發，更使得 IDE 的 parser 更容易開發 Crates：Rust 的 crate 是一個編譯單元，但並沒有 global shared namespace，取而代之的是每個 crate 都會是你的 dependant crate 的一個 property，解決了 lib 命名衝突問題 Eq 並非多型：以前從來沒想過這個問題，但的確不同型別的比較直接 compile error 很合理，不過代價是需要寫一堆 as usize 😂 Trivial Data Types：透過 #[derive(.</description></item><item><title>WWW 0x06: Life is short. I hate GIL</title><link>https://weihanglo.tw/posts/2020/www-0x06/</link><pubDate>Sat, 29 Feb 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x06/</guid><description>這裡是 WWW 第陸期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
WebAssembly Isolation with Tyler McMullen 聽了一集個人覺得不難但蠻有內容的 Podcast，主要在講 Isolation 和 WebAssembly 相關的知識，我覺得 web developer 都很值得稍微聽一下，內容包含：
概要提點了 VM vs. Container 等各種 Isolation 的差異 WASM 如何 isolation workloads：限制 jump instruction 跳到任意的地方 etc. Fastly 為什麼要使用 WASM： 一個請求本來可能要起 container，但 container 啟動時間還是不夠快，WASM 的 isolation 可以提供安全快速的環境 WASM 使用 linear memory model：和一般的 virtual memory 不同，memory space 是連續性一個 block，需要用到更多再與系統 / 瀏覽器請求 WASM 還在解決的問題：與外部世界互動的標準還沒完整， 但可以參考 Fastly 和 Mozilla 等幾個大廠訂定的 WASI（WebAssembly System Interface） WASM 目前 function pointer 只能用 dynamic dispatch，對要求極極極高效能的應用場景較不吃香 市面上的 WASM runtime：lucet、wasmtime（個人補充 wasmer） Note: Fastly 是市面上前十大的 CDN provider（約第六）</description></item><item><title>WWW 0x05: 若單體服務是屎，微服務就是許多屎</title><link>https://weihanglo.tw/posts/2020/www-0x05/</link><pubDate>Sat, 22 Feb 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x05/</guid><description>這裡是 WWW 第伍期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
Microservices: From Design to Deployment 這是 microservices.io 的作者在 NGINX blog 上面的系列文章，雖然是 2015 年的舊文，從起源、問題，和模式來理解微服務依然詳實，看完絕對驚呼：原來現在 Cloud Native 世界這麼混亂是有些道理！
Note：不知道為什麼作者很愛提到 Netflix 各種微服務的專案，不過 Netflix 的 Java 開源微服務工具數量之多還真大開眼界
以下分別摘要每個主題：
Introduction to Microservices 簡介什麼是微服務，有什麼優缺點，並介紹微服務架構下常見元件，鋪陳給接下來的系列文，總之是個不想看可跳過的篇章。
Building Microservices: Using an API Gateway 介紹 API gateway 為什麼存在：統一微服務一致對外的介面，解耦客戶端與微服務們，但缺點是 API gateway 需要更多 operational cost，也要維持 hign availibility。
實作 API gateway 要注意以下幾點：
Performance：所有請求都會通過 gateway，所以效能和擴充性一定要好 Reactive Programming 模式：gateway 需要集合各種請求，善用 Reactive programming 模式很有幫助 Service Invocation：微服務之間就是 IPC（inter-process communication），如何透過不同模式相互 invoke 很重要，下一章會詳述 Service Discovery：如何讓服務之間互相知道彼此，就是「服務發現」的工作了，分為 client-side 和 service-side discovery，之後有專文說明 Partial Failures：微服務之間不像單體服務可以用簡單的 transaction 處理錯誤並 rollback，處理部分錯誤，保持 CAP 的 consistency 是個重要課題 Building Microservices: Inter‑Process Communication in a Microservices Architecture 介紹微服務間 IPC（inter‑process communication）的方法與模式，這是系列文中最接近實作層面的文章，很棒。</description></item><item><title>WWW 0x04: Not feeling the async pressure</title><link>https://weihanglo.tw/posts/2020/www-0x04/</link><pubDate>Sat, 15 Feb 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x04/</guid><description>這裡是 WWW 第肆期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
&amp;ldquo;Performance Matters&amp;rdquo; by Emery Berger 最近滿紅的一個關於 performance measurement 的 影片，講者演講功力深厚，把嚴肅 performance analysis/profiling 議題以輕鬆的口吻娓娓道出，非常推薦。
節錄一些我覺得有趣的點：
以 CPU 和 transistor 的發展闡述為什麼現代程式越來越注重效能 解釋 Performance Analysis 和 Performance Profiling 有什麼差別 Performance Analysis 是需要統計而且不是 eyeball statistics，然後要排除環境變因 想做 Performance Profiling 可以從另一個角度開始：讓其他不想測試的部分「變慢」 Why Discord is switching from Go to Rust 簡體中文譯文
標題乍看下有點聳動，其實內容很平實，完整交代來龍去脈：
背景：Discord ReadState 服務架構和資料結構 問題：高度手動最佳化的 Go 實作仍有兩分鐘一次的 GC spike，測試好幾個 Go 版本都沒解決 行動：用沒有 GC 的 Rust 重寫，公司內其他團隊也有成功案例 成果：各項指標皆勝原本 Go 實作，但有強調不要腦衝什麼都 RiiR 紫色是 Go，藍色是還沒升級 Tokio 0.</description></item><item><title>WWW 0x03: What Color is Your Function?</title><link>https://weihanglo.tw/posts/2020/www-0x03/</link><pubDate>Sat, 08 Feb 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x03/</guid><description>你的 function 是什麼顏色？
這裡是 WWW 第參期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
Using Rust in Windows 相較於 Microsoft 近期在 Rust 社群動作不斷，這篇文章相對平實，不過也藏了許多有趣事實。
Microsoft 覺得 Cargo 不能容易配合既有的 build system，這個其實和 Google 使用 Bazel 和 Facebook 自己搞 tool 一樣，超巨頭的工作環境太特殊了。不過也提及正在與社群接觸，微軟真的開始關注 Rust 了。 提到了 Rust 很適合做 C 的 safe wrapper，其實這個也是官方死靈書提及的作法，bindgen 真心方便。 對熟悉 C++ 的開發者而言，Rust 學習成本比想像中低了很多，一兩天配合 Rust 好用的周邊工具就可以寫出 idiomatic Rust，這和 RustConf 2019 上 Facebook 僱員的說法一致。 看到最後才發現作者是 Hyper-V team 成員，再聯想到 AWS 用 Rust 寫的 Firecracker 作為 Fargate 和 Lambda 底層的 micro vm，不難想像這些大公司用 C++寫底層的底層員工生活多苦 。 What Color is Your Function?</description></item><item><title>WWW 0x02: Distroless Docker for distressed human</title><link>https://weihanglo.tw/posts/2020/www-0x02/</link><pubDate>Sat, 01 Feb 2020 00:00:11 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x02/</guid><description>這裡是 WWW 第貳期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
How to Review a Pull Request 這份是 Rust 的 crates.io（類似 PyPI 和 rubygems）如何審閱拉取請求的文件， 和 Google 那份不太一樣，更貼近專案一點，節錄重點：
先拉到自己的本地分支，看看 PR 是否達到他宣稱的療效（檢查一般行為） 嘗試用各種手段打爆他（檢查 edge case） 如果有任何失敗，請寫清楚重新產生錯誤的流程 再來就是理解這個修改到底合不合理，是不是其實不需要 這篇 review guideline 短短的，剩下的自己看囉。
Distroless Docker: Containerizing Apps, not VMs - Matthew Moore 本文是 Google 雇員介紹 Distroless Image 演講的重點摘要，對容器化和 Docker 最佳化有興趣的朋友千萬別錯過。
Distroless GitHub Repo 在此
Q：何謂 Distroless Image
Distroless 的 distro 是指 Linux 發行版（distro），加了一個 less 就是替 docker image 瘦身，只留 app source 和 runtime 需要的 dependencies，把發行版中不必要的東西都幹掉。</description></item><item><title>WWW 0x01: 有個部署「部署「部署 K8s 」」的工具</title><link>https://weihanglo.tw/posts/2020/www-0x01/</link><pubDate>Sat, 25 Jan 2020 00:00:11 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x01/</guid><description>這裡是 WWW 第壹期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
How to Adopt Modern C++17 into Your C++ Code : Build 2018 推個 C++ 影片，微軟的大師 Herb Sutter 很精要地講完重要的 modern feature 除了 smart pointer，還包含了
move semantic string_view optional any_cast/variant RAII scoped lifetime 心法 =&amp;gt; Rust 已經是 NLL 了 Tanka：Grafana Lab 部署 k8s 的新工具 Tanka 是 Grafana Lab 開源的新部署工具，原文短又清楚，但這邊還是再疊床架屋摘要一次
YAML 不是動態語言，很多邏輯會不斷重複，不好寫 Helm 很棒，但奠基在 string template 上仍然難寫難維護，彈性不夠高，Chart 維護者沒 export 的欄位你也不能擅自修改 Helm 其實完全沒有抽象化，就算 values.yaml 挖了很多洞，開發者仍然要去看 template 裡面到底做了什麼事 這些的確都是用 Helm 部署的痛點，尤其是低度抽象化，看看精美的 stable/prometheus-operator，就會開始思考 Helm 的定位與其說是 Package manager，倒像只是一堆 yaml 的集合（事實上就是），完全沒有封裝感，更別提 Resource 修改時，很常遇到 Helm 沒辦法正確更新的痛了。</description></item><item><title>WWW 0x00: Rust 有個靜態 GC</title><link>https://weihanglo.tw/posts/2020/www-0x00/</link><pubDate>Sat, 18 Jan 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/www-0x00/</guid><description>如果員工年齡用 5 bits 存，那 J 同事的確最年輕，在 overflow 之後。
傑森 - 2020
這裡是 WWW 第零期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
Rust has a static garbage collector 雖然這篇作者是 Rust 核心成員，文章鋪陳也是為了褒 Rust，但內文講到 static typed 與 dynamic typed lang 的權衡比較，還有各種 GC 和記憶體管理的精實介紹，覺得蠻值得一讀，第一次聽到 escape analysis 也是驚呼了一下，不就是 GC 版 RAII 嗎！
Starship 小又快的 shell prompt
config 超簡單 支援顯示 Node.js/Ruby/Python/Rust/Go/AWS/K8s/&amp;hellip; 非常多環境 支援 Git rebase/merge stage 還有 status/branch 還有自帶很醜的顏色 如果覺得 oh-my-zsh 太肥的同學可以來試試看，個人用了半年沒出什麼問題。
A simple C thread pool implementation 看到一個很簡單的 300 行 threadpool in C 實作，想分享一下：</description></item><item><title>RustConf 2019 雲參訪錄（1）</title><link>https://weihanglo.tw/posts/2019/rustconf-2019-1/</link><pubDate>Sun, 29 Sep 2019 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2019/rustconf-2019-1/</guid><description>RustConf 是 Rust 社群年度最重要的研討會之一，從 Rust 在 2015 年 1.0 版正式發布之後，2016、2017、2018 連續三年都在美國舉辦，今年當然不例外，八月底在 NBA 球迷稱作 Rip City 的波特蘭舉行。由於歷史悠久，加上 Rust 社群在美國較為活躍，許多 Rust Core Team 成員都會共襄盛舉，這場研討會是 Rust 開發者絕對不能錯過的盛事。
RustConf 歷年來皆由 Tilde Inc. 旗下的 Skylight 主辦，Skylight 是一個 Rails profiler in production 的解決方案，產品中關鍵的模組用了不少 Rust。
好了，介紹完背景，這篇文章主要是紀錄小弟我「在 YouTube 上」觀看演講的心得分享，當然，RustConf 除了主要的演講軌，還有不少場邊工作坊等小活動，這就留給看倌明年到實地考察啦！
目錄 這篇文章僅為部分心得，陸續更新中。
不負責任中譯講題 內容摘要 ✅ Rust 慣老闆們如何管理 Rust 社群 回顧 Rust 過去一年成就，現在如何治理 Rust 團隊與社群，又遭遇什麼困難 ✅ Rust 大法好，統一資料科學沒煩惱 資料科學工具 Weld 底層 JIT compiler 與 Runtime 技術選型與演進過程 ✅ 鏽媳婦也得見公婆的臉書 Facebook 內部的 Rust 生態現況與如何推廣 ✅ Constant Evaluation 的五十道陰影 const eval 目前開發狀況與未來藍圖 ✅ 用 Rust 後依舊慢的 Electron MongDB Compass 用 Rust + WASM 開發 Electron 心得 Opening Keynote 回到目錄</description></item><item><title>向上管理的設計模式</title><link>https://weihanglo.tw/posts/2019/design-patterns-for-managing-up/</link><pubDate>Sun, 27 Jan 2019 15:04:29 +0800</pubDate><guid>https://weihanglo.tw/posts/2019/design-patterns-for-managing-up/</guid><description>在資訊產業工作久了，其實就會知道，成功的軟體工程師並非社會眼中的科技宅男，溝通反而是做好工作的關鍵。Kate Matsudaira 整理了四個工作上常見的難題，並利用 design pattern 的方式，點出什麼情況該怎麼做。本文抽絲剝繭整理出其中的關鍵，想閱讀原文請點 Design Patterns for Managing Up。
（撰於 2019-01-27）
1. 有人問了你不知道的問題 步驟 直說你不知道。 承攬後續找答案的計畫。 設下後續處理的時程表。 給一個簡潔且正確回應。 範例 「我不清楚，但我會先調查，午餐過後給你答覆」，或是「我不確定，但我可以問問 Bob，然後在今天下班前回覆你」，如此一來，你就是解決問題的關鍵人物。
2. 有個問題是你的錯或責任 步驟 讓相關人士了解你知道這件事，並主動處理中。（表達自己是問題的 owner） 分享解決步驟，如果尚無明確解法，告訴他們什麼時候會給 follow-up 資訊。 給一個時程表。什麼時候解決？什麼時候給 follow-up 資訊？會嘗試什麼解法？ 範例 「我們不確定造成問題的原因，但會在一小時內更新相關資訊」，別讓通訊軟體的另一端乾等焦急。
3. 有個你不認同的決定 步驟 丟掉情緒。需要時間冷靜，那就等一兩天吧。 別起爭執；試著詢問來龍去脈，探究改變的原因。 先從你的主管或決策者開始，再一起向上表達看法（別直接越級通報）。 研究並呈現相同效果的替代方案。 如果說服失敗，就支持這個計畫。務必與團隊分享你的想法，並嘗試做讓情況好一些的措施。 切記，別直接一個「No」就完全拒絕。
4. 主管給你負面回饋 步驟 只有一個：深呼吸，注意情緒，然後回覆：「知道了，未來我會更注意的！」 你仍然可以整理相關想法，寄封 email ，讓主管得知你有用心在這個回饋上。切記，主管給你負面回饋不比收到負面回饋來的簡單。
小結 其實這些方法在任何場域都很受用，但實事求是，「Shut up and show me the code」文化充斥著 IT 產業，少了一些人味，更需要注意這些眉眉角角。</description></item><item><title>HLS 串流協議二三事</title><link>https://weihanglo.tw/posts/2019/streamin-hls/</link><pubDate>Sun, 27 Jan 2019 12:31:29 +0800</pubDate><guid>https://weihanglo.tw/posts/2019/streamin-hls/</guid><description>最近開始研究很夯的直播技術，一般常見的直播方案為 HLS 以及 RTMP 等，本篇將介紹 Apple 強迫使用 大力支持的 HLS 協議。
（撰於 2017-04-10）
本文是兩年前的舊文，剛好最近又開始碰串流，所以拿出來獻醜一下。
Overview HLS 的全名為 HTTP Live Streaming，是一個由 Apple 提出並實作。HLS 是基於 HTTP 的串流協議，實作起來平易近人。如果你想要實作串流但又不想要太複雜的後台配置、或是串流須經加密驗證，HLS 會是一個不錯的解決方案。
Workflow HLS 原理非常簡單：
將欲串流的影音媒體檔案進行對應編碼切割為一系列的影音串流片段（media segment，一般為 .ts 檔）。 建立索引檔（index file，為 .m3u8 檔）作為 HLS 的播放列表（playlist），指向多個影音串流片段的路徑 。 透過 HTTP 給予 client 對應的 Response（.m3u8、.ts）。 Client 請求並解析索引檔，即可開始串流，按照播放列表逐一下載播放串流片段。 該索引檔的播放列表（playlist）播完後，再請求新的索引檔，繼續串流。 簡單來講，就是取得 .m3u8 播放列表，按照順序播放 .ts 檔，全部放完再請求下一個 .m3u8 playlist，週而復始。
Features HLS 定義許多機制，讓串流得以在各種惡劣的網路連線環境下生存。以下列出幾個 HLS 的重要特色：
Adaptability and Availability .m3u8 這個 Playlist 檔除了指向影音串流片段路徑，也可以指向其他 Playlist 的路徑。標準架構是有一個 Master Playlist 指向其他的 Media Playlist（真正包含 .</description></item><item><title>Rust: Ownership and References</title><link>https://weihanglo.tw/posts/2018/rust-ownership-and-references/</link><pubDate>Sun, 30 Sep 2018 11:07:45 +0800</pubDate><guid>https://weihanglo.tw/posts/2018/rust-ownership-and-references/</guid><description>This is a series of quick notes about the fundamentals of the Rust programming language. It would cover parts of basic concepts and patterns in Rust. As a Rust begineer and a non-native English speaker, I may make some silly mistakes in my notes. Please contact me if there are some misleading words.
(written on 2018-09-30)
Ownership and References While a program runs, it need a way to manage memory .</description></item><item><title>【譯】Rust vs. Go</title><link>https://weihanglo.tw/posts/2018/rust-vs-go/</link><pubDate>Fri, 20 Jul 2018 10:58:59 +0800</pubDate><guid>https://weihanglo.tw/posts/2018/rust-vs-go/</guid><description>本文譯自 Julio Merino 的 Rust vs. Go。Julio Merino 目前是 G 社僱員，在 G 社工作超過 8 年，無論工作內外，都接觸開發不少 Go 語言，並撰寫 Rust 點評系列文，來聽聽他對 Rust 與 Go 的想法吧。
Thanks Julio Merino for this awesome article!
歡迎來到「Rust 點評」系列特別篇，也是我在系列文開始就承諾撰寫的主題，將探討一個難以忽視的大哉問：Rust 與 Go 孰優孰劣？
這麼比較並沒有根據，所以不會有標準答案。我認為人們會把這兩種語言作伙比較只因為它們幾乎同時釋出，而且 Rust 的釋出像是在回應 Go。除此之外，兩種語言都被認為聚焦在系統軟體上（system software），但其實它們大相徑庭，就算都專注系統軟體，各自目標的軟體類型也不盡相同。
Go 可以視為「做對了的 C」或是「Python 的替代品」。Go 在開發網路伺服器與自動化工具的領域發光發熱。Rust 專注在正確與安全性，定位在 C++ 與 Haskell 之間，如同之前提及，可以視為「務實的 Haskell」。儘管 Rust 的語言抽象程度很高，它仍承諾這些抽象是零成本（zero-cost abstraction），也就是說，它應該擅長寫任何系統專案。
這篇個人點評基於我用兩種語言寫了相同的專案 sandboxfs。最初實作是用 Go，而我開發了另一個用 Rust 的實驗性改寫（還沒有完全檢驗），兩個實作都通過相同的測試套件（test suite）。除了透過這次改寫來學習語言，也因為當我分析 Go 實作版本的效能時，發現熱點總是在 Go 的執行環境（runtime），我想要嘗試看看簡單的 Rust 改寫後效能能否長進，而情況似乎就是如此。隨著這次改寫，我很訝異原本的 Go 實作版本有不少潛在的並行（concurrency）漏洞，因為許多 Rust 並不允許我利用相同的設計改寫。</description></item><item><title>4 Podcasts Software Engineers May Love</title><link>https://weihanglo.tw/posts/2018/4-podcasts-software-engineers-may-love/</link><pubDate>Mon, 09 Jul 2018 23:48:41 +0800</pubDate><guid>https://weihanglo.tw/posts/2018/4-podcasts-software-engineers-may-love/</guid><description>As a non-native English speaker, I often try several methods to improve my English skills. Listening to podcasts is one of the most interesting way to practice English, especially with fascinating topics I indulge in.
Therefore, I pick some of my favorite podcasts about software engineering to share with you. Enjoy these awesome shows and don&amp;rsquo;t forget to give them some feedback.
(written on 2018-07-09)
Software Engineering Daily
If you are not afraid of information explosion, you may love Software Engineering Daily (SE Daily).</description></item><item><title>漸進符號 Asymptotic Notation</title><link>https://weihanglo.tw/posts/2018/asymptotic-notation/</link><pubDate>Thu, 31 May 2018 23:38:59 +0800</pubDate><guid>https://weihanglo.tw/posts/2018/asymptotic-notation/</guid><description>這是個人第一次撰寫 CS 基礎知識的文章，同時也是 Rust Algorithm Club 基礎概念的首篇文章，目前 Rust Algorithm Club 尚未完工，請各位敬請期待。
（撰於 2018-05-31）
日常生活中，你會如何描述處理事情的效率？
「原來她五分鐘內可以吃掉一頭牛！」
「房間這麼小你還能擺一堆雜物？還不快收拾！」
這些描述方法，著重在處理事情的花費時間，或單位空間內的儲存量。描述演算法的效率也如此，就是「測量演算法的執行成本」，例如這個排序法花了 10 秒鐘跑完兩萬筆資料，或是這個模擬演算法很吃資源需要 32 GB 的記憶體。
然而，在不同的機器規格、環境溫濕度、程式語言、實作方式，以及有沒有放乖乖的變異影響下，相同演算法的執行成本常常不一致。為了消弭這些外部因素，讓分析演算法能夠更科學化。科學家抽絲剝繭，發明一個方法：
「統計演算法內所需操作步驟的數目。」
這是最簡單，最粗淺比較不同演算法效率的作法。
用數學表示演算法效率 「計算步驟數目」很像中小學的數學題目：某公司有三個能力相異的工程師，有的工程師一天解決一個 bug，有的工程師連續工作後效率大幅滑落。每個工程師的除蟲效率可以畫成「bug 數 - 解決 bug 所需時數」函數，橫軸為待處理的臭蟲數，縱軸為解決臭蟲所需時數，如圖一與表所示。
時數 \(\log N\) \(N\) \(N \log N\) \(N=5\) 2.236 5 8.046 \(N=30\) 5.477 30 102.036 不論從圖或表，我們都可以明確看出，當 bug 數目小時，每個工程師耗時差不多；當 bug 數目成長到一定程度時，效率好與效率差的工程師差距就很明顯了。
我們把場景拉回演算法的範疇，再闡明一次。上述的除蟲效率函數關係，可以簡單視為為「輸入資料量 - 運算成本」關係之函數。例如 \(f(x)=x^2+3x+6\)。當輸入資料量增大時，成本也隨之上升，這個用來描述演算法執行成本與輸入資料量之關係的函數，我們稱之為該演算法的「複雜度」。</description></item><item><title>2018 前端工程師面試心得</title><link>https://weihanglo.tw/posts/2018/2018-interviews/</link><pubDate>Thu, 15 Mar 2018 10:44:17 +0800</pubDate><guid>https://weihanglo.tw/posts/2018/2018-interviews/</guid><description>這是我在 2018 年 Q1 的求職面試心得，不算實習的話，就是第一次正式求職。記錄下來作爲人生里程碑，也分享給大家參考。
（撰於 2018-03-15）
背景 森林系畢業，沒參與過任何資工必修課，是個大四才起步的自學傻子，啟蒙語言是 R。大四時協助教授建置 Linux server 並擔任 server admin。畢業前進入業界擔任 iOS 開發實習生，並在畢業後轉正職，2017 年 Q3 才開始全職開發前端工程。正職工作經驗約 1.5 年。
我的優勢是學習力旺盛、有 native app 開發經驗、熟悉且熱愛 Linux 和 command-line、熟悉電子書市場與相關技術、善於溝通傾聽而不堅持己見、喜愛分享所學所見。
我的劣勢是對 UI 較不在行、CS 知識不夠紮實、臨場反應不佳易緊張、沒有跑過真正的 TDD 和嚴謹的軟體開發流程。
希望我的背景能給同樣境遇的朋友一些參照。
求職需求 由於前東家是上櫃公司，規模不小，制度完善，但也稍缺彈性，所以求職希望以新創公司為主。
以下依優先順序排列，薪資等基本需求不列入：
新創團隊或具有新創氛圍 技術討論風氣盛。 有能力相仿或更強的 co-worker，不必自幹。 工作流程明確。 重視軟體品質（CI／CD、單元測試）。 同事年齡相近。 對社會有正面意義。 應徵企業列表 以下是這段時間我有去應徵的企業，如果你對細節沒興趣，可以直接 end。
CakeResume：錄取但婉拒 Hahow 好學校：錄取 Appier 沛星互動：錄取 CakeResume 職缺：全端工程師 應徵方式：使用 CakeResume 投遞 CakeResume 的履歷 若是近年來想求職的朋友，想必對 CakeResume 不陌生，CakeResume 是線上履歷編輯平臺，利用拖拉元件的方式，快速搭建個性履歷，並提供企業刊登職缺。 動機</description></item><item><title>【譯】Tokio 內部機制：從頭理解 Rust 非同步 I/O 框架</title><link>https://weihanglo.tw/posts/2018/tokio-internals/</link><pubDate>Fri, 05 Jan 2018 08:44:43 +0800</pubDate><guid>https://weihanglo.tw/posts/2018/tokio-internals/</guid><description>本文譯自 Tokio internals: Understanding Rust&amp;rsquo;s asynchronous I/O framework from the bottom up。
Thanks David Simmons for this awesome article!
Tokio 是 Rust 的開發框架，用於開發非同步 I/O 程式（asynchronous I/O，一種事件驅動的作法，可實現比傳統同步 I/O 更好的延伸性、效能與資源利用）。可惜的是，Tokio 過於精密的抽象設計，招致難以學習的惡名。即使我讀完教程後，依然不認為自己充分內化這些抽象層，以便推斷實際發生的事情。
從前的非同步 I/O 相關開發經驗甚至阻礙我學習 Tokio。我習慣使用作業系統提供的 selection 工具（例如 Linux epoll）當作起點，再轉移至 dispatch、state machine 等等。倘若直接從 Tokio 抽象層出發，卻沒有清楚了解 epoll_wait() 在何處及如何發生，我會覺得難以連結每個概念。Tokio 與 future-driven 的方法就好像一個黑盒子。
我決定不繼續由上而下的方法學習 Tokio，反其道而行，而是透過閱讀原始碼，確切理解具體實作是如何驅動從 epoll 事件到 Future::poll() 消耗 I/O 的整個過程。我不會深入高層次的 Tokio 與 futures 使用細節，現有的教程 有更完整詳細的內容。除了簡短的小結，我也不會探討一般性的非同步 I/O 問題，畢竟這些問題都可寫個獨立的主題了。我的目標是有信心讓 futures 與 Tokio 以我所認知的方式執行。
首先，有些重要的聲明。請注意，Tokio 正快速開發中，這裡所見所聞可能不久就會過時。這個研究中我用了 tokio-core 0.</description></item><item><title>與 IE 相處的日子二：淺談網頁相容性</title><link>https://weihanglo.tw/posts/2017/days-with-internet-explorer-2/</link><pubDate>Sat, 09 Dec 2017 18:48:48 +0800</pubDate><guid>https://weihanglo.tw/posts/2017/days-with-internet-explorer-2/</guid><description>還記得之前整理的 IE 相容性 一文嗎？筆者最近參與公司新版 Web App 架構規劃與開發，又遇到許多相容性的問題，連新版瀏覽器也無法倖免。就讓我們再次探討瀏覽器相容性吧！
（撰於 2017-12-09，基於各種莫名其妙的狀況)
對相容性問題細節沒興趣的朋友，可直接跳到「我能為網頁相容性做什麼」這個章節。
目錄 相容性問題一覽 我能為網頁相容性做什麼 如果你是網頁使用者 如果你是網頁開發者 結語 相容性問題一覽 這邊列出這段紀錄的相容性問題：
語意化 HTML5 標籤 不支援 const 宣告 沒有 append 和 prepend convenience methods XHR 不支援 JSON CustomEvent 沒有建構函式 flex-grow 需要 absolute height &amp;lt;button&amp;gt; 上的 text-align 沒作用 Element 連結到 DOM 前 getComputedStyle 沒有預設值 style Computed Style 行為不一致 iframe 不支援 Data URI iframe 不支援 width 與 height style SCRIPT70: Permission denied TypedArray 少了些高階函式 不支援 custom namespace attribute selector scrollWidth 與 scrollHeight 搞反了 Multi-column layout 需給定 absolute column-width 過時的 writing-mode 標準 不穩定的 scrollWidth 與 scrollHeight 語意化 HTML5 標籤 Issue：不支援語意化 tag 就算了，部分 tag 如 &amp;lt;main&amp;gt;、&amp;lt;article&amp;gt; 還會變成 inline elements Platform：IE 11 先來個簡單的 issue。 這個 bug 默默記在心上就好，在 IE 仍苟延殘喘的年代，如要使用 semantic element，記得加上 display: block 吧！</description></item><item><title>How Is New Terminal In VS Code So Fast?</title><link>https://weihanglo.tw/posts/2017/how-is-new-terminal-in-vs-code-so-fast/</link><pubDate>Thu, 12 Oct 2017 22:05:03 +0800</pubDate><guid>https://weihanglo.tw/posts/2017/how-is-new-terminal-in-vs-code-so-fast/</guid><description>Last week, a new version (1.17) of Visual Studio Code was released. While there are many fascinating improvements and features introduced, the one that cought my eyes is &amp;ldquo;Integrated Terminal performance&amp;rdquo; section. Let&amp;rsquo;s check out what they&amp;rsquo;ve done!
(written on 2017-10-12, based on Xterm.js v3, VS Code 1.17)
Old Performance Issue The integrated terminal in VS Code is powered by another popular open-source project &amp;ldquo;Xterm.js&amp;rdquo;, which is currently maintained by SourceLair and community contributors.</description></item><item><title>使用 JavaScript 處理二進位資料</title><link>https://weihanglo.tw/posts/2017/binary-data-manipulations-in-javascript/</link><pubDate>Sun, 03 Sep 2017 23:35:55 +0800</pubDate><guid>https://weihanglo.tw/posts/2017/binary-data-manipulations-in-javascript/</guid><description>由於高度封裝與抽象，JavaScript 的執行效率比不上 C 的語言。例如 JavaScript 的 Array 下標（subscript）是根據 hash key 而非實體記憶體位址 offset 取值，雖然方便，卻多了效能開銷。當 Canvas、WebGL、WebVR 開始走紅，效能越來越受重視，如何讓 JavaScript 達到如同 C 指標般操作 binary data 變得至關重要。
存在許久但最近才變為 ES6 標準「Typed Array」就是解放 JavaScript 操作 binary data 能力的好工具！一起來了解 Typed Array 吧！
（撰於 2017-09-03，基於 ECMAScript 6+，Node.js 8.3）
Buffer v.s View ES6 引入的 Typed Array 家族，可以分為兩大類：Buffer 與 View。
所謂 Buffer 是一個指向儲存資料的記憶體區塊之物件，類似於 malloc 配置出來的空間，無法直接存取或修改 buffer 內部的資料，在 JavaScript 中 Buffer 的實作就是 ArrayBuffer。
如果我們想存取某些 buffer 底下的內容，我們需要 View（視圖），透過宣告不同資料型別的 view，電腦就會了解如何操作這段 data chunk，該當作 float32 讀取呢？抑或以 unsigned integer 來操作。</description></item><item><title>Rx 入門二：觀察者模式</title><link>https://weihanglo.tw/posts/2017/intro-rx-2-observer-pattern/</link><pubDate>Tue, 15 Aug 2017 16:32:39 +0800</pubDate><guid>https://weihanglo.tw/posts/2017/intro-rx-2-observer-pattern/</guid><description>本篇介紹 Rx 另一個重要的基礎概念 Observer pattern（觀察者模式）。
（撰於 2017-08-15，基於 Swift 3.1）
Definition 觀察者模式（Observer pattern）定義出一對多的相依關係，一個目標物件（subject）負責管理所有相依的觀察者（observer），「當 subject 自身的狀態發生變化時，自動通知所有觀察者」。
Application Observer pattern 是一個非常泛用的設計模式，幾乎各種語言都有類似的設計。例 DOM Event 架構利用 dispatchEvent 及 EventListener 達成 observer pattern。Cocoa programming 有著名的 Key-Value Observing 來觀察物件上特定 key 的 value 變化。
Pros and Cons Pros 只要介面符合，任何物件都可以是 Observer。 可確認該狀態變化是由該 subject 通知，有較高的控制權。 熱門且容易理解的設計模式。 Cons Subject 和 Observer 通常必須知道彼此之間的部分屬性，有較緊的耦合性。 Subject 管理所有 observer，容易因 reference cycle 產生 memory leak。 部份實作並無法保證不同的 observer 接收到通知的時間順序。 承上，因此 thread-safe 與 asynchronous 的 observer pattern 不容易實作。 First attempt Swift 中實作 observer pattern 非常容易，除了透過 Objective-C 傳統的 Key-value observing 以外，直觀的 Property Observer 是最好的實作方式了。以下示範 property observer 實作 observer pattern。</description></item><item><title>Rx 入門一：迭代器模式</title><link>https://weihanglo.tw/posts/2017/intro-rx-1-iterator-pattern/</link><pubDate>Tue, 15 Aug 2017 13:06:59 +0800</pubDate><guid>https://weihanglo.tw/posts/2017/intro-rx-1-iterator-pattern/</guid><description>本篇介紹 Rx 的重要基礎概念 Iterator pattern（迭代器模式）。
（撰於 2017-08-15，基於 Swift 3.1）
Definition 迭代器模式（Iterator pattern） 提供一個迭代器，讓使用者透過特定方式走訪序列（sequence）中的元素，而不需知道底層的演算法。
Application Iterator pattern 是最基本的設計模式之一，基本上大部分語言的 for-in loop 都是 iterator pattern 的實作。我們可以說 Python 的 for x in iterable 符合 iterator pattern，因為 Python 將該 iterable 封裝起來，使用者對 iterator 如何取得下一個 element 並不知情；Swift 的 for x in Sequence 中 Sequence protocol 也有 iterator 介面，並提供了 default implementation。
相反地， C 的 for (int i = 0; i &amp;lt; n; i++) 通常不認為是 iterator pattern，因為使用者知道底層資料儲存在連續的記憶體空間中，也必須自行透過指針迭代。
透過 iterator 封裝的序列（或集合），讓調用者不需關係實作，只需使用統一的 for loop，或是 map、reduce、filter 等高階函數，即操作序列中的元素，完全與演算法解耦合。</description></item><item><title>Rx 入門零：ReactiveX</title><link>https://weihanglo.tw/posts/2017/intro-rx-0-reactivex/</link><pubDate>Tue, 15 Aug 2017 09:22:37 +0800</pubDate><guid>https://weihanglo.tw/posts/2017/intro-rx-0-reactivex/</guid><description>聽過 Reactive Programming 嗎？ReactiveX（Rx）是近來火紅的技術，帶動函數響應式程式設計的熱潮。本系列將從 Rx 最原始的概念解釋起，一步步認識 Rx 巧妙的設計理念。期盼讀完後，人人心中都能有 Reactive 的思維！
（撰於 2017-08-15）
Why use Rx 狂熱驅動開發（Hype Driven Development） 是當前軟體工程界的奇特現象，每當一個新概念新技術出來，不乏有人大力吹捧。這次，小弟同樣被狂熱驅動，要來吹捧 ReactiveX（Rx）的設計理念，但在開始推坑之前，我們仍須問自己：「為什麼要用 Rx？Rx 想解決什麼問題？ 」知道一個技術的應用範圍，遠比只會拿著新玩具揮舞來得重要。
Asynchronous: unified asynchronous APIs 時至今日，軟體工程越來越複雜，無論前端或後端工程、大量的非同步（asynchronous）操作散落於程式各處，各種不同的非同步 API 如 Promise、async／await、callback function 混雜在一起，讓開發一個穩定的非同步程式變得難上加難。若考慮例外捕捉／處理，非同步的程式就會更加複雜了。
如果採用的 Rx，一切的資料或事件都會轉換為 Observable，透過 Observable，就可以在統一的 API 操作非同步的程式了。這就是 ReactiveX 的核心價值：An API for asynchronous programming with observable streams。
Declarative: better coding style Rx 除了統一非同步程式的 API 之外，另外一大特色即是採用聲明式程式設計典範（Declarative Programming Paradigm），相較於傳統命令式設計（Imperative Programming），聲明式的程式設計更能專注於程式要做什麼（What to do），而非命令程式語言該怎麼做（How to do），也減少了許多人為因素的錯誤（例如忘記調用 update 導致頁面未更新）。
就拿網頁前端工程最熱門的兩大框架 ReactJS 與 VueJS 來說，都是 Declarative 的最佳實踐案例，也帶動整個軟體工程界對 Declarative 與 Imperative 程式設計的比較與反思。</description></item><item><title>Thoughts on React Native from an iOS developer</title><link>https://weihanglo.tw/posts/2017/thoughts-on-react-native-from-an-ios-developer/</link><pubDate>Sun, 30 Jul 2017 18:16:45 +0800</pubDate><guid>https://weihanglo.tw/posts/2017/thoughts-on-react-native-from-an-ios-developer/</guid><description>About two month ago, I started making a React Native app &amp;ldquo;PyConTW 17&amp;rdquo; for the biggest annual Python conference in Taiwan (PyCon Taiwan). The app is quite simple, but still took some efforts for me to build. As a complete React newbie, I would like to share some of my thoughts about React Native.
(written on 2017-07-30, based on React Native 0.44.2)
Disclaimer: I am a junior iOS developer (about 1 year experience) without any computer science degree.</description></item><item><title>試答 Cherny 所謂「最好的前端面試題」</title><link>https://weihanglo.tw/posts/2017/answers-to-cherny-interview-questions/</link><pubDate>Wed, 26 Jul 2017 20:48:30 +0800</pubDate><guid>https://weihanglo.tw/posts/2017/answers-to-cherny-interview-questions/</guid><description>這份面試題出自於此，是從 /r/Frontend/ 連結過去的，看到如此自豪的標題和簡介，便手癢來作答，結果寫完基礎概念篇，才發現這份題目在 reddit 上被批評得體無完膚，與現代前端技術棧相差頗大。不過，一些核心概念還是挺重要的，在此分享小弟的答案，有任何錯誤，請各位不吝賜教。
（撰於 2017-07-26）
Concepts Be able to clearly explain these in words (no coding):
What is Big O notation, and why is it useful? Big O notation 是用來分析演算法複雜度的漸近符號，可以簡單視為運算成本（時間、空間）與輸入資料量的趨勢函數，例如 f(x) = x^2 + 3x + 6。當輸入資料量增大時，函數的「最高次項」最具有決定性，因此可以之表示演算法在資料量夠大時，「最多」達到怎樣的趨勢（趨勢上界），例如上例的複雜度會是 f(n) = O(n^2)。（另有 Big-Theta、Big-Omega 分別描述「趨勢區間」與「趨勢下界」）
Big O 以宏觀的角度來分析演算法，並利用簡單的數學式表示，令演算法效率分析有簡明、客觀的基準。
What is the DOM? 全名為「Document Object Model」，是 W3C 的標準之一，定義如何將文件（XML／HTML document 等）映射至一樹狀結構中，每個節點都是一個物件，並帶有操作此 DOM node 的 API。
What is the event loop? JavaScript 是單執行緒（單線程）的程式語言，任何龐大運算都可能阻塞整個程式，因此 JavaScript 設計了 message queue 配合一個不間斷的 event loop 來管理任務，當 call stack 沒有執行任何 task 時（程式閒置時），loop 便從 queue 中取第一個 message 至 call stack 調用。開發者可將 callback 加入 message queue 等待 loop 輪詢（polling），實現非同步程式，這就是 JavaScript event loop 的機制。</description></item><item><title>與 IE 相處的日子</title><link>https://weihanglo.tw/posts/2017/days-with-internet-explorer/</link><pubDate>Sat, 15 Jul 2017 11:36:04 +0800</pubDate><guid>https://weihanglo.tw/posts/2017/days-with-internet-explorer/</guid><description>近幾年來，JavaScript 可謂風生水起，從後端到前端，從 mobile 到 desktop，各種 module 滿天飛，信手拈來就是一個 web app。不過，「沒碰過 IE，別說你會做前端」，本人從超新手的角度出發，整理最近修正 IE 相容性遇到的坑與解法，給自己日後留個參考。
（撰於 2017-07-15，基於 IE 11／Edge 15）
Contents Issues Fullscreen breaks my layout! Can an image fit its container with aspect ratio? Do you know your id? Where are my children? Give me some animated SVG How an element removes itself? Same CSS, weird flexbox behavior (EXTRA) Read the fxxking standard before using custom elements Tools for dealing with compatible issues Compatible tables Cross browser testing services Virtual machines Conclusion Issues Fullscreen breaks my layout!</description></item><item><title>現代化的 JavaScript 併發 - Async Functions</title><link>https://weihanglo.tw/posts/2017/javascript-concurrency-async-function/</link><pubDate>Sun, 18 Jun 2017 12:45:34 +0800</pubDate><guid>https://weihanglo.tw/posts/2017/javascript-concurrency-async-function/</guid><description>在前一篇介紹 JavaScript Concurrency 的文章中，Promise 提供開發者安全統一的標準 API，透過 thenable 減少 callback hell，巨幅降低開發非同步程式的門檻，大大提升可維護性。不過，Promise 仍沒達到 JS 社群的目標「Write async code synchronously」。本篇文章將簡單最新的 Concurrency Solution「Async Functions」，利用同步的語法寫非同步的程式，整個人都變潮了呢！
（撰於 2017-06-17，基於 ECMAScript 7+）
Introduction Async Functions 在去年進入 Stage 4，正式成為 ECMAScript 7 標準，這對 JS 社群無疑是一大利多。截至目前為止（2017.6），實作 Async Functions 的環境有：
Node.js 7.6.0 (without --harmony) Chrome 55 Firefox 52 Safari 10.1 Edge 15 可以看到當前 Release 版的 Desktop browser 都可以用了。
從此我們不會在 callback hell 中迷失自我，不需在 then 中塞一堆 console.log，也不需使用蹩足的 generator 語法。ES7 的 async function 完成我們對非同步程式的想像。</description></item><item><title>現代化的 JavaScript 併發 - Promises</title><link>https://weihanglo.tw/posts/2017/javascript-concurrency-promise/</link><pubDate>Mon, 12 Jun 2017 23:02:43 +0800</pubDate><guid>https://weihanglo.tw/posts/2017/javascript-concurrency-promise/</guid><description>所謂良好的使用者體驗，有個基本要求：「能即時回饋使用者的互動」。在 Mobile Native，常利用多線程（Multi-threading）分散主線程（main thread）的負擔，讓其能即時響應使用者點擊等事件。反觀 web 端的霸主 JavaScript，卻是易被阻塞的單線程（single-threaded）語言，不過藉由 Event Loop 的設計，仍可達成非同步操作，線程不至完全阻塞，或多或少彌補了單線程的不足。
眾所周知，Concurrency is hard！設計不良的非同步程式，絕對會讓你痛不欲生。本文將簡單介紹 Promise 這個現代 JavaScript Concurrency Features，讓 JS 新標準帶你從地獄回到另一個煉獄人間。
（撰於 2017-06-12，基於 ECMAScript 6+）
Definition Promise 是一個非同步操作的代理物件（proxy object），表示這個非同步操作在未來終將實現（或產生錯誤），並同時取得該操作的結果值。Promise 並不侷限在 JavaScript 中，它是一個概念，有時候又稱為 Deferred、Future，維基百科有詳盡的介紹。
Features Promise 是 ES6 引入的標準之一，主要實踐了 Promise/A+ 組織訂定的標準，該標準平息了社群長期對 Promise 實作的爭論，使得各家的非同步操作終於有了相同的 API。以下是個人認為 ES6 Promise 的幾個重要特色：
截止當前（2017.6），Promise 在瀏覽器的支援程度已接近 90%。（主流瀏覽器僅 IE 11 不支援） 統一、可預期的 callback 調用與 error handling 流程。 callback 定義清楚完善，沒有重複調用或改變狀態的疑慮。 將有序的 promises 串連起來（promise chaining），解除 callback hell 問題。 可自由組合多個 promises（promise composition)，實作 sequential 或 paralleling 的 promise chain。 Terminology 開始之前，先了解 Promise 相關的術語：</description></item><item><title>理解 Swift Generics</title><link>https://weihanglo.tw/posts/2017/swift-generics/</link><pubDate>Mon, 08 May 2017 22:28:09 +0800</pubDate><guid>https://weihanglo.tw/posts/2017/swift-generics/</guid><description>泛型程式設計（Generic Programming） 是經典的程式設計典範之一，不論是老牌的 C++，還是潮潮的 TypeScript，都能一睹泛型的風采。近年來，程式設計吹的是 static typing 風，泛型又開始被廣泛討論。
本篇將簡單介紹泛型的背景，再來理解並學習 Swift 語言的泛型寫法。
（撰於 2017-05-08，基於 Swift 3.1）
Definition 想像一下，有個需求是要交換兩個變數儲存的值，現在欲交換的變數是 int type，因此實作了 void swapInt(*int, *int) 的函式；接下來要交換的是 double，又寫了 void swapFloat(*double, *double)，但兩個函式實作幾乎一樣（交換指標指向的值），如果還有 float、char 等其他 n 種 data types，就必須寫 n 個版本的實作。如果程式語言支援函式重載，可以把 function name 都改成 swap，降低函式調用端的複雜度，但依然沒解決重複的問題。
泛型程式設計（Generic Programming）目的就是「消弭因為不同資料型態，而重複實作相同的演算法」。維基百科寫得非常清楚：
&amp;hellip; is a style of computer programming in which algorithms are written in terms of types to-be-specified-later that are then instantiated when needed for specific types provided as parameters</description></item><item><title>理解 Swift 的 Error Handling</title><link>https://weihanglo.tw/posts/2017/swift-error-handling/</link><pubDate>Mon, 10 Apr 2017 16:36:33 +0800</pubDate><guid>https://weihanglo.tw/posts/2017/swift-error-handling/</guid><description>如何利用 Swift 的語言特性來處理例外？使用 Optional 是常見的做法。如果成功就返回 value，失敗則返回 nil，這種模式常用於簡單的狀況。然而，面對複雜的情況，例如網路請求，若只簡單返回 nil，調用者並無法得知是 404，抑或 500。為了解決這個問題，我們必須緊緊抱住錯誤／例外處理的大腿。
（撰於 2017-04-10，基於 Swift 3.1）
Intro of Exception Handling 在開始介紹 Swift 例外處理之前，先來了解什麼是例外處理。維基百科道：
&amp;hellip;is the process of responding to the occurrence, during computation, of exceptions – anomalous or exceptional conditions requiring special processing – often changing the normal flow of program execution.
簡單來說，就是某些例外狀況，需要特別的處理，這個處理過程就稱為例外處理，而這個處理常伴隨程式流程轉移改變。
寫習慣 C++／Objective-C 的同學，想必很排斥寫 try-catch 這種吃效能、又易出錯的例外處理，明明 if&amp;hellip;else 就能打遍天下嘛！而喜歡 Python／Ruby 的朋友對 raise 和各種 Exceptions 一定不陌生，甚至 Python 底層的 iterator 都是用 StopIteration Exception 實作。依照各個程式語言的設計，例外處理大致分為兩類：</description></item><item><title>大前端時代的工具箱</title><link>https://weihanglo.tw/posts/2017/fed-toolchain/</link><pubDate>Fri, 10 Mar 2017 15:36:46 +0800</pubDate><guid>https://weihanglo.tw/posts/2017/fed-toolchain/</guid><description>在大前端的時代，開發 Web app 不再像以前使用一個 jQuery 的 CDN 這麼容易，從 html 模板的抉擇，css 預處理器的挑選，Javascript 模組化的方法，自動化工具的使用等等，都是一門學問。本文將從建置基本的前端開發環境起頭，簡單介紹個人愛用現代常用的前端開發工具。
（撰於 2017-03-10）
Contents Node.js 安裝 Node.js Node.js 內建模組與變數 Node.js 版本管理工具 NPM 套件模組管理工具 package.json NPM 常用指令 預處理器／轉譯器 CSS 預處理器 CSS 後處理器 ES6+／Babel 自動化工具／打包工具 Gulp Webpack 程式碼品質 測試 靜態程式語法檢查 小結 Reference （以下環境皆以 macOS 為例）
Node.js Node.js 是一個 Javascript 的運行環境，基於 Google V8 Engine。在 Node.js 尚未出現前，Javascript 只能運行在瀏覽器客戶端，功能受限於瀏覽器沙盒（sandbox）與廠商實作。Node.</description></item><item><title>Carthage 套件管理工具</title><link>https://weihanglo.tw/posts/2017/carthage-intro/</link><pubDate>Sun, 05 Mar 2017 08:45:57 +0800</pubDate><guid>https://weihanglo.tw/posts/2017/carthage-intro/</guid><description>Carthage 是一個較新的 Cocoa 開發第三方套件管理工具，相較於知名 CocoaPods 管理工具的複雜配置，輕巧的 Carthage 在推出之後廣受 Swift 社群喜愛。
（撰於 2017-03-05，基於 Carthage 0.20: Unary, Binary, Ternary）
特色 時代潮流：Written in Swift! (v.s. CocoaPods in Ruby) 主流現代：iOS 8+, dynamic framework only 去中心化：無提供類似 cocoapods、npm 這種中心儲存庫。 非入侵式：不會修改 Xcode 相關配置，耦合性低。 快速上手 從終端環境安裝 Carthage brew install carthage 如果還沒有裝 homebrew，請來這下載
建立一個 Carfile，列出欲使用的模組，例如： github &amp;#34;Alamofire/Alamofire&amp;#34; ~&amp;gt; 4.4 github &amp;#34;ReactiveX/RxSwift&amp;#34; ~&amp;gt; 3.0 在終端環境輸入 carthage update，Carthage 將自動下載所有相依模組至 Carthage/Checkouts 資料夾中，並編譯成 frameworks（或直接下載 pre-compiled framework）。 將 Carthage/Build 資料夾內編譯好的 frameworks 拖拉進你的 app target =&amp;gt; General =&amp;gt; Linked Frameworks and Libraries 在 app target =&amp;gt; Build Phases 下新增一個 New Run Script Phase # 自動將 framework 複製到 target app 的 bundle中 /usr/local/bin/carthage copy-frameworks 並在 Input Files 加入相依的 frameworks 路徑，例如：</description></item><item><title>Swift 初學速記</title><link>https://weihanglo.tw/posts/2017/swift-quick-note/</link><pubDate>Mon, 06 Feb 2017 23:25:19 +0800</pubDate><guid>https://weihanglo.tw/posts/2017/swift-quick-note/</guid><description>簡單記錄 Apple 官方 Swift Guide 的重點與心得。
（撰於 2017-02-06，基於 Swift 3.1）
Declaration 宣告變數使用 var，宣告常數使用 let
使用 var 宣告，該值為 mutable 使用 let 宣告，該值為 immutable let myConst = &amp;#34;constant&amp;#34; var myVar = 1234 myVar = 5678 慣例是都先使用 let 宣告，等到之後需求或 compiler 報錯時，再修正為 mutable 的 var
Type Inference 自動透過賦予的值推斷型別，也可以顯式聲明型別。
let doubleValue = 70.0 // Double type let myStr: String myStr = &amp;#34;1234&amp;#34; Type Safety Swift 是一個非常嚴謹的語言，注重型別安全（Type Safety）
宣告常數、變數時必須賦值或聲明顯示型別 常數、變數使用前必須給定初始值 型別無法任意轉換，必須顯式指定型別轉換。 Fundamental data type Swift Standard Library 定義了許多基本型別：</description></item><item><title>閱讀原始碼：Swift-Then</title><link>https://weihanglo.tw/posts/2017/readthesource-swift-then/</link><pubDate>Tue, 10 Jan 2017 12:15:34 +0800</pubDate><guid>https://weihanglo.tw/posts/2017/readthesource-swift-then/</guid><description>本系列文視筆者心情不定期撰寫。
提升程式設計能力的途徑，不外乎一個字「寫」。而另一個重要方法，則是「讀」。我們很容易將雜亂無章的想法轉化為程式碼，卻不易從程式碼反推回作者的意圖。藉由閱讀原始碼，可了解問題脈絡與解法邏輯，探討值得學習的技術點，將別人的多年修煉化為自身內功！
Programmer 不一定懶惰，但厲害的 programmer 絕對很懶惰！
Weihang Lo &amp;ndash; Daily Trash Talk
厲害的 programmer 會為了少打幾個字，犧牲睡眠與休閒時間來開發偷懶工具，
第一篇，先從簡單的 Framework 開始，Then 就非常有代表性。
（撰於 2017-01-10，基於 Swift 3.0、 Then 2.1.0）
Problem to Solve 我們知道，Block 的引入為古老的 Objective-C 增添了 lambda／closure 的現代感，Swift 則繼續將其發揚光大。有了 closure，我們不必將所有 UI 元件的設置全擠在 viewDidLoad 裡面。我們只需要：
let label: UILabel = { let label = UILabel() label.textAlignment = .center label.textColor = .black label.text = &amp;#34;Hello, World!&amp;#34; return label }() 可是對懶惰的 programmer 來說，這段程式碼太多地方重複，必定還有偷懶的空間。Then 這個迷你的語法糖 library 就是專為偷懶而生，目的就是將上面冗長的初始化設置簡寫如下：</description></item></channel></rss>